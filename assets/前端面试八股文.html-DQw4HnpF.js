import{_ as s,c as o,a,o as t}from"./app-UmXydJji.js";const e={};function c(l,n){return t(),o("div",null,[...n[0]||(n[0]=[a(`<h1 id="前端面试八股文及总结" tabindex="-1"><a class="header-anchor" href="#前端面试八股文及总结"><span>前端面试八股文及总结</span></a></h1><h2 id="day-1" tabindex="-1"><a class="header-anchor" href="#day-1"><span>Day 1</span></a></h2><p>好的，我们来模拟一次前端的深度技术面试。我将以<strong>面试官</strong>（I）和<strong>候选人</strong>（C）的角色进行一问一答</p><hr><h3 id="第一幕-javascript-中的事件循环机制" tabindex="-1"><a class="header-anchor" href="#第一幕-javascript-中的事件循环机制"><span><strong>第一幕：JavaScript 中的事件循环机制</strong></span></a></h3><p><strong>I：</strong> 请解释一下 JavaScript 中的事件循环机制。如果现在有一段包含 <code>setTimeout</code>、<code>Promise</code> 和 <code>async/await</code> 的代码，你能描述一下它们的执行顺序吗？</p><p><strong>C：</strong> 事件循环是 JS 实现异步的核心。它维护一个调用栈、一个微任务队列和一个宏任务队列。</p><ol><li>同步代码执行，遇到异步任务，根据类型分发：<code>setTimeout</code> 的回调进入宏任务队列，<code>Promise.then</code> 和 <code>async/await</code> 后的代码进入微任务队列。</li><li>当前调用栈清空后，会<strong>立即清空所有微任务</strong>。</li><li>然后从宏任务队列取出<strong>一个</strong>任务执行，执行完毕后再次检查并清空微任务队列，如此循环。</li></ol><p><strong>I：</strong> 那么，看这段代码，输出顺序是什么？</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;1&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;2&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;3&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;4&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">await</span> <span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;5&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;6&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></span>
<span class="line"><span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;7&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>C：</strong> 输出顺序是：<strong>1, 4, 6, 7, 3, 5, 2</strong>。 解析：</p><ol><li>同步输出 <code>1</code>。</li><li><code>setTimeout</code> 回调 <code>2</code> 放入宏任务队列。</li><li><code>Promise.then</code> 回调 <code>3</code> 放入微任务队列。</li><li>执行 <code>async1()</code>，同步输出 <code>4</code>。</li><li>执行 <code>await async2()</code>，同步输出 <code>6</code>。<strong><code>await</code> 后面的 <code>console.log(&#39;5&#39;)</code> 会被包裹成 Promise.then 的形式，放入微任务队列</strong>。</li><li>同步输出 <code>7</code>。</li><li>调用栈清空，清空微任务队列：按入队顺序输出 <code>3</code>，然后 <code>5</code>。</li><li>微任务清空后，执行下一个宏任务，输出 <code>2</code>。</li></ol><hr><h3 id="第二幕-浏览器输入-url-到页面显示过程" tabindex="-1"><a class="header-anchor" href="#第二幕-浏览器输入-url-到页面显示过程"><span><strong>第二幕：浏览器输入 URL 到页面显示过程</strong></span></a></h3><p><strong>I：</strong> 经典问题：从浏览器输入 URL 到页面显示，发生了什么？</p><p><strong>C：</strong> 这是一个综合过程：</p><ol><li><strong>网络过程</strong>：DNS解析 -&gt; 建立TCP连接（三次握手） -&gt; 发送HTTP请求 -&gt; 服务器处理并返回响应 -&gt; （如果是HTTPS，还有TLS握手）。</li><li><strong>浏览器解析与渲染</strong>： <ul><li><strong>构建DOM树</strong>：HTML解析器将字节流转换为DOM树。</li><li><strong>构建CSSOM树</strong>：解析CSS，生成CSS规则树。</li><li><strong>构建渲染树</strong>：合并DOM和CSSOM，排除不可见元素。</li><li><strong>布局</strong>：计算每个节点的几何信息（位置、大小）。</li><li><strong>绘制</strong>：将布局信息转换为屏幕上的实际像素。</li><li><strong>合成</strong>：将各图层合成，最终显示到屏幕上。</li></ul></li></ol><p><strong>I：</strong> 追问：在这个过程中，如何理解“重排”和“重绘”？如何避免或优化？</p><p><strong>C：</strong></p><ul><li><strong>重排</strong>：当元素的几何属性（宽、高、位置）发生变化，触发布局重新计算的过程。<strong>开销大</strong>。</li><li><strong>重绘</strong>：当元素的外观属性（颜色、背景、阴影）改变，但不影响布局时，会触发重绘。开销比重排小。</li><li><strong>优化</strong>： <ol><li><strong>避免频繁操作样式</strong>：合并多次DOM操作（使用<code>DocumentFragment</code>或修改<code>className</code>）。</li><li><strong>脱离文档流</strong>：对复杂动画使用<code>position: absolute/fixed</code>，使其脱离标准流，减少影响范围。</li><li><strong>GPU加速</strong>：对动画元素使用 <code>transform</code> 和 <code>opacity</code>，它们由合成器单独处理，跳过布局和绘制。</li></ol></li></ul><hr><h3 id="第三幕-vue-3-的响应式核心及与vue-2-对比" tabindex="-1"><a class="header-anchor" href="#第三幕-vue-3-的响应式核心及与vue-2-对比"><span><strong>第三幕： Vue 3 的响应式核心及与Vue 2 对比</strong></span></a></h3><p><strong>I：</strong> Vue 3 的响应式系统核心是什么？与 Vue 2 的 <code>Object.defineProperty</code> 相比有何优势？</p><p><strong>C：</strong> Vue 3 使用 <code>Proxy</code> 实现响应式。 <strong>优势</strong>：</p><ol><li><strong>直接代理整个对象</strong>：无需递归遍历所有属性，性能更好，初始化更快。</li><li><strong>动态监听属性增删</strong>：<code>Proxy</code> 可以拦截 <code>set</code> 和 <code>delete</code> 操作，而 <code>Object.defineProperty</code> 需要对新增属性手动调用 <code>Vue.set</code>。</li><li><strong>更好的数组监听</strong>：<code>Proxy</code> 可以拦截数组的索引修改、<code>length</code> 变化等所有操作。</li><li><strong>支持更多数据结构</strong>：可以原生支持 <code>Map</code>、<code>Set</code>、<code>WeakMap</code>、<code>WeakSet</code>。</li></ol><p><strong>I：</strong> 追问：你能简述一下 <code>Vue 3</code> 中 <code>ref</code> 和 <code>reactive</code> 的区别和使用场景吗？</p><p><strong>C：</strong></p><ul><li><code>reactive</code>：用于创建<strong>对象或数组</strong>的响应式代理。它接收一个对象，返回该对象的 <code>Proxy</code>。不能用于原始值。</li><li><code>ref</code>：用于创建一个包装器，使其具有响应式。它可以包装<strong>任何类型的值</strong>（包括原始值）。在模板和 <code>setup</code> 中会自动解包 <code>.value</code>。</li><li><strong>使用场景</strong>：当需要响应式的<strong>原始值</strong>（如字符串、数字、布尔值）时，必须使用 <code>ref</code>。当需要响应式的<strong>复杂对象</strong>时，优先使用 <code>reactive</code>，语法更简洁。</li></ul><hr><h3 id="第四幕-react-框架-理念与-hooks" tabindex="-1"><a class="header-anchor" href="#第四幕-react-框架-理念与-hooks"><span><strong>第四幕：React 框架 (理念与 hooks)</strong></span></a></h3><p><strong>I：</strong> 谈一谈你对 React Hooks 的理解。为什么不能在循环、条件或嵌套函数中调用 Hook？</p><p><strong>C：</strong> Hooks 是让函数组件拥有状态和生命周期等能力的功能函数。其核心规则是 <strong>“只在最顶层调用 Hook”</strong>。 <strong>原因</strong>：React 依赖于 <strong>Hook 的调用顺序</strong> 来正确关联每次渲染的 <code>state</code>。如果在条件语句中调用 Hook，会打乱这个顺序，导致后续 Hook 与之前的 <code>state</code> 错位匹配，引发 bug。React 内部通过一个“记忆单元格”链表来跟踪 Hook，顺序至关重要。</p><p><strong>I：</strong> 那么 <code>useEffect</code> 和 <code>useLayoutEffect</code> 有什么区别？</p><p><strong>C：</strong></p><ul><li><code>useEffect</code>：是<strong>异步</strong>执行的。它会在浏览器完成当前的布局与绘制<strong>之后</strong>才执行，不会阻塞浏览器的渲染。适合执行数据获取、订阅、手动修改 DOM（非即时）等副作用。</li><li><code>useLayoutEffect</code>：是<strong>同步</strong>执行的。它会在所有 DOM 变更之后、浏览器绘制<strong>之前</strong>同步执行。会阻塞浏览器的绘制。适合执行需要<strong>同步读取 DOM 布局</strong>或<strong>进行 DOM 样式修改</strong>（如测量元素、设置动画初始状态）的操作，以避免视觉上的闪烁。</li></ul><hr><h3 id="第五幕-webpack-与性能" tabindex="-1"><a class="header-anchor" href="#第五幕-webpack-与性能"><span>**第五幕： Webpack 与性能 **</span></a></h3><p><strong>I：</strong> Webpack 的核心概念有哪些？Tree Shaking 是如何工作的？</p><p><strong>C：</strong> 核心概念：<strong>入口、出口、Loader、Plugin、模式</strong>。 <strong>Tree Shaking</strong> 是一个通过静态分析来剔除项目中未使用代码（dead code）的优化技术。</p><ul><li><strong>工作原理</strong>： <ol><li><strong>依赖 ES6 模块语法</strong>：因为 ES Module 是静态的（<code>import/export</code>），可以在编译时分析出依赖关系。</li><li><strong>标记未使用代码</strong>：在编译阶段，Webpack 会分析出哪些 <code>export</code> 被 <code>import</code> 了，哪些没有被引用。</li><li><strong>在压缩阶段剔除</strong>：在代码压缩（如 TerserPlugin）阶段，将这些标记为“未使用”的代码安全地删除。</li></ol></li></ul><p><strong>I：</strong> 如果让你优化一个首屏加载过慢的 Vue/React 单页应用，你会从哪些方面入手？</p><p><strong>C：</strong> 这是一个系统工程：</p><ol><li><strong>分析</strong>：使用 Lighthouse、Webpack Bundle Analyzer 分析瓶颈（大资源、未压缩、无用代码）。</li><li><strong>加载优化</strong>： <ul><li><strong>代码分割</strong>：使用路由懒加载、组件异步加载，拆分主包。</li><li><strong>图片优化</strong>：使用 WebP 格式、懒加载、雪碧图、CDN。</li><li><strong>资源压缩</strong>：开启 Gzip/Brotli 压缩。</li></ul></li><li><strong>构建优化</strong>： <ul><li>升级 Webpack/Vite 到最新版。</li><li>配置 <code>splitChunks</code> 分离公共依赖。</li><li>开启 <code>Tree Shaking</code>。</li></ul></li><li><strong>缓存策略</strong>：为静态资源设置强缓存（<code>Cache-Control</code>）。</li><li><strong>运行时优化</strong>： <ul><li><strong>SSR/SSG</strong>：对于内容型网站，考虑服务端渲染或静态生成，提升首屏速度。</li><li><strong>骨架屏</strong>：提升用户体验感知。</li></ul></li></ol><hr>`,44)])])}const i=s(e,[["render",c]]),r=JSON.parse('{"path":"/posts/interview/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87.html","title":"前端面试八股文及总结","lang":"zh-CN","frontmatter":{"date":"2026-01-30T00:00:00.000Z","category":["前端面试"],"tag":["Vue3","React","JavaScript"]},"headers":[{"level":2,"title":"Day 1","slug":"day-1","link":"#day-1","children":[{"level":3,"title":"第一幕：JavaScript 中的事件循环机制","slug":"第一幕-javascript-中的事件循环机制","link":"#第一幕-javascript-中的事件循环机制","children":[]},{"level":3,"title":"第二幕：浏览器输入 URL 到页面显示过程","slug":"第二幕-浏览器输入-url-到页面显示过程","link":"#第二幕-浏览器输入-url-到页面显示过程","children":[]},{"level":3,"title":"第三幕： Vue 3 的响应式核心及与Vue 2 对比","slug":"第三幕-vue-3-的响应式核心及与vue-2-对比","link":"#第三幕-vue-3-的响应式核心及与vue-2-对比","children":[]},{"level":3,"title":"第四幕：React 框架 (理念与 hooks)","slug":"第四幕-react-框架-理念与-hooks","link":"#第四幕-react-框架-理念与-hooks","children":[]},{"level":3,"title":"**第五幕： Webpack 与性能 **","slug":"第五幕-webpack-与性能","link":"#第五幕-webpack-与性能","children":[]}]}],"git":{"updatedTime":1770271780000,"contributors":[{"name":"ksldnasx","username":"ksldnasx","email":"wh8261408@126.com","commits":2,"url":"https://github.com/ksldnasx"}],"changelog":[{"hash":"f3cf0d3098e765889213425f031f66042b28ba4e","time":1770271780000,"email":"wh8261408@126.com","author":"ksldnasx","message":"fix: 去除多余的点"},{"hash":"a0595edc4faeffd89ed0792f21cbdf342b813710","time":1769767628000,"email":"wh8261408@126.com","author":"ksldnasx","message":"feat: learning"}]},"filePathRelative":"posts/interview/前端面试八股文.md","excerpt":"\\n<h2>Day 1</h2>\\n<p>好的，我们来模拟一次前端的深度技术面试。我将以<strong>面试官</strong>（I）和<strong>候选人</strong>（C）的角色进行一问一答</p>\\n<hr>\\n<h3><strong>第一幕：JavaScript 中的事件循环机制</strong></h3>\\n<p><strong>I：</strong> 请解释一下 JavaScript 中的事件循环机制。如果现在有一段包含 <code>setTimeout</code>、<code>Promise</code> 和 <code>async/await</code> 的代码，你能描述一下它们的执行顺序吗？</p>"}');export{i as comp,r as data};
