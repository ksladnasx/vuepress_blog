import{_ as c,c as l,a as o,d as s,f as a,g as p,w as t,h as i,o as u}from"./app-UmXydJji.js";const r={};function d(k,n){const e=i("RouteLink");return u(),l("div",null,[n[6]||(n[6]=o('<h1 id="sse实践" tabindex="-1"><a class="header-anchor" href="#sse实践"><span>SSE实践</span></a></h1><h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述"><span>概述</span></a></h2><p>该实践基于nodejs的express框架搭建的后端，然后通过vuejs的前端进行请求学习。</p><p>后端部分通过设置SSE必需的响应头以及相应的定时器发送数据来建立sse接口，前端部分则通过<code>eventSource.value = new EventSource(sse数据接口地址)</code>来进行连接，利用<code>eventSource.value.onopen</code>,<code>eventSource.value.onmessage</code> 以及 <code>eventSource.value.addEventListener(&#39;自定义事件名&#39;，函数)</code>来实现对后端数据的接收。</p>',4)),s("p",null,[n[1]||(n[1]=a("当然有更方便不涉及业务逻辑的方式，就是封装一个类，具体见：",-1)),p(e,{to:"/posts/sse/sseService%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90.html"},{default:t(()=>[...n[0]||(n[0]=[a("sseService文件解析.js",-1)])]),_:1})]),n[7]||(n[7]=s("h2",{id:"代码",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#代码"},[s("span",null,"代码")])],-1)),s("p",null,[n[3]||(n[3]=a("前端主要组件代码：",-1)),p(e,{to:"/posts/codes/SSEDemoFronted.html"},{default:t(()=>[...n[2]||(n[2]=[a("SSEDemoFronted",-1)])]),_:1})]),s("p",null,[n[5]||(n[5]=a("后端nodejs代码：",-1)),p(e,{to:"/posts/codes/sseDomeServer.html"},{default:t(()=>[...n[4]||(n[4]=[a("sseDomeServer",-1)])]),_:1})]),n[8]||(n[8]=o(`<p>当服务器发送</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line">	res<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">&quot;event: status\\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    res<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">data: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">...</span>data<span class="token punctuation">,</span> <span class="token literal-property property">status</span><span class="token operator">:</span> <span class="token string">&quot;pause&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">\\n\\n</span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>浏览器的 EventSource 会把它识别为一个自定义事件名为 &quot;status&quot; 的事件。</p><p>前端通过 <code>addEventListener(&#39;status&#39;, handler) </code>或<code>es.onstatus</code>（非标准）来接收；没有<code>event: </code>行的消息走默认的 <code>onmessage</code>。</p><p>示例前端代码（最小、实际可用）：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token comment">// 建立连接</span></span>
<span class="line"><span class="token keyword">const</span> es <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EventSource</span><span class="token punctuation">(</span><span class="token string">&#39;/sse-data&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 接收默认消息（没有 event: 指定时）</span></span>
<span class="line">es<span class="token punctuation">.</span><span class="token function-variable function">onmessage</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">// e.data 是字符串，通常是 JSON 字符串</span></span>
<span class="line">  <span class="token keyword">try</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;default&#39;</span><span class="token punctuation">,</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></span>
<span class="line">  <span class="token keyword">catch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;default&#39;</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 接收自定义消息 event: status</span></span>
<span class="line">es<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;status&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">// e.data 同样是服务器发送的字符串</span></span>
<span class="line">  <span class="token keyword">const</span> payload <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;status event&#39;</span><span class="token punctuation">,</span> payload<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 可选：监听连接状态</span></span>
<span class="line">es<span class="token punctuation">.</span><span class="token function-variable function">onopen</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;SSE opened&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">es<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>es<span class="token punctuation">.</span>readyState <span class="token operator">===</span> EventSource<span class="token punctuation">.</span><span class="token constant">CLOSED</span><span class="token punctuation">)</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;SSE closed&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">else</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;SSE error&#39;</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>额外提示：</p><ul><li>服务器发送自定义事件时必须保证每条事件以空行结束（\\n\\n），否则不会触发。</li><li>data 可以跨多行（以 &quot;data:&quot; 开头多行），最终会合并为一条字符串。</li><li>若发送 JSON，前端需 JSON.parse(e.data)。</li><li>跨域时确保服务器返回允许的 CORS 头（你代码中已有 Access-Control-Allow-Origin）。</li></ul><h2 id="前端文字流处理部分代码" tabindex="-1"><a class="header-anchor" href="#前端文字流处理部分代码"><span>前端文字流处理部分代码</span></a></h2><h3 id="代码解析-流式文本处理-基于浏览器-readablestream-sse-协议" tabindex="-1"><a class="header-anchor" href="#代码解析-流式文本处理-基于浏览器-readablestream-sse-协议"><span>代码解析：流式文本处理（基于浏览器 ReadableStream + SSE 协议）</span></a></h3><p>这段代码是<strong>浏览器端基于 Fetch API 处理服务器推送的流式文本</strong>的核心逻辑（适配 SSE 协议），常用于 AI 对话、实时日志展示等场景，以下分模块拆解核心逻辑：</p><h4 id="一、核心功能概述" tabindex="-1"><a class="header-anchor" href="#一、核心功能概述"><span>一、核心功能概述</span></a></h4><p>异步发起流式请求 → 逐块读取服务器推送的二进制数据流 → 解码并解析符合 SSE 格式的文本 → 实时拼接展示文本 → 处理流式结束 / 异常 → 优化用户体验（自动滚动）。</p><h4 id="二、逐行-模块解析" tabindex="-1"><a class="header-anchor" href="#二、逐行-模块解析"><span>二、逐行 / 模块解析</span></a></h4><h5 id="_1-函数入口与状态控制-防重复请求" tabindex="-1"><a class="header-anchor" href="#_1-函数入口与状态控制-防重复请求"><span>1. 函数入口与状态控制（防重复请求）</span></a></h5><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span>isStreaming<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span></span>
<span class="line">outputText<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token string">&#39;&#39;</span><span class="token punctuation">;</span></span>
<span class="line">isStreaming<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>isStreaming.value</code>：响应式状态（如 Vue 的 ref），标记是否正在进行流式传输，避免重复发起请求；</li><li><code>outputText.value</code>：响应式状态，清空历史输出文本，准备接收新的流式内容。</li></ul><h5 id="_2-发起流式-fetch-请求" tabindex="-1"><a class="header-anchor" href="#_2-发起流式-fetch-请求"><span>2. 发起流式 Fetch 请求</span></a></h5><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">const</span> response <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">&#39;http://localhost:3000/stream-text&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>response<span class="token punctuation">.</span>ok <span class="token operator">||</span> <span class="token operator">!</span>response<span class="token punctuation">.</span>body<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&#39;流请求失败&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>向本地 <code>stream-text</code> 接口发起 GET 请求（默认）；</li><li>校验响应状态：<code>response.ok</code> 确保 HTTP 状态码为 200-299，<code>response.body</code> 确保返回<strong>可读流（ReadableStream）</strong>（流式接口核心特征）。</li></ul><h5 id="_3-流式数据读取-解码核心-api" tabindex="-1"><a class="header-anchor" href="#_3-流式数据读取-解码核心-api"><span>3. 流式数据读取 / 解码核心 API</span></a></h5><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">const</span> reader <span class="token operator">=</span> response<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">getReader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取流读取器</span></span>
<span class="line"><span class="token keyword">const</span> decoder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TextDecoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 二进制→字符串解码器</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>ReadableStreamDefaultReader</code>：浏览器原生 API，用于逐块读取 <code>response.body</code> 中的二进制数据流；</li><li><code>TextDecoder</code>：将 Uint8Array 格式的二进制块解码为 UTF-8 字符串（默认），处理多字节字符（如中文）跨块的场景。</li></ul><h5 id="_4-递归处理流式分块-核心逻辑" tabindex="-1"><a class="header-anchor" href="#_4-递归处理流式分块-核心逻辑"><span>4. 递归处理流式分块（核心逻辑）</span></a></h5><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">const</span> <span class="token function-variable function">processStream</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> done<span class="token punctuation">,</span> value <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">// 1. 流读取完毕的终止条件</span></span>
<span class="line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>done<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    isStreaming<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">return</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">  <span class="token comment">// 2. 解码当前二进制块（stream: true 保留未完成字符，避免解码错误）</span></span>
<span class="line">  <span class="token keyword">const</span> chunk <span class="token operator">=</span> decoder<span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">stream</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token comment">// 3. 拆分行：适配 SSE 协议（每行以 data: 开头传输数据）</span></span>
<span class="line">  <span class="token keyword">const</span> lines <span class="token operator">=</span> chunk<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">&#39;\\n&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">  <span class="token comment">// 4. 遍历解析每一行 SSE 格式数据</span></span>
<span class="line">  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> line <span class="token keyword">of</span> lines<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">&#39;data: &#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 筛选有效 SSE 数据行</span></span>
<span class="line">      <span class="token keyword">try</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">//line.substring(6) 是为了精准剔除 SSE 协议规定的 data: 前缀（注意：data: 后有一个空格所以为6）</span></span>
<span class="line">        <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </span>
<span class="line"></span>
<span class="line">        <span class="token comment">// 5. 处理流式结束标记</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">.</span>done<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">          isStreaming<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></span>
<span class="line">          <span class="token keyword">return</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">// 6. 拼接文本（区分换行符和普通字符）</span></span>
<span class="line">        outputText<span class="token punctuation">.</span>value <span class="token operator">+=</span> data<span class="token punctuation">.</span>char <span class="token operator">===</span> <span class="token string">&#39;\\n&#39;</span> <span class="token operator">?</span> <span class="token string">&#39;\\n&#39;</span> <span class="token operator">:</span> data<span class="token punctuation">.</span>char<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">// 7. 自动滚动：Vue nextTick 确保 DOM 更新后执行滚动</span></span>
<span class="line">        <span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">          <span class="token keyword">if</span> <span class="token punctuation">(</span>outputElement<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            outputElement<span class="token punctuation">.</span>value<span class="token punctuation">.</span>scrollTop <span class="token operator">=</span> outputElement<span class="token punctuation">.</span>value<span class="token punctuation">.</span>scrollHeight<span class="token punctuation">;</span></span>
<span class="line">          <span class="token punctuation">}</span></span>
<span class="line">        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">&#39;解析消息错误:&#39;</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 容错：JSON 解析失败不中断整个流</span></span>
<span class="line">      <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">  <span class="token comment">// 8. 递归读取下一个块：实现流式持续处理</span></span>
<span class="line">  <span class="token keyword">return</span> reader<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>processStream<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>入参 <code>{ done, value }</code>：<code>done</code> 为布尔值（流是否读取完毕），<code>value</code> 为当前读取的二进制块（Uint8Array）；</li><li>递归逻辑：<code>reader.read()</code> 读取下一个块 → 调用 <code>processStream</code> 处理 → 直到 <code>done === true</code>；</li><li>SSE 协议适配：服务器推送的流式数据需遵循「每行以 <code>data: </code>开头」的 SSE 格式，这是前端拆分 / 筛选的核心依据；</li><li>容错设计：JSON 解析异常仅打印日志，不终止整个流式处理。</li></ul><h5 id="_5-启动流式读取-全局异常捕获" tabindex="-1"><a class="header-anchor" href="#_5-启动流式读取-全局异常捕获"><span>5. 启动流式读取 + 全局异常捕获</span></a></h5><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token comment">// 启动第一次读取，读取器读取数据后结果作为参数给processStream并调用它，	触发递归</span></span>
<span class="line">reader<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>processStream<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">&#39;流式请求错误:&#39;</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  isStreaming<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 异常时重置状态</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>外层 <code>try-catch</code> 捕获 Fetch 请求、流读取过程中的所有异常，确保 <code>isStreaming</code> 状态最终重置为 <code>false</code>。</li></ul><h4 id="三、关键设计亮点" tabindex="-1"><a class="header-anchor" href="#三、关键设计亮点"><span>三、关键设计亮点</span></a></h4><ol><li><strong>防重复请求</strong>：通过 <code>isStreaming</code> 状态拦截重复调用；</li><li><strong>流式解码容错</strong>：<code>decoder.decode({ stream: true })</code> 处理多字节字符跨块问题；</li><li><strong>SSE 协议适配</strong>：按行拆分 + 筛选 <code>data: </code>前缀，符合主流流式接口规范；</li><li><strong>用户体验优化</strong>：<code>nextTick</code> 确保 DOM 更新后自动滚动到底部；</li><li><strong>异常容错</strong>：局部捕获 JSON 解析错误，全局捕获请求 / 流错误，避免整体崩溃。</li></ol>`,31))])}const m=c(r,[["render",d]]),b=JSON.parse(`{"path":"/posts/sse/SSE%E5%AE%9E%E8%B7%B5%E6%B5%8B%E8%AF%95.html","title":"SSE实践","lang":"zh-CN","frontmatter":{"date":"2025-12-01T00:00:00.000Z","category":["说明文档"],"tag":["SSE"]},"headers":[{"level":2,"title":"概述","slug":"概述","link":"#概述","children":[]},{"level":2,"title":"代码","slug":"代码","link":"#代码","children":[]},{"level":2,"title":"前端文字流处理部分代码","slug":"前端文字流处理部分代码","link":"#前端文字流处理部分代码","children":[{"level":3,"title":"代码解析：流式文本处理（基于浏览器 ReadableStream + SSE 协议）","slug":"代码解析-流式文本处理-基于浏览器-readablestream-sse-协议","link":"#代码解析-流式文本处理-基于浏览器-readablestream-sse-协议","children":[]}]}],"git":{"updatedTime":1765271411000,"contributors":[{"name":"ksldnasx","username":"ksldnasx","email":"wh8261408@126.com","commits":6,"url":"https://github.com/ksldnasx"}],"changelog":[{"hash":"38f5d2d76c8dd864b56b327c069ef5bcfd035c0c","time":1765271411000,"email":"wh8261408@126.com","author":"ksldnasx","message":"fix: link change"},{"hash":"acd93ed23f26117dad056c26ee821ccbe6fb6c2e","time":1765250440000,"email":"wh8261408@126.com","author":"ksldnasx","message":"style:开始页样式大改 fix:链接正确修改"},{"hash":"a0089923dda5b0a1e568fce8d29533128e78ce23","time":1765244359000,"email":"wh8261408@126.com","author":"ksldnasx","message":"fix:各类文件布局"},{"hash":"e25950c32aab29e5beb8db47779df8f87114bf2e","time":1764816433000,"email":"wh8261408@126.com","author":"ksldnasx","message":"feat:周总结 5 style:icon修改 fix:排版更新"},{"hash":"f162efcbe6e985bc8bde39ec7d4449f7e1489fe1","time":1764666751000,"email":"wh8261408@126.com","author":"ksldnasx","message":"feat:sse.  fix:link"},{"hash":"be6e122abe588c644e2bb3f542a67042af33aa82","time":1764585427000,"email":"wh8261408@126.com","author":"ksldnasx","message":"fix:排除code文件夹下的文章"}]},"filePathRelative":"posts/sse/SSE实践测试.md","excerpt":"\\n<h2>概述</h2>\\n<p>该实践基于nodejs的express框架搭建的后端，然后通过vuejs的前端进行请求学习。</p>\\n<p>后端部分通过设置SSE必需的响应头以及相应的定时器发送数据来建立sse接口，前端部分则通过<code>eventSource.value = new EventSource(sse数据接口地址)</code>来进行连接，利用<code>eventSource.value.onopen</code>,<code>eventSource.value.onmessage</code> 以及 <code>eventSource.value.addEventListener('自定义事件名'，函数)</code>来实现对后端数据的接收。</p>"}`);export{m as comp,b as data};
