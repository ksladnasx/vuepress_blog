import{_ as i,c as t,a as s,o as n}from"./app-UmXydJji.js";const r="/vuepress_blog/assets/page_table-fxMP01C0.png",p="/vuepress_blog/assets/page_algorithm-3KF3lpJP.png",e={};function o(d,l){return n(),t("div",null,[...l[0]||(l[0]=[s(`<h1 id="操作系统书后习题" tabindex="-1"><a class="header-anchor" href="#操作系统书后习题"><span>操作系统书后习题</span></a></h1><h2 id="第一章" tabindex="-1"><a class="header-anchor" href="#第一章"><span>第一章</span></a></h2><p><strong>1. 操作系统两大主要作用？</strong></p><ul><li>管理 CPU、内存、I/O 设备等硬件资源；</li><li>为用户 / 应用程序提供便捷的硬件抽象接口。</li></ul><p><strong>3. 分时系统和多道程序系统的区别？</strong></p><ul><li>分时系统：按时间片轮转调度，支持多用户交互，响应快；</li><li>多道程序系统：多个程序并发执行，仅提升 CPU 利用率，无交互性。</li></ul><p><strong>6. 为何 I/O 指令是特权指令？</strong></p><p>防止用户程序错误控制 I/O 设备，避免破坏硬件或系统资源，保障系统稳定性。</p><p><strong>10. 内核态与用户态的区别及设计意义？</strong></p><ul><li>区别：内核态可执行所有指令（含特权指令）、访问所有资源；用户态仅能执行非特权指令、访问受限资源；</li><li>意义：隔离用户程序与系统核心，防止用户程序破坏系统，提升安全性与稳定性。</li></ul><p><strong>12. 以下哪些是只能在内核态使用的指令？（选项：a 禁止所有中断、b 读时钟、c 设置日期 - 时间时钟、d 改变存储映像）</strong></p><p>答案：(a)、(c)、(d)</p><p>用户态能执行的指令，核心特征：<strong>仅作用于进程自身内存 / 数据，不影响系统全局、不操控硬件、执行错误只会让自身进程崩溃，不会导致系统故障</strong>，具体包含：</p><ol><li>所有<strong>基础数据运算指令</strong> ：加减乘除、逻辑运算、位运算等；</li><li>所有<strong>进程自身数据的读写指令</strong>：读写本进程虚拟地址空间内的变量、数组、文件缓冲区等（✅ 可写，不是只读）；</li><li>所有<strong>程序流程控制指令</strong>：条件判断、循环、函数调用 / 返回、跳转等；</li><li>部分<strong>只读式系统信息获取指令</strong>：仅读取时钟时间、系统版本等无修改权限的基础信息</li></ol><p><strong>13. 4 个程序 P1 (10ms)、P2 (20ms)、P3 (5ms)，在 2 个 CPU + 超线程的系统中运行，总运行时间？</strong></p><p>情况一：20ms（P1与P3在一个CPU上执行，P2 需 20ms在另外一个CPU上执行，两个CPU并行执行）</p><p>情况二：25ms( P2与P3在一个CPU上执行，P1在另外一个CPU上执行)</p><p>情况三：30ms ; 情况四：35ms</p><p><strong>23. 有一个文件,其文件描述符是fd,内含下列字 节序列:3, 1, 4, 1,5,9, 2, 6,5,3,5. 有如下系统调用: Iseek(fd, 3, SEEK_SET); read(fd, &amp;buffer, 4); 其中Iseek调用寻找文件中的字节3。在读操作 完成之后,buffer 中的内容是什么?</strong></p><ol><li><code>lseek(fd, 3, SEEK_SET)</code> 含义（必考）</li></ol><p><code>SEEK_SET</code> 表示 <strong>从文件开头绝对偏移</strong>，偏移 3 字节 = 把文件读写指针，定位到「文件索引为 3 的字节的位置」</p><p>👉 操作系统中，文件字节的索引（位置编号）<strong>永远从 0 开始</strong>，这是铁律！</p><ol start="2"><li><code>read(fd, &amp;buffer, 4)</code> 含义（必考）</li></ol><p>从指针定位的位置开始，<strong>连续向后读取 4 个字节</strong>，存入 buffer 中；只要文件剩余字节数足够，就直接读，✅ 无跳跃、✅ 无循环，是最基础的连续读取规则。则是从1开始，读四个字节。</p><p>答案：1、5、9、2</p><p><strong>27. 进程的地址空间与物理内存分离的好处？</strong></p><ol><li>进程地址空间隔离，防止进程间数据破坏，提升安全性；</li><li>支持虚拟内存，使进程可使用超过物理内存的地址空间，提升内存利用率。</li></ol><h2 id="第二章" tabindex="-1"><a class="header-anchor" href="#第二章"><span>第二章</span></a></h2><p><strong>1. 进程三状态（就绪、运行、阻塞）的剩余两种转换是否可能？</strong></p><p>不可能，剩余转换为 “就绪→阻塞” 和 “阻塞→运行”：</p><ul><li>就绪→阻塞：就绪进程<strong>未获得 CPU 使用权</strong>，无法主动发起 I/O 等阻塞操作，无法直接转换；</li><li>阻塞→运行：阻塞进程需先完成等待事件（如 I/O 完成），转为就绪态后，再由调度器选中才能进入运行态，不能直接转换。</li></ul><p><strong>6. 已知 RAM4GB（OS 占 512MB），进程各占 256MB，求使 CPU 利用率达 99% 的最大 I/O 等待时间占比？</strong></p><ol><li>计算可用内存：4GB - 512MB = 3584MB，最多同时运行进程数为 3584MB ÷ 256MB = 14 个；</li><li>CPU 利用率公式：1 减去每个进程 I/O 等待占比的 14 次方，结果需大于等于 99%（即 1 - p 的 14 次方 ≥ 0.99）；</li><li>推导得 p 的 14 次方 ≤ 0.01，计算后 p 约等于 0.72，故最大 I/O 等待时间占比约 72%。</li></ol><p><strong>9. 如何用多线程优化从镜像服务器下载 2GB 大文件的时间？</strong></p><ol><li><p>拆分文件：将 2GB 文件分成多个连续的字节块，每个块对应一个镜像服务器；</p></li><li><p>并行下载：创建多个线程，每个线程向对应的镜像服务器发起请求（指定块的起始和结束字节），同时下载各自负责的块；</p></li><li><p>合并文件：所有线程下载完成后，将各个字节块按原文件顺序拼接，生成完整文件</p><p>核心优势：充分利用多服务器的带宽资源，减少单线程下载的等待时间，提升整体下载效率。</p></li></ol><p><strong>18. 用户态实现线程的最大优缺点是什么？</strong></p><ul><li>最大优点：线程切换在用户态完成，不需要内核参与，切换开销小（无需切换内核态 / 用户态，上下文保存和恢复操作简单）；</li><li>最大缺点：<em><strong>内核无法感知用户级线程的存在</strong></em>，若一个用户级线程因 I/O 等操作阻塞，整个进程的所有用户级线程都会被阻塞；且无法利用多核 CPU（内核按进程调度，同一进程的用户级线程只能在一个 CPU 核心上运行）。</li></ul><p><strong>27. 用户级线程和内核级线程的栈，是每个线程一个栈还是每个进程一个栈？</strong></p><ul><li>用户级线程：每个线程一个栈。因为用户级线程是<strong>进程内独立的执行流</strong>，需要独立的栈存储局部变量、函数调用上下文等，确保执行互不干扰；</li><li>内核级线程：每个线程一个栈。内核级线程是<strong>内核直接调度的独立实体</strong>，每个线程需具备独立的用户栈（用于用户态执行）和内核栈（用于内核态处理中断、系统调用等操作）。</li></ul><p><strong>36. 快餐店雇员（领班→厨师→打包员→收银员）的进程通信模型是什么？与 UNIX 的联系？</strong></p><ul><li>通信模型：流式管道通信。数据按 “领班→厨师→打包员→收银员” 的顺序，单向、有序传递，前一个环节的输出作为后一个环节的输入；</li><li>与 UNIX 的联系：UNIX 系统中的管道（pipe）就是基于该模型实现的，用于进程间单向、顺序的字节流通信（例如父子进程间通过管道传递数据）。</li></ul><p><strong>39. 代码中连续执行两次 fork ()，会创建多少个子进程？</strong></p><p>共创建 3 个子进程，原理如下：</p><ol><li>第一次 fork ()：父进程创建 1 个子进程，此时系统中共有 2 个进程（父进程、子进程 1）；</li><li>第二次 fork ()：当前的 2 个进程（父进程、子进程 1）<strong>都会执行 fork ()</strong>，各自创建 1 个子进程（子进程 2、子进程 3）；</li><li>总进程数为 2 的 2 次方 = 4 个，减去原始的 1 个父进程，最终子进程数为 3 个（公式：<strong>2 的 n 次方 - 1，n 为 fork () 执行次数</strong>）。</li></ol><p><strong>44. 作业运行时间分别为 9、6、3、5、X，按什么顺序运行能得到最短平均响应时间？（依 X 取值而定）</strong></p><p>采用短作业优先（SJF）调度算法，按作业运行时间升序排列，分情况如下：</p><ul><li>若 X≤3：顺序为 X、3、5、6、9；</li><li>若 3＜X≤5：顺序为 3、X、5、6、9；</li><li>若 5＜X≤6：顺序为 3、5、X、6、9；</li><li>若 6＜X≤9：顺序为 3、5、6、X、9；</li><li>若 X＞9：顺序为 3、5、6、9、X。</li></ul><p><strong>45. .有5个批处理作业A~E,它们几乎同时到达一 个计算中心。作业 A (运行时间 10，优先级 3)、B (6，5)、C (2，2)、D (4，1)、E (8，4)（优先级 5 最高），计算各调度算法的平均周转时间（作业到达时间均为 0，周转时间 = 完成时间 - 到达时间）？</strong></p><p>对于轮转法,假设系统具有多道程序处理能力, 每个作业均公平共享CPU时间,对</p><ul><li><p><strong>轮转法</strong> 每个作业均公平共享CPU时间：</p><p><strong>没说就确定时间片是几个数的最大公约数</strong></p><p>这里所有进程同时到达，时刻是2 ； 这里取2，；</p><p>但是他的总周转时间 = 每个进程完成时间之和；</p><p><strong>单个进程的带权周转时间</strong>带权周转时间的本质是<strong>周转时间与实际运行时间的比值</strong></p><p>每个进程的带权周转时间 = 完成时间 / 实际cpu分给他的时间（题干那个时间）</p><p>平均带权周转时间 = 所有带权周转时间之和 / 个数</p><p>总周转时间 - 所有进程的实际的总的运行时间（10+6+2+4+8） = 所有进程总共的等待时间 （除以进程个数就是平均等待时间）</p><p>时间片轮转就是一个队列轮转着来。</p><p>如果每个作业到达时间不一样，优先级有影响。例如此时是<code>p1-&gt;p2-&gt;p3</code> ,在运行p3，p3结束后放入队尾的时候如果p4进入，要对比p3和p4的优先级。如果如果优先级<code>p4&lt;p3</code>,则此时队列是<code>p4-&gt;p3-&gt;p2-&gt;p1</code> ；优先级<code>p4&gt;p3</code>，则此时队列是<code>p3-&gt;p4-&gt;p2-&gt;p1</code>。</p></li><li><p>优先级调度（<strong>按优先级从高到低</strong>）：</p><p>执行顺序：B、E、A、C、D；</p><p>完成时间：B (6)、E (14)、A (24)、C (26)、D (30)；</p><p>平均周转时间：(6+14+24+26+30)÷5=20；</p></li><li><p>先来先服务（按 A、B、C、D、E 顺序）：</p><p>完成时间：A (10)、B (16)、C (18)、D (22)、E (30)；</p><p>平均周转时间：(10+16+18+22+30)÷5=19.2；</p></li><li><p>最短作业优先（按运行时间从短到长）：</p><p>执行顺序：C、D、B、E、A；</p><p>完成时间：C (2)、D (6)、B (12)、E (20)、A (30)；</p><p>平均周转时间：(2+6+12+20+30)÷5=14。</p></li><li><p>高响应比优先（HRRN）：选择 “响应比最高” 的进程（响应比 =（等待时间 + 运行时间）/ 运行时间）</p></li></ul><p>**47. 系统中有 2 个周期 5ms（CPU 时间 1ms）的电话任务，1 个周期 33ms（CPU 时间 11ms）的视频流任务，实时系统是否可调度？**采用速率单调调度（RMS）判断，可调度，步骤如下：</p><ol><li>计算各任务的 CPU 利用率： <ul><li>每个电话任务利用率：1ms÷5ms=0.2；</li><li>视频流任务利用率：11ms÷33ms≈0.333；</li><li>总利用率：0.2+0.2+0.333=0.733；</li></ul></li><li>RMS 最大可调度利用率（3 个任务）：3×(2 的三分之一次方 -1)≈0.78；</li><li>因总利用率 0.733≤0.78，故系统可调度。</li></ol><h3 id="线程的定义和作用-线程与进程的联系与区别、线程的类型" tabindex="-1"><a class="header-anchor" href="#线程的定义和作用-线程与进程的联系与区别、线程的类型"><span>线程的定义和作用；线程与进程的联系与区别、线程的类型</span></a></h3><ul><li><p>线程（轻量级进程 LWP）</p><ul><li>定义：进程内的 “执行单元”，是 OS 调度的基本单位（比进程更小，开销更低）。</li><li>作用：减少进程切换开销，提高并发效率（如浏览器的多个标签页对应多个线程，共享浏览器进程的资源）。</li></ul></li><li><p>线程与进程的联系与区别</p><table><thead><tr><th>维度</th><th>进程</th><th>线程</th></tr></thead><tbody><tr><td>资源分配</td><td>资源分配的基本单位（有独立地址空间）</td><td>不分配资源（共享所属进程的资源）</td></tr><tr><td>调度</td><td>调度的基本单位（早期 OS）</td><td>调度的基本单位（现代 OS）</td></tr><tr><td>切换开销</td><td>大（需切换地址空间、资源上下文）</td><td>小（仅切换执行上下文，如 PC、寄存器）</td></tr><tr><td>并发性</td><td>进程间并发</td><td>进程内线程并发 + 进程间并发</td></tr><tr><td>生命周期</td><td>独立（父进程终止不影响子进程）</td><td>依赖进程（进程终止，线程全部终止）</td></tr><tr><td>通信方式</td><td>需进程通信（共享存储、消息传递）</td><td>直接共享进程资源（全局变量、文件）</td></tr></tbody></table></li><li><p>线程的类型</p><ol><li>用户级线程（ULT） <ul><li>管理主体：用户态线程库（如 POSIX 线程库），OS 内核不感知线程存在。</li><li>优点：切换开销小（用户态完成），灵活；缺点：一个线程阻塞，整个进程阻塞（内核只调度进程）。</li></ul></li><li>内核级线程（KLT） <ul><li>管理主体：OS 内核，每个线程对应一个内核线程（KT）。</li><li>优点：线程阻塞不影响其他线程，并发效率高；缺点：切换开销大（需内核态）。</li></ul></li><li><strong>混合级线程</strong>：用户级线程映射到内核级线程（如 N:M 映射），兼顾灵活性和并发效率（现代 OS 常用）。</li></ol></li></ul><h3 id="信号量实现生产者-消费者问题" tabindex="-1"><a class="header-anchor" href="#信号量实现生产者-消费者问题"><span>信号量实现生产者 - 消费者问题</span></a></h3><p><strong>题目</strong>：使用信号量实现有界缓冲区（大小为 100）的生产者 - 消费者问题，要求保证缓冲区访问的互斥和同步。<strong>解析步骤</strong>：</p><ol><li><p>定义信号量：</p><ul><li>mutex：互斥信号量，保护缓冲区访问，初始值 1。</li><li>empty：同步信号量，标识空缓冲区数量，初始值 100。</li><li>full：同步信号量，标识满缓冲区数量，初始值 0。</li></ul></li><li><p>生产者进程：先申请空缓冲区（P (empty)），再申请互斥锁（P (mutex)），放入数据后释放互斥锁（V (mutex)），最后通知消费者（V (full)）。</p></li><li><p>消费者进程：先申请满缓冲区（P (full)），再申请互斥锁（P (mutex)），取出数据后释放互斥锁（V (mutex)），最后通知生产者（V (empty)）。</p><p>代码实现</p><p>（伪代码）：</p></li></ol><div class="language-plaintext line-numbers-mode" data-highlighter="prismjs" data-ext="plaintext"><pre><code><span class="line">#define N 100</span>
<span class="line">typedef int semaphore;</span>
<span class="line">semaphore mutex = 1, empty = N, full = 0;</span>
<span class="line"></span>
<span class="line">void producer() {</span>
<span class="line">    int item;</span>
<span class="line">    while (TRUE) {</span>
<span class="line">        item = 生产数据;</span>
<span class="line">        P(empty);  // 申请空缓冲区</span>
<span class="line">        P(mutex);  // 申请互斥锁</span>
<span class="line">        将item放入缓冲区;</span>
<span class="line">        V(mutex);  // 释放互斥锁</span>
<span class="line">        V(full);   // 通知消费者有数据</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">void consumer() {</span>
<span class="line">    int item;</span>
<span class="line">    while (TRUE) {</span>
<span class="line">        P(full);   // 申请满缓冲区</span>
<span class="line">        P(mutex);  // 申请互斥锁</span>
<span class="line">        从缓冲区取出item;</span>
<span class="line">        V(mutex);  // 释放互斥锁</span>
<span class="line">        V(empty);  // 通知生产者有空位</span>
<span class="line">        消费item;</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="一二章知识点" tabindex="-1"><a class="header-anchor" href="#一二章知识点"><span>一二章知识点</span></a></h2><h3 id="一、简要记忆" tabindex="-1"><a class="header-anchor" href="#一、简要记忆"><span>一、简要记忆</span></a></h3><p><strong>第一章 操作系统基础核心考点</strong></p><ol><li>操作系统核心作用：管理 CPU、内存、I/O 等硬件资源，为用户和程序提供简洁的硬件操作接口。</li><li>分时系统与多道程序系统区别：多道程序系统仅实现程序并发、提升 CPU 利用率，无交互性；分时系统按时间片轮转调度，支持多用户实时交互，响应速度快。</li><li>特权指令与内核态、用户态：特权指令（如 I/O、中断控制）仅能在核心态执行，防止用户程序破坏系统；内核态权限最高，可访问所有资源，用户态权限受限，二者隔离是为保障系统安全稳定。</li><li>地址空间与物理内存分离优势：实现进程地址隔离，提升安全性；支持虚拟内存，让进程可用空间突破物理内存限制。</li><li>多核并行计算规律：程序总运行时间由耗时最长的单个程序决定，其余程序可并行完成。</li></ol><p><strong>第二章 进程线程与调度核心考点</strong></p><ol><li>进程三状态核心：就绪、运行、阻塞，就绪→阻塞、阻塞→运行这两种转换绝对不可能发生；就绪进程需等调度才会运行，阻塞进程需先转为就绪再运行。</li><li>核心计算公式：①CPU 利用率 = 1-pⁿ（p 为单进程 I/O 等待占比，n 为并发进程数）；②n 次 fork 创建子进程数 = 2ⁿ-1。</li><li>线程核心考点：多线程下载大文件，核心是拆分文件、并行下载、合并文件，优势是提升效率；用户级线程切换开销小，内核无感知，不支持多核，一个线程阻塞则整个进程阻塞；内核级线程由内核调度，支持多核，线程阻塞不影响进程，两类线程均为每个线程一个独立栈。</li><li>进程通信：流式管道通信是单向有序的流水线式数据传递，UNIX 的 pipe 机制基于此实现，适用于进程间字节流的单向传输。</li><li>作业调度算法：短作业优先按运行时间升序调度，平均周转时间最短；优先级调度按优先级高低执行；时间片轮转均分 CPU，轮流响应，响应快无饿死；先来先服务按到达顺序执行，计算均需算平均周转时间（周转时间 = 完成时间 - 到达时间）。</li><li>实时调度 RMS：判断任务是否可调度，先算各任务利用率（执行时间 / 周期）求和，<strong>总利用率不超 n×(2^(1/n)-1) 即可调度</strong>，任务周期越短优先级越高。</li></ol><h3 id="二、进程与线程管理模块" tabindex="-1"><a class="header-anchor" href="#二、进程与线程管理模块"><span>二、进程与线程管理模块</span></a></h3><ol><li><strong>进程状态与转换</strong><ul><li>核心状态：就绪（等待 CPU）、运行（占用 CPU）、阻塞（等待事件，如 I/O）</li><li>不可能的转换：<code>就绪→阻塞</code>（就绪进程未获 CPU，无法发起阻塞操作）；<code>阻塞→运行</code>（阻塞进程需先转为就绪，再被调度）</li></ul></li><li><strong>操作系统的核心作用</strong><ul><li>管理硬件资源（CPU、内存、I/O 设备）；为用户 / 应用程序提供硬件抽象接口</li></ul></li><li><strong>分时系统 vs 多道程序系统</strong><ul><li>分时系统：按时间片轮转调度，支持多用户交互，响应快</li><li>多道程序系统：多程序并发执行，仅提升 CPU 利用率，无交互性</li></ul></li><li><strong>特权指令的意义</strong><ul><li>定义：仅能在内核态执行的指令（如 I/O 指令）</li><li>原因：防止用户程序错误控制硬件，保护系统资源与稳定性</li></ul></li><li><strong>内核态与用户态</strong><ul><li>区别：内核态可执行所有指令、访问所有资源；用户态仅能执行非特权指令、访问受限资源</li><li>设计意义：隔离用户程序与系统核心，提升安全性与稳定性</li></ul></li><li><strong>线程相关</strong><ul><li>用户级线程：每个线程一个栈；优点是切换开销小，缺点是内核无法感知（一个线程阻塞则进程阻塞）</li><li>内核级线程：每个线程一个栈；内核直接调度，可利用多核</li></ul></li><li><strong>进程通信模型</strong><ul><li>流式管道通信：数据单向、顺序传递（如快餐店雇员的 “领班→厨师→打包员” 流程）；对应 UNIX 的<code>pipe</code>机制</li></ul></li><li><strong>fork 创建子进程</strong><ul><li>规则：每次 fork 会复制进程，子进程也会执行后续代码；<code>n次fork</code>的子进程数为<code>2ⁿ - 1</code></li></ul></li><li><strong>作业调度算法</strong><ul><li>短作业优先（SJF）：按作业时长升序排列，获最短平均响应时间（依作业时长动态调整顺序）</li><li>轮转法（RR）：时间片轮流转，公平共享 CPU；完成时间需按时间片循环分配计算</li><li>优先级调度：按优先级（高优先）执行</li><li>先来先服务（FCFS）：按作业到达顺序执行</li><li>平均周转时间：<code>(各作业完成时间之和) ÷ 作业数</code></li></ul></li><li><strong>实时调度（速率单调 RMS）</strong><ul><li>判断可调度的条件：<strong>总 CPU 利用率 ≤ <code>n×(2^(1/n)-1)</code>（n 为任务数）</strong>；总利用率低于阈值则可调度</li></ul></li></ol><h2 id="第三章" tabindex="-1"><a class="header-anchor" href="#第三章"><span>第三章</span></a></h2><h3 id="一、连续内存分配算法-对应题-4" tabindex="-1"><a class="header-anchor" href="#一、连续内存分配算法-对应题-4"><span>一、连续内存分配算法（对应题 4）</span></a></h3><p>用于为进程分配连续的内存空间，核心是 “选择空闲区的规则”：</p><ul><li><strong>首次适配</strong>：按内存地址顺序，找<strong>第一个</strong>能容纳进程的空闲区，然后指针回到开头</li><li><strong>最佳适配</strong>：找<strong>最小</strong>能容纳进程的空闲区（减少空间浪费）</li><li><strong>最差适配</strong>：找<strong>最大</strong>的空闲区（避免频繁分割小空闲区）</li><li><strong>下次适配</strong>：从<strong>上次分配空闲区的下一个空闲区</strong>开始，按地址顺序找能容纳的空闲区</li></ul><p>例题：在一个交换系统中,按内存地址排列的空闲区大小是10MB、4MB、20MB、18MB、7MB、9MB、12MB和15MB。对于连续的段请求:(a) 12MB、(b) 10MB、(c) 9MB 。使用首次适配算法,将找出哪个空闲区?使用最佳适配、最差适配、下次适配算法呢?</p><p><strong>初始空闲区</strong>（按地址顺序）：<br> 10 MB, 4 MB, 20 MB, 18 MB, 7 MB, 9 MB, 12 MB, 15 MB</p><hr><p><strong>(1) 首次适配（First Fit）</strong><br> ① 请求 12 MB → 扫描：10(不够) → 4(不够) → 20(够, 分配) → 剩余 8 MB。<br> 列表变为：10, 4, 8, 18, 7, 9, 12, 15。<br> ② 请求 10 MB → 扫描：10(刚好) → 分配，移出。<br> 列表：4, 8, 18, 7, 9, 12, 15。<br> ③ 请求 9 MB → 扫描：4(不够) → 8(不够) → 18(够) → 分配后剩 9 MB。</p><p>将找出 20 MB区； 10 MB区；18 MB区。</p><hr><p><strong>(2) 最佳适配（Best Fit）</strong><br> ① 请求 12 MB → 候选：20, 18, 12, 15 → 最小满足是 12 MB → 分配并移出。<br> 列表：10, 4, 20, 18, 7, 9, 15。<br> ② 请求 10 MB → 候选：10, 20, 18, 15 → 最小满足是 10 MB → 移出。<br> 列表：4, 20, 18, 7, 9, 15。<br> ③ 请求 9 MB → 候选：20, 18, 9, 15 → 最小满足是 9 MB → 移出。</p><p>将找出 12 MB区；10 MB区；9 MB区。</p><hr><p><strong>(3) 最差适配（Worst Fit）</strong><br> ① 请求 12 MB → 候选：20, 18, 12, 15 → 最大是 20 MB → 剩 8 MB。<br> 列表：10, 4, 8, 18, 7, 9, 12, 15。<br> ② 请求 10 MB → 候选：10, 18, 12, 15 → 最大是 18 MB → 剩 8 MB。<br> 列表：10, 4, 8, 8, 7, 9, 12, 15。<br> ③ 请求 9 MB → 候选：10, 12, 15 → 最大是 15 MB → 剩 6 MB。</p><p>将找出 20 MB区；18 MB区；15 MB区。</p><hr><p><strong>(4) 下次适配（Next Fit）</strong><br> 指针初始在起点。<br> ① 请求 12 MB：从第一块开始扫描 → 10(不够) → 4(不够) → 20(够) → 分配剩 8 MB，指针<strong>移到下一块</strong>（原18 MB块）。<br> 列表：10, 4, 8, 18, 7, 9, 12, 15。<br> ② 请求 10 MB：从指针处（18 MB块）开始 → 18(够) → 分配剩 8 MB，指针移到下一块（7 MB块）。<br> 列表：10, 4, 8, 8, 7, 9, 12, 15。<br> ③ 请求 9 MB：从指针处（7 MB块）开始 → 7(不够) → 9(刚好) → 分配移出。</p><p>将找出 20 MB区；18 MB区；9 MB区。</p><hr><p><strong>最终答案表</strong></p><table><thead><tr><th>算法</th><th>12 MB请求来源</th><th>10 MB请求来源</th><th>9 MB请求来源</th></tr></thead><tbody><tr><td>首次适配</td><td>20 MB区</td><td>10 MB区</td><td>18 MB区</td></tr><tr><td>最佳适配</td><td>12 MB区</td><td>10 MB区</td><td>9 MB区</td></tr><tr><td>最差适配</td><td>20 MB区</td><td>18 MB区</td><td>15 MB区</td></tr><tr><td>下次适配</td><td>20 MB区</td><td>18 MB区</td><td>9 MB区</td></tr></tbody></table><h3 id="二、分页存储管理-对应题-7" tabindex="-1"><a class="header-anchor" href="#二、分页存储管理-对应题-7"><span>二、分页存储管理（对应题 7）</span></a></h3><p>将虚拟地址拆分为 “页号 + 页内偏移”，通过页表映射到物理内存，核心是<strong>虚拟地址转物理地址的步骤</strong>：</p><ol><li>计算：页号 = 虚拟地址 ÷ 页面大小；页内偏移 = 虚拟地址 % 页面大小</li><li>查页表：找到页号对应的<strong>页框号</strong></li><li>计算物理地址：物理地址 = 页框号 × 页面大小 + 页内偏移</li></ol><p>例：使用图3-9的页表,给出下面每个虚拟地址对应的物理地址: (a) 20、(b) 4100、(c) 8300</p><p><img src="`+r+'" alt="图3-9 页表"></p><p>显然看图说话，虚拟地址20对应的线指向8k-12k的部分的页，起址为8192（8*1024），然后页内偏移 = 虚拟地址 % 页面大小=20</p><p>则物理地址 = 对应地址起始值+ 页内偏移 = 8192+20 =8212 。同理可得，b的物理地址4100，c的物理地址24684</p><h3 id="分页原理-逻辑地址到页号和页内偏移量的转换方法-两种-公式和二进制" tabindex="-1"><a class="header-anchor" href="#分页原理-逻辑地址到页号和页内偏移量的转换方法-两种-公式和二进制"><span>分页原理；逻辑地址到页号和页内偏移量的转换方法（两种：公式和二进制）</span></a></h3><ul><li>分页原理 <ul><li>逻辑地址空间：分为 n 个逻辑页（页号 0、1、2…n-1），每页大小为 2^k 字节（如 4KB=2^12 字节）。</li><li>物理内存：分为 m 个物理块（块号 0、1、2…m-1），<strong>块大小 = 页大小</strong>（保证页能装入块）。</li></ul></li><li><strong>逻辑地址结构</strong>：逻辑地址 = 页号（高位） + 页内偏移量（低位）。</li><li>转换方法 <ol><li>公式法 <ul><li>页号 = 逻辑地址 ÷ 页大小（整除）；</li><li>页内偏移量 = 逻辑地址 % 页大小（取余）。</li><li>例子：页大小 4KB（4096），逻辑地址 10000 → 页号 = 10000÷4096=2，页内偏移量 = 10000%4096=1808。</li></ul></li><li>二进制法 <ul><li>页大小 = 2^k → 页内偏移量占 k 位，页号占剩余高位。</li><li>例子：页大小 4KB（2^12），逻辑地址 16 位 → 低 12 位是页内偏移量，高 4 位是页号。</li></ul></li></ol></li></ul><h3 id="请求分页的地址变换" tabindex="-1"><a class="header-anchor" href="#请求分页的地址变换"><span>请求分页的地址变换</span></a></h3><p>在普通页式地址映射基础上增加 “缺页检查”：</p><ol><li>拆分逻辑地址为页号和页内偏移量；</li><li>查找页表，检查存在位（P）；</li><li>若 P=1：按普通页式映射计算物理地址；</li><li>若 P=0：触发缺页中断，OS 调入页面后，再执行步骤 3。</li></ol><h3 id="三、页面置换算法-对应题-28、36" tabindex="-1"><a class="header-anchor" href="#三、页面置换算法-对应题-28、36"><span>三、页面置换算法（对应题 28、36）</span></a></h3><p>当内存页框不足时，替换已装入的页面，核心是 “替换哪个页面的规则”：</p><ul><li><p>FIFO（先进先出 first in first out）：</p><ul><li>规则：替换<strong>最早装入页框</strong>的页面</li><li>特点：易出现 “Belady 异常”（页框数增加，缺页次数反而变多）</li></ul></li><li><p>LRU（最近最少使用 least recent use）：</p><ul><li>规则：替换<strong>最久未被访问</strong>的页面</li><li>特点：需记录页面的访问时间，反映 “局部性原理”</li></ul></li><li><p>NRU（最近未使用 not recent use）：</p><ul><li>规则：按 “<strong>R 位（最近访问标记）+ M 位（修改标记）</strong>” 的优先级置换（优先级：<strong>R=0&amp;M=0 &lt; R=0&amp;M=1 &lt; R=1&amp;M=0 &lt; R=1&amp;M=1</strong>）</li></ul></li><li><p>最佳置换算法（OPT）：选择 “未来最长时间不被访问” 的页面换出；实际无法实现（无法预知未来访问）</p></li><li><p>时钟算法（Clock）（第二次机会算法）：</p><ul><li>规则：基于 FIFO，先检查页面的 <strong>R 位</strong>；</li><li>若 R=1，置 R=0 并放到队尾，给他第二次机会；直到找到 R=0 的页面置换</li><li>如果引用位 R= 0，置换该页，新页放入该位置，引用位R置为 1，新页加入<strong>队尾</strong>。</li></ul></li><li><p>时钟算法改良算法（既有R又有M的情况）：</p><p>考虑 <strong>(R, M)</strong> 两位组合，优先级顺序如下（从最佳置换候选到最差置换候选）：</p><ol><li><strong>(0, 0)</strong>：最近未使用，未被修改（干净页）——最好换出，无需写回磁盘。</li><li><strong>(0, 1)</strong>：最近未使用，但被修改过（脏页）——需要写回磁盘，开销较大。</li><li><strong>(1, 0)</strong>：最近使用过，但干净——可能很快又用，尽量保留。</li><li><strong>(1, 1)</strong>：最近使用过且脏——最不该换出。</li></ol><p>置换规则：</p><ol><li>扫描循环队列，检查每一页的 (R, M)。</li><li>寻找第一个 <strong>(0, 0)</strong> 页直接换出。</li><li>如果没有 (0, 0)，寻找 (0, 1)，但在找到前如果遇到 (1, 0) 或 (1, 1)，将 R 位清 0（给第二次机会）并继续扫描。</li><li>如果扫描一轮没找到可换的，再扫第二轮时必定会有 (0, 0) 或 (0, 1)（因为 R 位已被清过一次），优先选 (0, 0)。</li></ol></li></ul><h4 id="页面置换算法例题" tabindex="-1"><a class="header-anchor" href="#页面置换算法例题"><span><strong>页面置换算法例题</strong></span></a></h4><p>1.<strong>如果将FIFO页面置换算法用到4个页框和8个页面上,若初始时页框为空,访问序列串为0172327103,请问会发生多少次缺页中断?如</strong></p><p><strong>果使用LRU算法呢?</strong></p><hr><p><strong>1. FIFO 算法</strong></p><p>初始页框：空，8个页面指的就是0-7这八个页面。</p><p>访问顺序： <strong>0 1 7 2 3 2 7 1 0 3</strong></p><p>页框数量 = 4。(按进入顺序，<strong>最前面的是最早装入的</strong>)</p><table><thead><tr><th>访问</th><th>页框内容</th><th>FIFO替换选择</th><th>缺页？</th></tr></thead><tbody><tr><td>0</td><td>[0]</td><td>-</td><td>✔</td></tr><tr><td>1</td><td>[0, 1]</td><td>-</td><td>✔</td></tr><tr><td>7</td><td>[0, 1, 7]</td><td>-</td><td>✔</td></tr><tr><td>2</td><td>[0, 1, 7, 2]</td><td>-</td><td>✔</td></tr><tr><td>3</td><td>[1, 7, 2, 3]</td><td>换出 0</td><td>✔</td></tr><tr><td>2</td><td>[1, 7, 2, 3]</td><td>已在内存</td><td></td></tr><tr><td>7</td><td>[1, 7, 2, 3]</td><td>已在内存</td><td></td></tr><tr><td>1</td><td>[1, 7, 2, 3]</td><td>已在内存</td><td></td></tr><tr><td>0</td><td>[7, 2, 3, 0]</td><td>换出 1</td><td>✔</td></tr><tr><td>3</td><td>[7, 2, 3, 0]</td><td>已在内存</td><td></td></tr></tbody></table><p><strong>FIFO 缺页次数：</strong><br> 前 5 个访问已经缺页 5 次（因为填满 4 页框 + 第 5 次访问新页 3 缺页）。<br> 之后在第 9 个访问 0 时又缺页 1 次。<br> 合计 = 6 次缺页。</p><hr><p><strong>2. LRU 算法</strong></p><p>注意动态调整页框内容的顺序，数组按最近最少使用排序，<strong>最近使用的放最后</strong>，这样方便后续替换。</p><table><thead><tr><th>访问</th><th>页框内容</th><th>替换选择</th><th>缺页？</th></tr></thead><tbody><tr><td>0</td><td>[0]</td><td>-</td><td>✔</td></tr><tr><td>1</td><td>[0, 1]</td><td>-</td><td>✔</td></tr><tr><td>7</td><td>[0, 1, 7]</td><td>-</td><td>✔</td></tr><tr><td>2</td><td>[0, 1, 7, 2]</td><td>-</td><td>✔</td></tr><tr><td>3</td><td>[1, 7, 2, 3]</td><td>换出 0</td><td>✔</td></tr><tr><td>2</td><td>[1, 7, 3, 2]</td><td>已在内存，访问2后把它移到最新位置</td><td></td></tr><tr><td>7</td><td>[1, 3, 2, 7]</td><td>已在内存，访问7后移到最新位置</td><td></td></tr><tr><td>1</td><td>[3, 2, 7, 1]</td><td>已在内存，访问1后移到最新位置</td><td></td></tr><tr><td>0</td><td>[2, 7, 1, 0]</td><td>换出 3</td><td>✔</td></tr><tr><td>3</td><td>[7, 1, 0, 3]</td><td>换出 2</td><td>✔</td></tr></tbody></table><p>仔细跟踪 LRU 顺序（用列表尾部表示最近访问过，头部是最久未使用的）：</p><p><strong>LRU 缺页次数：</strong><br> 发生在访问 0, 1, 7, 2, 3, 0, 3 这 7 个位置。<br> 缺页次数 = <strong>7</strong>。</p><hr><p><strong>最终答案：</strong></p><ul><li><strong>FIFO 缺页次数</strong> = <strong>6</strong></li><li><strong>LRU 缺页次数</strong> = <strong>7</strong></li></ul><p><img src="'+p+'" alt="页面置换算法"></p><p>显然NRU算法 移除页面 2，FIFO 算法移除页面 3，LRU算法 移除页面 1，Second chance 算法移除页面 2（找第一个R=0且M=0的）。</p><h3 id="四、磁盘-i-o-时间计算-对应题-35" tabindex="-1"><a class="header-anchor" href="#四、磁盘-i-o-时间计算-对应题-35"><span>四、磁盘 I/O 时间计算（对应题 35）</span></a></h3><p>磁盘访问一个页面的总时间由三部分组成，核心是<strong>时间构成 + 计算逻辑</strong>：</p><ul><li>单个页面的访问时间 = 寻道时间（移动磁臂到目标柱面） + 旋转延迟（等待目标扇区转到磁头下） + <strong>传输时间</strong>（读写数据）</li><li>传输时间 = 页面大小 ÷（每磁道容量 ÷ 磁盘旋转周期）</li><li>磁盘旋转周期 = 2* 平均旋转延迟</li><li>总时间（页面随机分布）= 页面数 × 单个页面访问时间</li></ul><p><strong>例题：从平均寻道时间10ms、旋转延迟时间10ms、 每磁道32KB的磁盘上载入一个64KB的程序, 对于下列页面大小分别需要多少时间才能载入这64K的程序? (a)页面大小为2KB。 (b) 页面大小为4KB。 假设页面随机地分布在磁盘上,柱面的数目非常大,以致于两个页面在同一个柱面的概率可 以忽略不计。</strong></p><p>(a) 680 ms； (b) 360 ms；</p><h2 id="第四章" tabindex="-1"><a class="header-anchor" href="#第四章"><span>第四章</span></a></h2><h3 id="一、索引节点-i-节点-的文件大小计算" tabindex="-1"><a class="header-anchor" href="#一、索引节点-i-节点-的文件大小计算"><span>一、索引节点（i 节点）的文件大小计算</span></a></h3><p><strong>核心逻辑</strong>：仅考虑直接地址时，文件最大大小 = 直接地址数量 × 单个磁盘块大小</p><p><strong>例题（题 16）：考虑图 4-13 中的 i 节点，含 4 字节表示的 10 个直接地址，磁盘块大小是 1024KB，文件最大可能有多大？</strong></p><p>解题：文件最大大小 = 10 个直接地址 × 1024KB / 块 = 10240KB（即 10MB）</p><h3 id="二、文件分配方式的适用场景" tabindex="-1"><a class="header-anchor" href="#二、文件分配方式的适用场景"><span>二、文件分配方式的适用场景</span></a></h3><p><strong>核心逻辑</strong>：</p><ul><li><p>连续分配：适合大小固定的文件，随机访问快；但不适合动态变化的文件（易碎片、扩展难）</p></li><li><p>链表分配：适合动态变化的文件，无碎片；但随机访问慢</p></li><li><p>索引分配：<strong>适合大小动态变化</strong>的文件，支持随机访问；开销略高</p></li></ul><p><strong>例题（题 18）：一个大小在 4KB 和 4MB 间变化的文件，连续、链表、索引三种分配方式中哪个最合适？</strong></p><p>解题：选索引分配。因为文件大小动态变化，索引分配既支持动态调整，又能实现随机访问。</p><h3 id="dma的工作原理和通道的工作原理" tabindex="-1"><a class="header-anchor" href="#dma的工作原理和通道的工作原理"><span>DMA的工作原理和通道的工作原理</span></a></h3><ul><li>DMA 的工作原理 <ul><li>核心硬件：DMA 控制器（独立于 CPU 的硬件）。</li><li>工作过程： <ol><li>进程请求 I/O（如读取硬盘数据），CPU 向 DMA 控制器发送命令（设备地址、内存地址、传输长度）；</li><li>CPU 继续执行其他任务，<strong>DMA 控制器控制设备与内存直接交换数据</strong>；</li><li>数据传输完成后，DMA 控制器向 CPU 发中断；</li><li>CPU 响应中断，通知进程 I/O 完成。</li></ol></li><li>核心优势：CPU 无需参与数据传输，仅需发命令和处理中断，极大提高 CPU 利用率。</li></ul></li><li>通道的工作原理 <ul><li>核心硬件：通道处理器（专用的 I/O 处理器，有自己的指令系统）。</li><li>工作过程： <ol><li>CPU 向通道发送 “通道程序”（包含 I/O 命令、设备地址、内存地址）；</li><li>通道执行通道程序，控制设备与内存交换数据，可同时控制多个设备；</li><li>所有 I/O 完成后，通道向 CPU 发中断；</li><li>CPU 响应中断，处理后续工作。</li></ol></li><li>核心优势：CPU 只需启动通道，无需干预 I/O 过程，支持多设备并发，适合大型系统。</li></ul></li></ul><h3 id="spooling技术" tabindex="-1"><a class="header-anchor" href="#spooling技术"><span>SPOOLING技术</span></a></h3><ul><li><strong>定义</strong>：Simultaneous Peripheral Operations On-Line（联机并行外围操作），是一种将独占设备转换为虚拟设备的技术。</li><li><strong>核心思想</strong>：利用磁盘作为 “缓冲区”，将进程的 I/O 请求缓存到磁盘的 “输入井” 或 “输出井”，再由 “井管理程序” 依次将请求提交给物理设备。</li><li>组成部分 <ol><li>输入井：磁盘上的区域，存放进程的输入数据（从输入设备读入）。</li><li>输出井：磁盘上的区域，存放进程的输出数据（待输出到设备）。</li><li>输入井管理程序：控制输入设备将数据写入输入井。</li><li>输出井管理程序：控制输出井的数据写入输出设备。</li><li>虚拟设备：进程访问的逻辑设备（对应输入井 / 输出井）。</li></ol></li><li>例子（虚拟打印机） <ol><li>多个进程提交打印任务，OS 将打印数据写入输出井；</li><li>输出井管理程序按顺序将数据发送给物理打印机；</li><li>进程无需等待打印完成，可继续执行（异步 I/O）。</li></ol></li><li><strong>优点</strong>：提高独占设备利用率，实现多进程并发 I/O，提高系统吞吐量。</li></ul><h3 id="三、硬链接与符号链接的优缺点" tabindex="-1"><a class="header-anchor" href="#三、硬链接与符号链接的优缺点"><span>三、硬链接与符号链接的优缺点</span></a></h3><p><strong>核心逻辑</strong>：</p><ul><li><p>硬链接优点：不占用额外磁盘空间（仅新增目录项）；删除原文件后，硬链接仍可访问文件内容</p></li><li><p>符号链接优点：可跨文件系统链接；可链接目录（硬链接通常不能链接目录）</p></li></ul><h3 id="四、空闲磁盘空间管理-空闲块表-vs-位图" tabindex="-1"><a class="header-anchor" href="#四、空闲磁盘空间管理-空闲块表-vs-位图"><span>四、空闲磁盘空间管理（空闲块表 vs 位图）</span></a></h3><p><strong>核心逻辑</strong>：</p><ol><li><p>空间开销：</p><ul><li>空闲块表空间 = 空闲块数（F） × 磁盘地址对应的字节数（D 字节）</li><li>位图空间 = 总块数（B） ÷ 8（1 位表示 1 个块）</li></ul></li><li><p>空闲块表空间更少的条件：F × D &lt; B / 8</p><p>例题（题 24）磁盘地址需 D 位，磁盘有 B 个块、F 个空闲。什么条件下空闲块表空间少于位图？若 D=16 位，计算空闲磁盘空间的百分比。</p></li></ol><ul><li>条件：当 D=16 位（即 2 字节）时，代入得 2F &lt; B/8 → F/B &lt; 1/16 = 6.25%，即空闲磁盘空间百分比需小于 6.25%。</li></ul><h3 id="五、空闲块位图的状态变化" tabindex="-1"><a class="header-anchor" href="#五、空闲块位图的状态变化"><span>五、空闲块位图的状态变化</span></a></h3><p><strong>核心逻辑</strong>：</p><ul><li><p>分配块：对应位设为 1；释放块：对应位设为 0</p></li><li><p>分配规则：从最小编号的空闲块（位为 0 的位置）开始分配</p></li></ul><p><strong>例题（题 25）空闲块位图初始为1000 0000 0000 0000（块 0 被占），文件 A 写入6 块后位图为1111 1110 0000 0000，完成以下操作后位图状态：(a) 写入 5 块的文件 B；(b) 删除文件 A；(c) 写入 8 块的文件 C；(d) 删除文件 B</strong></p><ul><li><p>(a) 写文件 B（5 块）：占块 8-12 → 位图：<code>1111 1111 1111 0000</code></p></li><li><p>(b) 删除文件 A（即删除A写入的块）：释放块 1-6 → 位图：<code>1000 0001 1111 0000</code></p></li><li><p>(c) 写文件 C（8 块）：按顺序写入空闲块→ 位图：<code>1111 1111 1111 1100</code></p></li><li><p>(d) 删除文件 B：释放块 8-12 → 位图：<code>1111 1110 0000 1100</code></p></li></ul><h3 id="六、磁盘块的内部碎片" tabindex="-1"><a class="header-anchor" href="#六、磁盘块的内部碎片"><span>六、磁盘块的内部碎片</span></a></h3><p><strong>核心逻辑</strong>：内部碎片比例 = （磁盘块大小 - 文件大小） ÷ 磁盘块大小 × 100%；实际文件系统碎片更大（因小文件多、含元数据开销）</p><p><strong>例题（题 37）：某个文件系统使用2KB的磁盘块,而中间文件 大小值为1KB。如果所有的文件都是正好1KB 大,那么浪费掉的磁盘空间的比例是多少?你 认为一个真正的文件系统所浪费的空间比这个 数值大还是小?请说明理由</strong></p><ul><li>碎片比例：（2KB - 1KB）÷ 2KB × 100% = 50%</li><li>实际更大：因为实际存在更多小于此块大小的小文件，且有目录、元数据等额外开销。</li></ul><h3 id="七、索引节点-直接-间接地址-的最大文件大小" tabindex="-1"><a class="header-anchor" href="#七、索引节点-直接-间接地址-的最大文件大小"><span>七、索引节点（直接 + 间接地址）的最大文件大小</span></a></h3><p><strong>核心逻辑</strong>：</p><ol><li>间接块指针数 = 间接块大小 ÷ 指针地址大小</li><li>总块数 = 直接地址数 + 间接块指针数</li><li>最大文件大小 = 总块数 × 磁盘块大小</li></ol><p><strong>例题（题 38）：磁盘块大小 4KB，块指针地址 4 字节，用 10 个直接地址和 1 个间接块，可访问的最大文件大小是多少字节？</strong></p><ul><li>间接块指针数：4KB ÷ 4 字节 = 1024</li><li>总块数：10 + 1024 = 1034</li><li>最大文件大小：1034 × 4KB = 1034 × 4096 字节 = 4235264 字节</li></ul><h2 id="第五章" tabindex="-1"><a class="header-anchor" href="#第五章"><span>第五章</span></a></h2><h3 id="一、中断驱动-i-o-的适用性评估" tabindex="-1"><a class="header-anchor" href="#一、中断驱动-i-o-的适用性评估"><span>一、中断驱动 I/O 的适用性评估</span></a></h3><p><strong>核心逻辑</strong>：判断中断驱动 I/O 是否有意义，需计算中断总开销占 CPU 时间的比例；若开销过高（接近 / 超过 CPU 可分配时间），则无意义。</p><p><strong>例题（题 12）：一个典型文本打印页面含 50 行，每行 80 个字符。打印机每分钟打印 6 个页面，打印每个字符请求一次中断，中断服务花费 50μs。使用中断驱动的 I/O 运行该打印机有没有意义？</strong></p><ol><li>计算每分钟打印字符数：50 行 ×80 字符 / 行 ×6 页面 = 24000 字符</li><li>计算中断总开销：24000 字符 ×50μs / 字符 = 1200000μs=1.2 秒</li><li>开销占比：1.2 秒 / 60 秒 = 2%，CPU 额外开销极低，因此<strong>有意义</strong>。</li></ol><h3 id="二、i-o-软件的四层结构" tabindex="-1"><a class="header-anchor" href="#二、i-o-软件的四层结构"><span>二、I/O 软件的四层结构</span></a></h3><p><strong>核心逻辑</strong>：I/O 软件分为四层，各层功能：</p><ul><li>用户层 I/O 软件：处理用户请求的格式转换；</li><li>设备独立性软件：设备分配、权限检查；</li><li>设备驱动程序：计算设备操作参数、写设备寄存器；</li><li>中断处理程序：响应设备中断（本题未涉及）。</li></ul><p><strong>例题（题 14）以下工作是在四个 I/O 软件层的哪一层完成的？</strong></p><p>(a) <strong>为</strong>一个磁盘读操作<strong>计算</strong>磁道、扇区、磁头；(b) 向设备寄存器<strong>写命令</strong>；</p><p>(c) <strong>检查用户</strong>是否允许使用设备；(d) 将二进制整数<strong>转换成 ASCII 码</strong>以便打印。</p><p>解题：(a) 设备驱动程序；(b) 设备驱动程序；(c) 设备独立性软件；(d) 用户层 I/O 软件</p><h3 id="三、磁盘扇区的读入时间计算" tabindex="-1"><a class="header-anchor" href="#三、磁盘扇区的读入时间计算"><span>三、磁盘扇区的读入时间计算</span></a></h3><p><strong>核心逻辑</strong>：读入一个扇区的时间 = 旋转延迟 + 传输时间；</p><ul><li>旋转延迟：磁盘半圈的时间，公式为<code>1/(2×转速（转/秒）)</code>；</li><li>传输时间：一个扇区的传输时间，公式为<code>1/(柱面扇区数×转速（转/秒）)。</code></li></ul><p><strong>例题（题 18）一个磁盘的转速为 7200rpm，一个柱面上有 500 个扇区，每个扇区大小为 512B。读入一个扇区需要多少时间？</strong></p><ol><li>转速转换为转 / 秒：7200rpm ÷ 60=120 转 / 秒</li><li>旋转延迟：1/(2×120)≈0.00417 秒 = 4.17ms</li><li>传输时间：1/(500×120)≈0.0000167 秒 = 0.0167ms</li><li>总时间：4.17ms+0.0167ms≈<strong>4.19ms</strong></li></ol><h3 id="四、磁盘容量、磁道斜进与数据传输率计算" tabindex="-1"><a class="header-anchor" href="#四、磁盘容量、磁道斜进与数据传输率计算"><span>四、磁盘容量、磁道斜进与数据传输率计算</span></a></h3><p><strong>核心逻辑</strong>：</p><ul><li><p>磁盘容量：各区域（柱面数 × 磁头数 × 扇区数）× 扇区大小，累加各区域容量；</p></li><li><p>该区域内的最优磁道斜进（单位：扇区） = 在寻道时间内磁盘转过的圈数 × 区域扇区数</p></li><li><p>假设连续读取一个文件，文件占满一个磁道后要继续到相邻磁道读取。 从当前磁道最后一个扇区到下一磁道第一个扇区，需要做两件事：</p><ol><li>磁头移动到相邻柱面（寻道）耗时 1 ms</li><li>磁盘在这 1 ms 内仍在旋转，等寻道结束，原来在磁头下的扇区已经转过去了</li></ol><p>如果不做斜进，那么逻辑上的“下一扇区”在物理上可能需要转几乎一圈才能到磁头下，造成大的旋转延迟。</p></li><li><p>最大数据传输率：转速 × 一个柱面的扇区数 × 扇区大小。</p></li></ul><p><strong>例题（题 28）考虑一个包含 16 个磁头和 400 个柱面的磁盘。该磁盘分成 4 个 100 柱面的区域，不同区域分别包含 160、200、240 和 280 个扇区。每个扇区含 512 字节，相邻柱面平均寻道时间 1ms，磁盘转速 7200rpm。计算磁盘容量、最优磁道斜进以及最大数据传输率。</strong></p><ol><li><p>磁盘容量：</p><p>区域 1：100×16×160×512=131072000B=131.072MB</p><p>区域 2：100×16×200×512=163840000B=163.84MB</p><p>区域 3：100×16×240×512=196608000B=196.608MB</p><p>区域 4：100×16×280×512=229376000B=229.376MB</p><p>总容量：131.072+163.84+196.608+229.376=720.896MB</p></li><li><p><strong>最优磁道斜进：</strong></p><p>我们分步讲解看最优磁道斜进的计算逻辑。</p><hr><p><strong>已知条件：</strong></p><ul><li>相邻柱面寻道时间：1 ms</li><li>磁盘转速：7200 rpm</li><li>各区域每磁道扇区数分别为 160、200、240、280</li><li>磁道斜进是指同一逻辑扇区在相邻磁道上物理位置偏移的扇区数</li></ul><hr><p><strong>1. 算出一圈的旋转时间</strong> 转速 7200 转/分钟<br> 转一圈时间 = 60 ÷ 7200 ≈ 8.333 ms</p><hr><p><strong>2. 最优斜进怎么算</strong> 目标：<strong>寻道结束后，磁头刚好位于下一磁道的“逻辑第一扇区”的物理位置</strong><br> 在 1 ms 寻道期间磁盘转过的角度 = (1 ms ÷ 8.333 ms) × 1圈 ≈ 0.12 圈</p><p>这个角度对应的扇区数，取决于每磁道有多少扇区。<br> 不同区域每磁道扇区数不同：</p><ul><li>区域1：160 扇区 → 0.12 × 160 ≈ 19.2 扇区</li><li>区域2：0.12 × 200 ≈ 24 扇区</li><li>区域3：0.12 × 240 ≈ 28.8 扇区</li><li>区域4：0.12 × 280 ≈ 33.6 扇区</li></ul><hr><p><strong>3. ps: 如果斜进固定一个值，应该选哪个作为斜进？</strong> 如果斜进固定一个值，要保证所有区域在寻道 1 ms 后都能刚好对准或超前，必须选择<strong>最大的扇区偏移数</strong>，即 34 扇区。</p><p>但有时题目会假设按“平均扇区数”算，因为统一斜进无法同时满足所有区域。<br> 平均扇区数 = (160+200+240+280)/4 = 220<br> 0.12 × 220 ≈ 26.4 扇区 → 取整 26</p><p>通常教材例题答案可能是 26 扇区，这是平衡设计。</p></li><li><p>最大数据传输率：</p><p>转速转 / 秒：7200÷60=120 转 / 秒</p><p>传输率：120×280×512=17203200 字节 / 秒</p></li></ol><h3 id="五、磁盘调度算法的寻道时间计算" tabindex="-1"><a class="header-anchor" href="#五、磁盘调度算法的寻道时间计算"><span>五、磁盘调度算法的寻道时间计算</span></a></h3><p><strong>核心逻辑</strong>：</p><ul><li><p>先来先服务（FCFS）：按请求顺序移动磁臂，总寻道时间 = 总移动柱面数 × 每个柱面时间；</p></li><li><p>最近柱面优先（SSTF）：移动到最近的请求柱面，计算总移动柱面数 × 每个柱面时间；</p></li><li><p>电梯算法（SCAN）：初始向一个方向移动，处理完该方向请求后回到起始点然后<strong>反向</strong>，计算总移动柱面数 × 每个柱面时间。</p></li></ul><p><strong>例题（题 31）磁盘请求以柱面 10、22、20、2、40、6 和 38 的次序进入，寻道时每个柱面移动需要 6ms，磁臂起始于柱面 20。计算各算法的寻道时间：(a) 先来先服务；(b) 最近柱面优先；(c) 电梯算法（初始向上移动）。</strong></p><ol><li><p>(a) 先来先服务：路径：20→10→22→20→2→40→6→38（磁臂起始于柱面 20）</p><p>移动柱面数：10（20→10）+12（10→22）+2+18+38+34+32=146 （路径之间差值和）</p><p>寻道时间：146×6ms=876ms</p></li><li><p>(b) 最近柱面优先：路径：20→22→38→40→10→6→2</p><p>移动柱面数：2+16+2+30+4+4=58</p><p>寻道时间：58×6ms=348ms</p></li><li><p>(c) 电梯算法（初始向上）：</p><p>路径：20→22→38→40→20→10→6→2</p><p>移动柱面数：2+16+2+20+10+4+4=58</p><p>寻道时间：58×6ms=348ms</p></li></ol><h2 id="第六章" tabindex="-1"><a class="header-anchor" href="#第六章"><span>第六章</span></a></h2><h3 id="一、死锁检测算法的应用" tabindex="-1"><a class="header-anchor" href="#一、死锁检测算法的应用"><span>一、死锁检测算法的应用</span></a></h3><p><strong>核心逻辑</strong>（银行家算法，拿着A一个个去对每个进程的请求<code>Ri</code>，能分配就分配然后将该进程的已分配的资源<code>Ci</code>释放到A(加到A)）：</p><ol><li><strong>C（Claim / 最大需求矩阵）</strong> —— 每个进程声明需要每种资源的最大数量。</li><li><strong>A（Allocation / 已分配矩阵）</strong> —— 当前已分配给每个进程的资源数量。</li><li><strong>R（Request / 当前请求矩阵）</strong> —— 每个进程当前还请求多少资源才能完成。</li><li><strong>E（Existing / 系统资源总量）</strong></li><li><strong>A_v（Available / 当前可用资源向量）</strong></li></ol><p>死锁检测步骤为：</p><ol><li>寻找一个<strong>没有标记</strong>的进程<code>Pi</code>,对于它而言R矩阵的第<code>i</code>行向量小于或等于A。</li><li>如果找到了这样一个进程,那么将C矩阵的第<code>i</code>行向量**加到A中,**标记该进程,并转到第1步。</li><li>如果没有这样的进程,那么算法终止。 算法结束时,所有没有标记过的进程(如果存在的话)都是死锁进程。</li></ol><p><strong>例题（题 14）系统有 4 个进程 P1-P4，5 种资源 RS1-RS5，已分配矩阵 C、需求矩阵 R、可用资源 E=(2,4,1,4,4)、已分配总和 A=(0,1,0,2,1)。用死锁检测算法说明系统存在死锁，并识别死锁进程。</strong></p><p>确认需求矩阵 R（题目已给出），可用资源 E=(2,4,1,4,4)；</p><p>每个进程已分配资源：C1 = 0 1 1 2； C2 = 0 1 0 1 0 ；C3 =0 0 0 0 1 ；C4 = 2 1 0 0 0</p><p>检查进程：</p><p>首先，未标记的进程集合 P = (P1 P2 P3 P4) P1 剩余需求 R1=(1,0,2,1,1)，R1 不小于或等于 A,无法分配并释放P1的资源。 P2 剩余需求 R2=(0,1,0,2,1)，R2 小于 A；标记 P2；A = (0,2,0,3,1)；P = (P1 ，P3， P4) P1 剩余需求R1 不小于或等于 A；P = (P3 ，P4，P1 ) P3 剩余需求 R3=(0,2,0,3,1)，R3 等于 A；标记 P3；<code>加上C3</code>; A = (0,2,0,3,2)；P = (P1，P4) P1 剩余需求 R1仍 不小于或等于 A；P = (P4，P1) P4 剩余需求 R4=(0,2,1,1,0)，R4 不小于或等于 A<br> 因此，进程 P1 和 P4 仍未标记。它们处于死锁状态。</p><h3 id="二、死锁可能性的判断-基于资源数与进程需求" tabindex="-1"><a class="header-anchor" href="#二、死锁可能性的判断-基于资源数与进程需求"><span>二、死锁可能性的判断（基于资源数与进程需求）</span></a></h3><p><strong>核心逻辑</strong>：判断是否可能死锁，需结合死锁的必要条件（互斥、占有等待、不可剥夺、循环等待），同时计算 “资源数是否能满足进程的最大需求”：若<code>资源数≥进程数 x（每个进程最大需求 - 1）+ 1</code>，则不会死锁。</p><p><strong>例题（题 22）</strong>：系统有 2 个进程、3 个相同资源，每个进程最多需要 2 个资源。是否可能发生死锁？为什么？</p><p>解题：不可能发生死锁。原因：计算 “资源数下限”：进程数 x（每个进程最大需求 - 1）+ 1=1+ 2*(2-1)=3，当前资源数恰好为 3；当资源数≥该下限，无论进程如何请求，总能有一个进程获得足够资源完成，释放资源后其他进程也能完成，不满足 “循环等待” 等死锁条件。</p><h3 id="三、安全状态与可用资源的最小值" tabindex="-1"><a class="header-anchor" href="#三、安全状态与可用资源的最小值"><span>三、安全状态与可用资源的最小值</span></a></h3><p><strong>核心逻辑</strong>：安全状态需存在 “安全序列”（进程按序列依次完成，释放资源后后续进程可完成）。步骤：</p><ol><li><p>计算<strong>剩余需求</strong>(也就是R矩阵)：剩余需求 = 最大需求量 - 已分配资源；</p></li><li><p>遍历进程，寻找 “剩余需求≤可用资源” 的进程，标记后释放其已分配资源到可用资源；</p></li><li><p>重复步骤 2，若所有进程都能被标记，则状态安全；据此确定可用资源的最小值。</p></li></ol><p><strong>例题（题 26）系统有 4 个进程、5 个可分配资源，已分配、最大需求量、可用资源为 (0,0,x,1,1)。求保持安全状态的 x 最小值。</strong></p><p>计算各进程的剩余需求：最大 - 已分配</p><ul><li>进程 A：(1,1,2,1,3)-(1,0,2,1,1)=(0,1,0,0,2)；</li><li>进程 B：(2,2,2,1,0)-(2,0,1,1,0)=(0,2,1,0,0)；</li><li>进程 C：(2,1,3,1,0)-(1,1,0,1,0)=(1,0,3,0,0)；</li><li>进程 D：(1,1,2,2,1)-(1,1,1,1,0)=(0,0,1,1,1)；</li></ul><p>初始可用资源为 (0,0,x,1,1)，尝试 x 的最小值：</p><p>当 x=1 时，可用资源为 (0,0,1,1,1)：</p><ul><li><p>进程 D 的剩余需求 (0,0,1,1,1)≤可用资源，标记 D；释放其已分配 (1,1,1,1,0)，可用资源更新为 (1,1,2,2,1)；</p></li><li><p>进程 A 的剩余需求 (0,1,0,0,2)≤可用资源，标记 A；释放已分配 (1,0,2,1,1)，可用资源更新为 (2,1,4,3,2)；</p></li><li><p>进程 B 的剩余需求 (0,2,1,0,0)≤可用资源，标记 B；释放已分配 (2,0,1,1,0)，可用资源更新为 (4,1,5,4,2)；</p></li><li><p>进程 C 的剩余需求 (1,0,3,0,0)≤可用资源，标记 C；所有进程完成，状态安全。</p><p>因此 x 的最小值为1。</p></li></ul><h3 id="四、预防死锁-破除-占有等待-条件-的方法改进" tabindex="-1"><a class="header-anchor" href="#四、预防死锁-破除-占有等待-条件-的方法改进"><span>四、预防死锁（破除 “占有等待” 条件）的方法改进</span></a></h3><p><strong>核心逻辑</strong>：原方法（请求新资源前释放已有资源）的问题是 “丢失原有资源”，改进思路是 “先保留原有资源的使用权，直到新资源分配成功”。</p><p><strong>例题（题 31）</strong>：预防死锁的方法之一是请求新资源前释放已有资源，但会导致进程丢失原有资源。给出该方法的改进。</p><p>解题：改进方法：进程请求新资源时，<strong>先申请新资源，若新资源分配成功，再保留原有资源；若新资源分配失败，才释放原有资源并进入等待</strong>。或：引入 “资源预留” 机制，进程先声明所需资源，系统为其预留（不实际分配），当所有所需资源都能预留时，再一次性分配所有资源（同时破除 “占有等待” 条件，避免资源丢失）。</p>',218)])])}const g=i(e,[["render",o]]),h=JSON.parse('{"path":"/posts/classlearning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E5%90%8E%E9%A2%98%E7%9B%AE.html","title":"操作系统书后习题","lang":"zh-CN","frontmatter":{"date":"2026-01-03T00:00:00.000Z","category":["期末复习"],"tag":["操作系统"]},"headers":[{"level":2,"title":"第一章","slug":"第一章","link":"#第一章","children":[]},{"level":2,"title":"第二章","slug":"第二章","link":"#第二章","children":[{"level":3,"title":"线程的定义和作用；线程与进程的联系与区别、线程的类型","slug":"线程的定义和作用-线程与进程的联系与区别、线程的类型","link":"#线程的定义和作用-线程与进程的联系与区别、线程的类型","children":[]},{"level":3,"title":"信号量实现生产者 - 消费者问题","slug":"信号量实现生产者-消费者问题","link":"#信号量实现生产者-消费者问题","children":[]}]},{"level":2,"title":"一二章知识点","slug":"一二章知识点","link":"#一二章知识点","children":[{"level":3,"title":"一、简要记忆","slug":"一、简要记忆","link":"#一、简要记忆","children":[]},{"level":3,"title":"二、进程与线程管理模块","slug":"二、进程与线程管理模块","link":"#二、进程与线程管理模块","children":[]}]},{"level":2,"title":"第三章","slug":"第三章","link":"#第三章","children":[{"level":3,"title":"一、连续内存分配算法（对应题 4）","slug":"一、连续内存分配算法-对应题-4","link":"#一、连续内存分配算法-对应题-4","children":[]},{"level":3,"title":"二、分页存储管理（对应题 7）","slug":"二、分页存储管理-对应题-7","link":"#二、分页存储管理-对应题-7","children":[]},{"level":3,"title":"分页原理；逻辑地址到页号和页内偏移量的转换方法（两种：公式和二进制）","slug":"分页原理-逻辑地址到页号和页内偏移量的转换方法-两种-公式和二进制","link":"#分页原理-逻辑地址到页号和页内偏移量的转换方法-两种-公式和二进制","children":[]},{"level":3,"title":"请求分页的地址变换","slug":"请求分页的地址变换","link":"#请求分页的地址变换","children":[]},{"level":3,"title":"三、页面置换算法（对应题 28、36）","slug":"三、页面置换算法-对应题-28、36","link":"#三、页面置换算法-对应题-28、36","children":[]},{"level":3,"title":"四、磁盘 I/O 时间计算（对应题 35）","slug":"四、磁盘-i-o-时间计算-对应题-35","link":"#四、磁盘-i-o-时间计算-对应题-35","children":[]}]},{"level":2,"title":"第四章","slug":"第四章","link":"#第四章","children":[{"level":3,"title":"一、索引节点（i 节点）的文件大小计算","slug":"一、索引节点-i-节点-的文件大小计算","link":"#一、索引节点-i-节点-的文件大小计算","children":[]},{"level":3,"title":"二、文件分配方式的适用场景","slug":"二、文件分配方式的适用场景","link":"#二、文件分配方式的适用场景","children":[]},{"level":3,"title":"DMA的工作原理和通道的工作原理","slug":"dma的工作原理和通道的工作原理","link":"#dma的工作原理和通道的工作原理","children":[]},{"level":3,"title":"SPOOLING技术","slug":"spooling技术","link":"#spooling技术","children":[]},{"level":3,"title":"三、硬链接与符号链接的优缺点","slug":"三、硬链接与符号链接的优缺点","link":"#三、硬链接与符号链接的优缺点","children":[]},{"level":3,"title":"四、空闲磁盘空间管理（空闲块表 vs 位图）","slug":"四、空闲磁盘空间管理-空闲块表-vs-位图","link":"#四、空闲磁盘空间管理-空闲块表-vs-位图","children":[]},{"level":3,"title":"五、空闲块位图的状态变化","slug":"五、空闲块位图的状态变化","link":"#五、空闲块位图的状态变化","children":[]},{"level":3,"title":"六、磁盘块的内部碎片","slug":"六、磁盘块的内部碎片","link":"#六、磁盘块的内部碎片","children":[]},{"level":3,"title":"七、索引节点（直接 + 间接地址）的最大文件大小","slug":"七、索引节点-直接-间接地址-的最大文件大小","link":"#七、索引节点-直接-间接地址-的最大文件大小","children":[]}]},{"level":2,"title":"第五章","slug":"第五章","link":"#第五章","children":[{"level":3,"title":"一、中断驱动 I/O 的适用性评估","slug":"一、中断驱动-i-o-的适用性评估","link":"#一、中断驱动-i-o-的适用性评估","children":[]},{"level":3,"title":"二、I/O 软件的四层结构","slug":"二、i-o-软件的四层结构","link":"#二、i-o-软件的四层结构","children":[]},{"level":3,"title":"三、磁盘扇区的读入时间计算","slug":"三、磁盘扇区的读入时间计算","link":"#三、磁盘扇区的读入时间计算","children":[]},{"level":3,"title":"四、磁盘容量、磁道斜进与数据传输率计算","slug":"四、磁盘容量、磁道斜进与数据传输率计算","link":"#四、磁盘容量、磁道斜进与数据传输率计算","children":[]},{"level":3,"title":"五、磁盘调度算法的寻道时间计算","slug":"五、磁盘调度算法的寻道时间计算","link":"#五、磁盘调度算法的寻道时间计算","children":[]}]},{"level":2,"title":"第六章","slug":"第六章","link":"#第六章","children":[{"level":3,"title":"一、死锁检测算法的应用","slug":"一、死锁检测算法的应用","link":"#一、死锁检测算法的应用","children":[]},{"level":3,"title":"二、死锁可能性的判断（基于资源数与进程需求）","slug":"二、死锁可能性的判断-基于资源数与进程需求","link":"#二、死锁可能性的判断-基于资源数与进程需求","children":[]},{"level":3,"title":"三、安全状态与可用资源的最小值","slug":"三、安全状态与可用资源的最小值","link":"#三、安全状态与可用资源的最小值","children":[]},{"level":3,"title":"四、预防死锁（破除 “占有等待” 条件）的方法改进","slug":"四、预防死锁-破除-占有等待-条件-的方法改进","link":"#四、预防死锁-破除-占有等待-条件-的方法改进","children":[]}]}],"git":{"updatedTime":1768621358000,"contributors":[{"name":"ksldnasx","username":"ksldnasx","email":"wh8261408@126.com","commits":5,"url":"https://github.com/ksldnasx"}],"changelog":[{"hash":"1f864259e832e26b375fa180e4e2da1fa0f7da94","time":1768621358000,"email":"wh8261408@126.com","author":"ksldnasx","message":"fix"},{"hash":"45631f3e07c87d7a13e6aaae3afde88f19810e12","time":1767540983000,"email":"wh8261408@126.com","author":"ksldnasx","message":"feat:操作系统AI总结"},{"hash":"02f581955ebc4e487be56657d69105c749d17657","time":1767525228000,"email":"wh8261408@126.com","author":"ksldnasx","message":"fix :png"},{"hash":"b7cca549130cb7e4ba2ddf45e4130feb9dd1553c","time":1767524782000,"email":"wh8261408@126.com","author":"ksldnasx","message":"fix:操作系统课后题"},{"hash":"c5fd1778fcc4e0bc3a6b966a93ef4f2ffd9ac13a","time":1767457984000,"email":"wh8261408@126.com","author":"ksldnasx","message":"feat：操作系统"}]},"filePathRelative":"posts/classlearning/操作系统课后题目.md","excerpt":"\\n<h2>第一章</h2>\\n<p><strong>1. 操作系统两大主要作用？</strong></p>\\n<ul>\\n<li>管理 CPU、内存、I/O 设备等硬件资源；</li>\\n<li>为用户 / 应用程序提供便捷的硬件抽象接口。</li>\\n</ul>\\n<p><strong>3. 分时系统和多道程序系统的区别？</strong></p>\\n<ul>\\n<li>分时系统：按时间片轮转调度，支持多用户交互，响应快；</li>\\n<li>多道程序系统：多个程序并发执行，仅提升 CPU 利用率，无交互性。</li>\\n</ul>\\n<p><strong>6. 为何 I/O 指令是特权指令？</strong></p>"}');export{g as comp,h as data};
