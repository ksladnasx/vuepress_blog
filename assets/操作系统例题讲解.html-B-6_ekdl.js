import{_ as s,c as l,a,o as i}from"./app-UmXydJji.js";const e={};function p(t,n){return i(),l("div",null,[...n[0]||(n[0]=[a(`<h1 id="操作系统核心算法例题及解析" tabindex="-1"><a class="header-anchor" href="#操作系统核心算法例题及解析"><span>操作系统核心算法例题及解析</span></a></h1><h2 id="第一章-概述-——-系统调用相关例题" tabindex="-1"><a class="header-anchor" href="#第一章-概述-——-系统调用相关例题"><span>第一章 概述 —— 系统调用相关例题</span></a></h2><h3 id="例题-fork-系统调用应用" tabindex="-1"><a class="header-anchor" href="#例题-fork-系统调用应用"><span>例题：fork 系统调用应用</span></a></h3><p><strong>题目</strong>：编写一段 C 语言代码，使用 fork () 创建子进程，分别在父进程和子进程中输出进程 ID，并说明 fork () 的返回值特点。<strong>解析步骤</strong>：</p><ol><li>调用 fork () 创建子进程，返回值存储在变量 pid 中。</li><li>fork () 返回值规则：父进程中返回子进程 ID（大于 0），子进程中返回 0，创建失败返回 - 1。</li><li>通过判断 pid 值区分父、子进程，分别输出对应信息。</li><li>代码实现：</li></ol><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c"><pre><code><span class="line"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span></span>
<span class="line"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span></span>
<span class="line"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">pid_t</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">&quot;fork failed&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;子进程：PID = %d，父进程PID = %d\\n&quot;</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;父进程：PID = %d，子进程PID = %d\\n&quot;</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>输出结果</strong>（示例）：</p><div class="language-plaintext line-numbers-mode" data-highlighter="prismjs" data-ext="plaintext"><pre><code><span class="line">父进程：PID = 1234，子进程PID = 1235</span>
<span class="line">子进程：PID = 1235，父进程PID = 1234</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意事项</strong>：子进程会复制父进程的地址空间，fork () 之后的代码会被父子进程分别执行。</p><h2 id="第二章-进程与线程-——-进程调度算法例题" tabindex="-1"><a class="header-anchor" href="#第二章-进程与线程-——-进程调度算法例题"><span>第二章 进程与线程 —— 进程调度算法例题</span></a></h2><h3 id="例题-先来先服务-fcfs-调度算法" tabindex="-1"><a class="header-anchor" href="#例题-先来先服务-fcfs-调度算法"><span>例题：先来先服务（FCFS）调度算法</span></a></h3><p><strong>题目</strong>：有 3 个进程 P1、P2、P3，进入就绪队列的次序为 P1、P2、P3，CPU 周期分别为 21ms、6ms、3ms。计算平均周转时间、平均带权周转时间和平均等待时间。<strong>解析步骤</strong>：</p><ol><li>调度序列：按 FCFS 规则，执行顺序为 P1→P2→P3。</li><li>周转时间 = 完成时间 - 进入就绪队列时间（假设均为 0）： <ul><li>P1：21ms - 0 = 21ms</li><li>P2：21ms + 6ms - 0 = 27ms</li><li>P3：27ms + 3ms - 0 = 30ms</li></ul></li><li>带权周转时间 = 周转时间 / CPU 周期： <ul><li>P1：21/21 = 1</li><li>P2：27/6 = 4.5</li><li>P3：30/3 = 10</li></ul></li><li>等待时间 = 周转时间 - CPU 周期： <ul><li>P1：21 - 21 = 0ms</li><li>P2：27 - 6 = 21ms</li><li>P3：30 - 3 = 27ms</li></ul></li><li>平均计算： <ul><li>平均周转时间：(21+27+30)/3 = 26ms</li><li>平均带权周转时间：(1+4.5+10)/3 ≈ 5.17</li><li>平均等待时间：(0+21+27)/3 = 16ms</li></ul></li></ol><h3 id="例题-信号量实现生产者-消费者问题" tabindex="-1"><a class="header-anchor" href="#例题-信号量实现生产者-消费者问题"><span>例题：信号量实现生产者 - 消费者问题</span></a></h3><p><strong>题目</strong>：使用信号量实现有界缓冲区（大小为 100）的生产者 - 消费者问题，要求保证缓冲区访问的互斥和同步。<strong>解析步骤</strong>：</p><ol><li><p>定义信号量：</p><ul><li>mutex：互斥信号量，保护缓冲区访问，初始值 1。</li><li>empty：同步信号量，标识空缓冲区数量，初始值 100。</li><li>full：同步信号量，标识满缓冲区数量，初始值 0。</li></ul></li><li><p>生产者进程：先申请空缓冲区（P (empty)），再申请互斥锁（P (mutex)），放入数据后释放互斥锁（V (mutex)），最后通知消费者（V (full)）。</p></li><li><p>消费者进程：先申请满缓冲区（P (full)），再申请互斥锁（P (mutex)），取出数据后释放互斥锁（V (mutex)），最后通知生产者（V (empty)）。</p><p>代码实现</p><p>（伪代码）：</p></li></ol><div class="language-plaintext line-numbers-mode" data-highlighter="prismjs" data-ext="plaintext"><pre><code><span class="line">#define N 100</span>
<span class="line">typedef int semaphore;</span>
<span class="line">semaphore mutex = 1, empty = N, full = 0;</span>
<span class="line"></span>
<span class="line">void producer() {</span>
<span class="line">    int item;</span>
<span class="line">    while (TRUE) {</span>
<span class="line">        item = 生产数据;</span>
<span class="line">        P(empty);  // 申请空缓冲区</span>
<span class="line">        P(mutex);  // 申请互斥锁</span>
<span class="line">        将item放入缓冲区;</span>
<span class="line">        V(mutex);  // 释放互斥锁</span>
<span class="line">        V(full);   // 通知消费者有数据</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">void consumer() {</span>
<span class="line">    int item;</span>
<span class="line">    while (TRUE) {</span>
<span class="line">        P(full);   // 申请满缓冲区</span>
<span class="line">        P(mutex);  // 申请互斥锁</span>
<span class="line">        从缓冲区取出item;</span>
<span class="line">        V(mutex);  // 释放互斥锁</span>
<span class="line">        V(empty);  // 通知生产者有空位</span>
<span class="line">        消费item;</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="第三章-死锁" tabindex="-1"><a class="header-anchor" href="#第三章-死锁"><span>第三章 死锁</span></a></h2><h3 id="银行家算法例题" tabindex="-1"><a class="header-anchor" href="#银行家算法例题"><span>银行家算法例题</span></a></h3><p><strong>题目</strong>：系统有 A、B、C 三类资源，总量分别为 10、5、7。当前资源分配情况如下表，判断当前系统是否安全，若安全给出安全序列。</p><table><thead><tr><th>进程</th><th>已分配资源（A,B,C）</th><th>最大需求（A,B,C）</th><th>剩余需求（A,B,C）</th></tr></thead><tbody><tr><td>P0</td><td>0,1,0</td><td>7,5,3</td><td>7,4,3</td></tr><tr><td>P1</td><td>2,0,0</td><td>3,2,2</td><td>1,2,2</td></tr><tr><td>P2</td><td>3,0,2</td><td>9,0,2</td><td>6,0,0</td></tr><tr><td>P3</td><td>2,1,1</td><td>2,2,2</td><td>0,1,1</td></tr><tr><td>P4</td><td>0,0,2</td><td>4,3,3</td><td>4,3,1</td></tr><tr><td>当前可用资源（A,B,C）：3,3,2</td><td></td><td></td><td></td></tr><tr><td><strong>解析步骤</strong>：</td><td></td><td></td><td></td></tr></tbody></table><ol><li><p>检查各进程剩余需求是否≤可用资源：</p><ul><li>P1 剩余需求（1,2,2）≤（3,3,2），可先执行 P1。</li></ul></li><li><p>执行 P1 后，释放其已分配资源，可用资源更新为：3+2, 3+0, 2+0 =（5,3,2）。</p></li><li><p>继续查找剩余需求≤当前可用资源的进程：</p><ul><li>P3 剩余需求（0,1,1）≤（5,3,2），执行 P3。</li></ul></li><li><p>释放 P3 资源，可用资源更新为：5+2, 3+1, 2+1 =（7,4,3）。</p></li><li><p>继续查找：</p><ul><li>P0 剩余需求（7,4,3）≤（7,4,3），执行 P0。</li></ul></li><li><p>释放 P0 资源，可用资源更新为：7+0, 4+1, 3+0 =（7,5,3）。</p></li><li><p>继续查找：</p><ul><li>P2 剩余需求（6,0,0）≤（7,5,3），执行 P2。</li></ul></li><li><p>释放 P2 资源，可用资源更新为：7+3, 5+0, 3+2 =（10,5,5）。</p></li><li><p>最后执行 P4，剩余需求（4,3,1）≤（10,5,5），执行完成。</p><p>安全序列：P1→P3→P0→P2→P4，当前系统安全。</p></li></ol><h3 id="多资源死锁检测" tabindex="-1"><a class="header-anchor" href="#多资源死锁检测"><span>多资源死锁检测</span></a></h3><p><strong>题目</strong>：系统有 3 个进程（P0、P1、P2）和 4 类资源（磁带机、绘图仪、扫描仪、CD-ROM），资源总量 (E=(4,2,3,1))。当前资源分配情况如下：</p><ul><li><p>可用资源向量 (A=(2,1,0,0))</p></li><li><p>分配矩阵C（行：进程，列：资源）：$ C=\\begin{bmatrix} 0 &amp; 0 &amp; 1 &amp; 0 \\ 2 &amp; 0 &amp; 0 &amp; 1 \\ 0 &amp; 1 &amp; 2 &amp; 0 \\end{bmatrix} $</p></li><li><p>请求矩阵R（行：进程，列：资源）：$ R=\\begin{bmatrix} 2 &amp; 0 &amp; 0 &amp; 1 \\ 1 &amp; 0 &amp; 1 &amp; 0 \\ 2 &amp; 1 &amp; 0 &amp; 0 \\end{bmatrix} $</p><p>判断系统是否存在死锁，若存在，指出死锁进程。</p></li></ul><p><strong>解析步骤</strong>：</p><ol><li><p>初始化：标记所有进程为 “未完成”，可用资源 (A=(2,1,0,0))。</p></li><li><p>遍历所有未完成进程，检查是否满足$ R[i] \\leq A$：</p><ul><li>P0 请求 ((2,0,0,1))，可用资源 ((2,1,0,0)) 不满足（CD-ROM 资源不足）；</li></ul></li></ol><ul><li>P1 请求 ((1,0,1,0))，可用资源 ((2,1,0,0)) 不满足（扫描仪资源不足）； <ul><li>P2 请求 ((2,1,0,0))，可用资源 ((2,1,0,0)) 满足。</li></ul></li></ul><ol start="3"><li><p>标记 P2 为 “完成”，释放其已分配资源，可用资源更新为：(A + C[2] = (2+0,1+1,0+2,0+0) = (2,2,2,0))。</p></li><li><p>再次遍历未完成进程（P0、P1）：</p><ul><li>P0 请求 ((2,0,0,1))，可用资源 ((2,2,2,0)) 不满足（CD-ROM 资源不足）；</li><li>P1 请求 ((1,0,1,0))，可用资源 ((2,2,2,0)) 满足（1≤2，0≤2，1≤2，0≤0）。</li></ul></li><li><p>标记 P1 为 “完成”，释放其已分配资源，可用资源更新为：((2,2,2,0) + C[1] = (2+2,2+0,2+0,0+1) = (4,2,2,1))。</p></li><li><p>最后遍历未完成进程（P0）：</p><ul><li>P0 请求 ((2,0,0,1))，可用资源 ((4,2,2,1)) 满足（2≤4，0≤2，0≤2，1≤1）。</li></ul></li><li><p>标记 P0 为 “完成”，所有进程均完成，<strong>系统无死锁</strong>。</p></li></ol><h3 id="变式-存在死锁场景" tabindex="-1"><a class="header-anchor" href="#变式-存在死锁场景"><span>变式（存在死锁场景）：</span></a></h3><p>若可用资源初始为 (A=(1,1,0,0))，重复上述步骤：</p><ol><li><p>第一步无进程满足 (R[i] \\leq A)，未完成进程为 P0、P1、P2；</p></li><li><p>无新进程可完成，剩余进程均无法推进，<strong>系统存在死锁，死锁进程为 P0、P1、P2</strong>。</p></li></ol><h2 id="第四章-存储管理-——-页面置换算法例题" tabindex="-1"><a class="header-anchor" href="#第四章-存储管理-——-页面置换算法例题"><span>第四章 存储管理 —— 页面置换算法例题</span></a></h2><h3 id="例题-lru-页面置换算法" tabindex="-1"><a class="header-anchor" href="#例题-lru-页面置换算法"><span>例题：LRU 页面置换算法</span></a></h3><p><strong>题目</strong>：某程序分配 3 个页框，初始为空，页面走向为 4,3,2,1,4,3,5,4,3,2,1,5。计算缺页次数和缺页率。<strong>解析步骤</strong>：</p><ol><li>页框初始状态：[]</li><li>按页面走向逐次处理，记录页框变化和缺页情况（× 表示缺页）： <ul><li>4：[]→[4]，缺页（×1）</li><li>3：[4]→[4,3]，缺页（×2）</li><li>2：[4,3]→[4,3,2]，缺页（×3）</li><li>1：[4,3,2]→[1,3,2]（淘汰最近最少使用的 4），缺页（×4）</li><li>4：[1,3,2]→[1,4,2]（淘汰最近最少使用的 3），缺页（×5）</li><li>3：[1,4,2]→[1,4,3]（淘汰最近最少使用的 2），缺页（×6）</li><li>5：[1,4,3]→[5,4,3]（淘汰最近最少使用的 1），缺页（×7）</li><li>4：[5,4,3]→[5,4,3]（命中，无缺页）</li><li>3：[5,4,3]→[5,4,3]（命中，无缺页）</li><li>2：[5,4,3]→[5,2,3]（淘汰最近最少使用的 4），缺页（×8）</li><li>1：[5,2,3]→[1,2,3]（淘汰最近最少使用的 5），缺页（×9）</li><li>5：[1,2,3]→[1,2,5]（淘汰最近最少使用的 3），缺页（×10）</li></ul></li><li>缺页次数 = 10 次，总访问次数 = 12 次。</li><li>缺页率 = 10/12≈83.3%</li></ol><h3 id="例题-可变分区首次适配算法" tabindex="-1"><a class="header-anchor" href="#例题-可变分区首次适配算法"><span>例题：可变分区首次适配算法</span></a></h3><p><strong>题目</strong>：内存空闲分区为：2K、4K、20K、10K、8K、5K（按地址从低到高排列）。现有一进程申请 6K 内存，使用首次适配算法分配后，空闲分区变为多少？<strong>解析步骤</strong>：</p><ol><li>首次适配算法：从内存起始位置查找第一个能容纳申请大小的空闲分区。</li><li>遍历空闲分区：2K（不足 6K）→4K（不足 6K）→20K（满足 6K）。</li><li>分配 6K 后，20K 空闲分区剩余：20K - 6K =14K。</li><li>分配后空闲分区顺序：2K、4K、14K、10K、8K、5K。</li></ol><h3 id="例题-段页式虚拟地址到物理地址转换" tabindex="-1"><a class="header-anchor" href="#例题-段页式虚拟地址到物理地址转换"><span>例题：段页式虚拟地址到物理地址转换</span></a></h3><p><strong>题目</strong>：某系统采用段页式存储管理，虚拟地址结构为：段号（2 位）+ 页号（3 位）+ 页内偏移（9 位）。已知：</p><ul><li><p>页大小 = (2^9 = 512) 字节；</p></li><li><p>段表（每个进程 1 张）：</p><p>| 段号 | 段长（页数） | 页表始址（物理地址） | 段存在位 |</p><p>|------|--------------|----------------------|----------|</p><p>| 0 | 4 | 10240 | 1 |</p><p>| 1 | 3 | 20480 | 1 |</p><p>| 2 | 5 | 30720 | 0 |</p><p>| 3 | 2 | 40960 | 1 |</p></li><li><p>段 0 的页表（页表项：页框号 + 存在位）：</p><p>| 页号 | 页框号 | 存在位 |</p><p>|------|--------|--------|</p><p>| 0 | 15 | 1 |</p><p>| 1 | 23 | 1 |</p><p>| 2 | 37 | 1 |</p><p>| 3 | 42 | 1 |</p><p>现有虚拟地址：01 011 101001100（二进制），将其转换为物理地址。</p></li></ul><p><strong>解析步骤</strong>：</p><ol><li>拆分虚拟地址各字段： <ul><li>段号（前 2 位）：01（二进制）= 1（十进制）；</li><li>页号（中间 3 位）：011（二进制）= 3（十进制）；</li><li>页内偏移（后 9 位）：101001100（二进制）= 332（十进制）。</li></ul></li><li>查段表（段号 = 1）： <ul><li>段存在位 = 1（段已调入内存）；</li><li>段长 = 3 页，页号 = 3 &gt; 段长 - 1=2，<strong>段内页号越界，抛出越界中断</strong>。</li></ul></li></ol><p><strong>修正虚拟地址</strong>（无越界场景）：</p><p>虚拟地址：00 010 101001100（二进制），拆分后：</p><ul><li>段号 = 00（十进制 0），页号 = 010（十进制 2），页内偏移 = 332。</li></ul><ol><li>查段表（段号 = 0）： <ul><li>段存在位 = 1，段长 = 4 页，页号 = 2 ≤ 3（合法），页表始址 = 10240。</li></ul></li><li>计算页表项地址： <ul><li>每个页表项占 4 字节（假设），页表项偏移 = 页号 ×4 = 2×4=8；</li><li>页表项物理地址 = 页表始址 + 偏移 = 10240 + 8 = 10248。</li></ul></li><li>查段 0 的页表（页号 = 2）： <ul><li>页框号 = 37，存在位 = 1（页已调入内存）。</li></ul></li><li>计算物理地址： <ul><li>物理地址 = 页框号 × 页大小 + 页内偏移 = 37×512 + 332；</li><li>计算：37×512=18944，18944+332=19276（十进制）；</li><li>转换为十六进制：19276 → 0x4B4C。</li></ul></li></ol><p><strong>最终物理地址</strong>：19276（十进制）或 0x4B4C（十六进制）。</p><h2 id="第五章-文件系统-——-磁盘空间管理例题" tabindex="-1"><a class="header-anchor" href="#第五章-文件系统-——-磁盘空间管理例题"><span>第五章 文件系统 —— 磁盘空间管理例题</span></a></h2><h3 id="例题-位图法管理磁盘空间" tabindex="-1"><a class="header-anchor" href="#例题-位图法管理磁盘空间"><span>例题：位图法管理磁盘空间</span></a></h3><p><strong>题目</strong>：某磁盘有 32 个扇区（编号 0-31），位图中每一位对应一个扇区（0 表示空闲，1 表示占用）。当前位图为：10011011011011000110111101110111（从高位到低位对应扇区 0-31）。请找出所有空闲扇区编号。<strong>解析步骤</strong>：</p><ol><li>将位图按每一位对应扇区编号（高位对应扇区 0，低位对应扇区 31）。</li><li>逐位解析位图，值为 0 的位对应的扇区为空闲： <ul><li>位图二进制：1 0 0 1 1 0 1 1 0 1 1 0 1 1 0 0 0 1 1 0 1 1 1 1 0 1 1 1 0 1 1 1</li><li>对应扇区 0-31，空闲扇区（值为 0）编号：1、2、5、8、11、14、15、16、19、24、28</li></ul></li><li>最终空闲扇区：1、2、5、8、11、14、15、16、19、24、28。</li></ol><h2 id="第六章-设备管理-——-磁盘臂调度算法例题" tabindex="-1"><a class="header-anchor" href="#第六章-设备管理-——-磁盘臂调度算法例题"><span>第六章 设备管理 —— 磁盘臂调度算法例题</span></a></h2><h3 id="例题-scan-电梯-调度算法" tabindex="-1"><a class="header-anchor" href="#例题-scan-电梯-调度算法"><span>例题：SCAN（电梯）调度算法</span></a></h3><p><strong>题目</strong>：磁盘有 0-35 共 36 个柱面，当前磁头在 10 号柱面，且正在向柱面号增大的方向移动。当前等待的磁盘 I/O 请求柱面号为：1、36、16、34、9、12。计算磁头移动的总柱面数。<strong>解析步骤</strong>：</p><ol><li>SCAN 算法：磁头按当前方向移动，依次处理沿途请求，到达边缘后反向。</li><li>当前磁头位置 10，方向：增大，请求队列：1、36、16、34、9、12。</li><li>按方向筛选并排序请求（≥10）：12、16、34、36。</li><li>处理顺序：10→12（移动 2）→16（移动 4）→34（移动 18）→36（移动 2）。</li><li>到达 36（最大柱面），反向（向减小方向），剩余请求：9、1。</li><li>处理顺序：36→9（移动 27）→1（移动 8）。</li><li>总移动柱面数：2+4+18+2+27+8=61。</li></ol>`,57)])])}const r=s(e,[["render",p]]),o=JSON.parse('{"path":"/posts/classlearning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3.html","title":"操作系统核心算法例题及解析","lang":"zh-CN","frontmatter":{"date":"2025-12-15T00:00:00.000Z","category":["期末复习"],"tag":["操作系统"]},"headers":[{"level":2,"title":"第一章 概述 —— 系统调用相关例题","slug":"第一章-概述-——-系统调用相关例题","link":"#第一章-概述-——-系统调用相关例题","children":[{"level":3,"title":"例题：fork 系统调用应用","slug":"例题-fork-系统调用应用","link":"#例题-fork-系统调用应用","children":[]}]},{"level":2,"title":"第二章 进程与线程 —— 进程调度算法例题","slug":"第二章-进程与线程-——-进程调度算法例题","link":"#第二章-进程与线程-——-进程调度算法例题","children":[{"level":3,"title":"例题：先来先服务（FCFS）调度算法","slug":"例题-先来先服务-fcfs-调度算法","link":"#例题-先来先服务-fcfs-调度算法","children":[]},{"level":3,"title":"例题：信号量实现生产者 - 消费者问题","slug":"例题-信号量实现生产者-消费者问题","link":"#例题-信号量实现生产者-消费者问题","children":[]}]},{"level":2,"title":"第三章 死锁","slug":"第三章-死锁","link":"#第三章-死锁","children":[{"level":3,"title":"银行家算法例题","slug":"银行家算法例题","link":"#银行家算法例题","children":[]},{"level":3,"title":"多资源死锁检测","slug":"多资源死锁检测","link":"#多资源死锁检测","children":[]},{"level":3,"title":"变式（存在死锁场景）：","slug":"变式-存在死锁场景","link":"#变式-存在死锁场景","children":[]}]},{"level":2,"title":"第四章 存储管理 —— 页面置换算法例题","slug":"第四章-存储管理-——-页面置换算法例题","link":"#第四章-存储管理-——-页面置换算法例题","children":[{"level":3,"title":"例题：LRU 页面置换算法","slug":"例题-lru-页面置换算法","link":"#例题-lru-页面置换算法","children":[]},{"level":3,"title":"例题：可变分区首次适配算法","slug":"例题-可变分区首次适配算法","link":"#例题-可变分区首次适配算法","children":[]},{"level":3,"title":"例题：段页式虚拟地址到物理地址转换","slug":"例题-段页式虚拟地址到物理地址转换","link":"#例题-段页式虚拟地址到物理地址转换","children":[]}]},{"level":2,"title":"第五章 文件系统 —— 磁盘空间管理例题","slug":"第五章-文件系统-——-磁盘空间管理例题","link":"#第五章-文件系统-——-磁盘空间管理例题","children":[{"level":3,"title":"例题：位图法管理磁盘空间","slug":"例题-位图法管理磁盘空间","link":"#例题-位图法管理磁盘空间","children":[]}]},{"level":2,"title":"第六章 设备管理 —— 磁盘臂调度算法例题","slug":"第六章-设备管理-——-磁盘臂调度算法例题","link":"#第六章-设备管理-——-磁盘臂调度算法例题","children":[{"level":3,"title":"例题：SCAN（电梯）调度算法","slug":"例题-scan-电梯-调度算法","link":"#例题-scan-电梯-调度算法","children":[]}]}],"git":{"updatedTime":1768621358000,"contributors":[{"name":"ksldnasx","username":"ksldnasx","email":"wh8261408@126.com","commits":2,"url":"https://github.com/ksldnasx"}],"changelog":[{"hash":"1f864259e832e26b375fa180e4e2da1fa0f7da94","time":1768621358000,"email":"wh8261408@126.com","author":"ksldnasx","message":"fix"},{"hash":"7acde950f3e52ea4afdc8aa0ae6b40c48e60e8fc","time":1765965489000,"email":"wh8261408@126.com","author":"ksldnasx","message":"feat：复习文章"}]},"filePathRelative":"posts/classlearning/操作系统例题讲解.md","excerpt":"\\n<h2>第一章 概述 —— 系统调用相关例题</h2>\\n<h3>例题：fork 系统调用应用</h3>\\n<p><strong>题目</strong>：编写一段 C 语言代码，使用 fork () 创建子进程，分别在父进程和子进程中输出进程 ID，并说明 fork () 的返回值特点。<strong>解析步骤</strong>：</p>\\n<ol>\\n<li>调用 fork () 创建子进程，返回值存储在变量 pid 中。</li>\\n<li>fork () 返回值规则：父进程中返回子进程 ID（大于 0），子进程中返回 0，创建失败返回 - 1。</li>\\n<li>通过判断 pid 值区分父、子进程，分别输出对应信息。</li>\\n<li>代码实现：</li>\\n</ol>"}');export{r as comp,o as data};
