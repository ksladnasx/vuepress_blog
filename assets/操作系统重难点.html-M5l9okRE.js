import{_ as i,c as t,a as e,o as n}from"./app-UmXydJji.js";const a={};function s(r,l){return n(),t("div",null,[...l[0]||(l[0]=[e(`<h1 id="操作系统期末重难点知识点详解" tabindex="-1"><a class="header-anchor" href="#操作系统期末重难点知识点详解"><span>操作系统期末重难点知识点详解</span></a></h1><h2 id="第一章-引论" tabindex="-1"><a class="header-anchor" href="#第一章-引论"><span>第一章 引论</span></a></h2><h3 id="_1-操作系统定义" tabindex="-1"><a class="header-anchor" href="#_1-操作系统定义"><span>1. 操作系统定义</span></a></h3><ul><li><p><strong>定义</strong>：操作系统是计算机系统中的核心软件，负责协调管理计算机系统硬件与软件资源，并为用户和应用程序提供高效的交互环境。</p></li><li><p>特征：</p><ul><li><p>并发性</p></li><li><p>异步性</p></li><li><p>共享性</p></li><li><p>异步性</p></li></ul></li></ul><h3 id="_2-操作系统在计算机系统中的位置和作用" tabindex="-1"><a class="header-anchor" href="#_2-操作系统在计算机系统中的位置和作用"><span>2. 操作系统在计算机系统中的位置和作用</span></a></h3><ul><li><p><strong>位置</strong>：位于计算机硬件之上，应用软件之下，是一层 “中间件”。</p></li><li><p>核心作用</p><ol><li>资源管理：统一管理 CPU、内存、设备、文件等软硬件资源，避免冲突。</li><li>提供接口：给用户（命令接口、图形接口）和应用程序（系统调用接口）提供便捷操作方式。</li><li>优化系统性能：通过调度算法、资源分配策略提升系统吞吐量、响应速度。</li><li>屏蔽硬件差异：使应用程序无需关注具体硬件型号，实现 “硬件无关性”。</li></ol></li></ul><h3 id="_3-关键概念区分" tabindex="-1"><a class="header-anchor" href="#_3-关键概念区分"><span>3. 关键概念区分</span></a></h3><ul><li><p>多道程序</p><p>指计算机内存中同时存放多个相互独立的程序，CPU 在它们之间切换执行，宏观上多个程序同时运行，微观上 CPU 分时执行。</p><p>核心目的是提高 CPU 利用率（避免 CPU 因等待 I/O 而空闲）。</p></li><li><p>并发与并行的区别</p><table><thead><tr><th style="text-align:center;">维度</th><th style="text-align:center;">并发（Concurrency）</th><th style="text-align:center;">并行（Parallelism）</th></tr></thead><tbody><tr><td style="text-align:center;">核心定义</td><td style="text-align:center;">多个程序在<strong>同一时间段</strong>内交替执行</td><td style="text-align:center;">多个程序在<strong>同一时刻</strong>同时执行</td></tr><tr><td style="text-align:center;">硬件要求</td><td style="text-align:center;">单 CPU 即可实现（分时切换）</td><td style="text-align:center;">必须多 CPU 或多核处理器</td></tr><tr><td style="text-align:center;">典型例子</td><td style="text-align:center;">单 CPU 电脑同时聊微信、写文档</td><td style="text-align:center;">双 CPU 服务器同时处理多个请求</td></tr></tbody></table></li></ul><h3 id="_4-基本操作系统类型及其特点" tabindex="-1"><a class="header-anchor" href="#_4-基本操作系统类型及其特点"><span>4. 基本操作系统类型及其特点</span></a></h3><table><thead><tr><th style="text-align:center;">类型</th><th style="text-align:center;">核心特点</th><th style="text-align:center;">优点</th><th style="text-align:center;">缺点</th><th style="text-align:center;">适用场景</th></tr></thead><tbody><tr><td style="text-align:center;">批处理系统</td><td style="text-align:center;">成批处理作业，无交互；顺序执行</td><td style="text-align:center;">资源利用率高，系统吞吐量高</td><td style="text-align:center;">响应时间长，无交互性</td><td style="text-align:center;">大型科学计算、批量数据处理</td></tr><tr><td style="text-align:center;">分时系统</td><td style="text-align:center;">多个用户共享 CPU，时间片轮转；交互性强</td><td style="text-align:center;">响应快，用户体验好，资源共享</td><td style="text-align:center;">系统开销大（切换频繁）</td><td style="text-align:center;">面操作系统（Windows、Linux）</td></tr><tr><td style="text-align:center;">实时系统</td><td style="text-align:center;">严格满足时间约束（硬实时 / 软实时）</td><td style="text-align:center;">响应时间确定，可靠性高</td><td style="text-align:center;">资源利用率较低，设计复杂</td><td style="text-align:center;">工业控制、医疗设备、航空航天</td></tr></tbody></table><h3 id="_5-网络操作系统与分布式操作系统的特点和联系" tabindex="-1"><a class="header-anchor" href="#_5-网络操作系统与分布式操作系统的特点和联系"><span>5. 网络操作系统与分布式操作系统的特点和联系</span></a></h3><ul><li><p>网络操作系统（NOS）</p><ul><li>特点：将多台独立计算机通过网络连接，提供文件共享、打印共享、通信等服务；各计算机独立，有自己的 OS，网络仅为通信媒介。</li></ul></li><li><p>例子：Windows Server、Linux Server。</p></li><li><p>分布式操作系统（DOS）</p><ul><li>特点：多台计算机组成 “逻辑上统一的系统”，用户无需关注硬件分布；资源全局共享，任务可分布式执行（拆分到不同计算机）。</li></ul></li><li><p>例子：Google 的分布式文件系统（GFS）、Hadoop。</p></li><li><p><strong>相互联系</strong>：都基于网络连接多台计算机；分布式 OS 是网络 OS 的高级形式，核心区别是 “是否逻辑统一”“是否透明化分布”。</p></li></ul><h3 id="_6-操作系统的特征-四大核心" tabindex="-1"><a class="header-anchor" href="#_6-操作系统的特征-四大核心"><span>6. 操作系统的特征（四大核心）</span></a></h3><ul><li><strong>并发</strong>：多个程序在同一时间段可交替执行（核心特征，是共享、虚拟的基础）。</li><li><strong>共享</strong>：系统资源可被多个并发程序共同使用（分为互斥共享：如打印机；同时共享：如内存）。</li><li><strong>虚拟</strong>：通过软件将物理资源抽象为多个逻辑资源（如虚拟内存、虚拟打印机）。</li><li><strong>异步</strong>：各个进程以不可预知的速度前进，但 OS 需保证程序最终完成（因资源竞争导致）。</li></ul><h3 id="_7-操作系统的功能-五大核心" tabindex="-1"><a class="header-anchor" href="#_7-操作系统的功能-五大核心"><span>7. 操作系统的功能（五大核心）</span></a></h3><ul><li><strong>处理机管理</strong>：进程 / 线程的创建、调度、同步互斥、死锁处理。</li><li><strong>存储管理</strong>：内存分配、回收、保护、地址映射、虚拟存储。</li><li><strong>设备管理</strong>：设备分配、I/O 控制、缓冲技术、SPOOLING 技术。</li><li><strong>文件管理</strong>：文件创建、删除、读写、目录管理、存储空间管理。</li><li><strong>接口管理</strong>：提供命令接口（用户直接操作）、程序接口（系统调用，应用程序使用）。</li></ul><h3 id="_8-操作系统的设计结构及其特点-教材-p36-1-7-1-1-7-4" tabindex="-1"><a class="header-anchor" href="#_8-操作系统的设计结构及其特点-教材-p36-1-7-1-1-7-4"><span>8. 操作系统的设计结构及其特点（教材 P36 1.7.1-1.7.4）</span></a></h3><ul><li><p>单内核结构（整体式结构）</p></li><li><p>特点：所有功能模块（进程管理、存储管理等）集成在核心内核中，直接运行在核心态。</p></li><li><p>优点：结构简单，通信效率高；缺点：可维护性差，一个模块出错可能导致整个系统崩溃。</p></li><li><p>层次式结构</p><ul><li>特点：将 OS 按功能划分为若干层次（如硬件层、内核层、应用层），上层依赖下层服务，下层不依赖上层。</li><li>优点：模块化强，易调试、易维护；缺点：层次间通信开销大。</li></ul></li><li><p>微内核结构</p><ul><li>特点：内核仅保留最核心功能（进程通信、地址映射、中断处理），其他功能（文件管理、设备管理）以 “用户态服务进程” 形式实现。</li><li>优点：可靠性高（服务进程出错不影响内核）、可扩展性强；缺点：进程通信开销大。</li></ul></li><li><p>模块化结构</p><ul><li>特点：将 OS 划分为独立模块，模块间通过标准化接口通信，加载时按需组合。</li><li>优点：兼顾模块化和效率，易扩展；缺点：接口设计复杂。</li></ul></li></ul><h3 id="_9-操作系统的运行模式-内核态与用户态-特别重点" tabindex="-1"><a class="header-anchor" href="#_9-操作系统的运行模式-内核态与用户态-特别重点"><span>9. 操作系统的运行模式：内核态与用户态（特别重点）</span></a></h3><ul><li><p>内核态（核心态、管态）</p><ul><li>特权级别：最高，可直接访问所有硬件资源（CPU、内存、I/O 设备）和执行所有指令（如中断指令、修改页表指令）。</li><li>运行内容：OS 内核程序（进程调度、内存管理、设备驱动）。</li></ul></li><li><p>用户态（目态）</p><ul><li>特权级别：最低，仅能访问用户自己的内存空间，不能直接访问硬件资源，只能执行非特权指令。</li><li>运行内容：应用程序（如浏览器、Word）。</li></ul></li><li><p>模式切换</p><ul><li><p>触发条件：用户态 → 内核态（主动 / 被动触发）：主动触发：<strong>系统调用</strong>（最常用场景），被动触发：<strong>外部中断（如硬件事件）或者异常（如程序错误）</strong></p></li><li><p>内核态 → 用户态（主动返回）：内核态不会 “被动” 切换到用户态，必须由内核主动执行 “返回指令” 触发</p></li><li><p>切换过程：保存用户态上下文（寄存器、程序计数器）→ 切换到内核态 → 执行内核程序 → 恢复用户态上下文 → 回到应用程序。</p></li><li><p>例如Word 作为应用程序，其自身的执行（包括字符输入、显示、文档存储等逻辑）始终运行在<strong>用户态</strong>。用户态是操作系统为应用程序分配的 “受限运行环境”，权限较低，无法直接访问硬件（如键盘、显卡）或核心系统资源（如内存管理、中断控制器），只能通过操作系统提供的 “系统调用（System Call）” 间接请求内核服务。用户输入的 “硬件触发环节” 需要短暂切换到<strong>内核态</strong>处理，之后立即返回用户态。</p></li><li><p>第一步：敲击键盘时，键盘硬件会产生<strong>中断信号（IRQ）</strong>，触发 CPU 从用户态切换到内核态（内核态拥有最高权限，可直接操作硬件和处理中断）；</p><p>第二步：内核态中的<strong>键盘驱动程序</strong>接收中断信号，读取键盘传递的字符数据（如 ASCII 码），并将其存入系统的 “输入缓冲区”；</p><p>第三步：中断处理完成后，CPU 从内核态切换回用户态，操作系统通过 “事件通知机制”（如 Windows 的消息队列、Linux 的信号 / 管道）将输入缓冲区中的字符数据传递给前台运行的 Word 程序；</p><p>第四步：Word 在用户态读取输入缓冲区中的字符，完成后续的显示和文档处理。</p></li></ul></li></ul><h3 id="教材重点补充-p16-p17-io-设备-p29-系统调用" tabindex="-1"><a class="header-anchor" href="#教材重点补充-p16-p17-io-设备-p29-系统调用"><span>教材重点补充（P16-P17 IO 设备 + P29 系统调用）</span></a></h3><ul><li><p>IO 设备</p><ul><li>分类：按传输速率（高速设备：磁盘、网卡；低速设备：键盘、鼠标）；按交互方式（字符设备、块设备，后续第四章详解）。</li><li>作用：计算机与外部世界的接口，负责数据输入（如键盘输入）和输出（如屏幕显示）。</li></ul></li><li><p>系统调用的过程和应用</p><ul><li>定义：应用程序请求 OS 内核提供服务的接口（如 open、read、write 函数）。</li><li>过程：1. 应用程序在用户态执行系统调用指令 → 2. 触发陷阱（Trap），切换到内核态 → 3. 内核执行对应服务程序 → 4. 完成后返回用户态，将结果返回应用程序。</li><li>应用：所有应用程序的底层操作都依赖系统调用（如打开文件需调用 open，分配内存需调用 malloc，底层是 brk 系统调用）。</li></ul></li></ul><h2 id="第二章-进程-处理机管理-——-期末核心重点章节" tabindex="-1"><a class="header-anchor" href="#第二章-进程-处理机管理-——-期末核心重点章节"><span>第二章 进程（处理机管理）—— 期末核心重点章节</span></a></h2><h3 id="_1-进程的定义" tabindex="-1"><a class="header-anchor" href="#_1-进程的定义"><span>1. 进程的定义</span></a></h3><ul><li>官方定义：进程是 “程序在计算机中的一次执行过程”，是 系统 进行<strong>资源分配和调度的基本单位</strong>。</li><li>通俗理解：正在运行的程序及其所需资源的集合（如打开的浏览器进程，包含浏览器程序代码、占用的内存、CPU 时间片等）。</li></ul><h3 id="_2-进程的特征-五大核心" tabindex="-1"><a class="header-anchor" href="#_2-进程的特征-五大核心"><span>2. 进程的特征（五大核心）</span></a></h3><ul><li><strong>动态性</strong>：进程是程序的执行过程，有生命周期（创建→就绪→运行→阻塞→终止）。</li><li><strong>并发性</strong>：多个进程可在同一时间段交替执行。</li><li><strong>独立性</strong>：进程是资源分配的基本单位，拥有独立的地址空间（代码段、数据段、堆栈段）。</li><li><strong>异步性</strong>：进程按 “走走停停” 的方式执行，但 OS 需保证其最终完成。</li><li><strong>结构性</strong>：进程实体由 “程序段 + 数据段 + PCB（进程控制块）” 组成。</li></ul><h3 id="_3-进程与程序的区别和联系" tabindex="-1"><a class="header-anchor" href="#_3-进程与程序的区别和联系"><span>3. 进程与程序的区别和联系</span></a></h3><table><thead><tr><th style="text-align:center;">维度</th><th style="text-align:center;">进程</th><th style="text-align:center;">程序</th></tr></thead><tbody><tr><td style="text-align:center;">本质</td><td style="text-align:center;">动态的执行过程</td><td style="text-align:center;">静态的指令集合（文件）</td></tr><tr><td style="text-align:center;">生命周期</td><td style="text-align:center;">有（创建→终止）</td><td style="text-align:center;">无（永久存在于磁盘）</td></tr><tr><td style="text-align:center;">资源占用</td><td style="text-align:center;">占用资源（内存、CPU、I/O）</td><td style="text-align:center;">不占用资源（仅占用磁盘空间）</td></tr><tr><td style="text-align:center;">对应关系</td><td style="text-align:center;">一个程序可对应多个进程（如多个浏览器窗口）</td><td style="text-align:center;">一个进程对应一个或多个程序（如进程执行时调用库程序）</td></tr><tr><td style="text-align:center;">联系</td><td style="text-align:center;">/进程是程序的执行实例，程序是进程的执行依据</td><td style="text-align:center;"></td></tr></tbody></table><h3 id="_4-进程实体的组成" tabindex="-1"><a class="header-anchor" href="#_4-进程实体的组成"><span>4. 进程实体的组成</span></a></h3><ul><li><strong>程序段</strong>：进程执行的代码（从磁盘加载到内存）。</li><li><strong>数据段</strong>：进程运行时操作的数据（全局变量、静态变量等）。</li><li><strong>PCB（进程控制块）</strong>：进程的 “身份证”，OS 通过 PCB 管理进程，是进程存在的唯一标志。</li></ul><h3 id="_5-pcb-的作用和特点" tabindex="-1"><a class="header-anchor" href="#_5-pcb-的作用和特点"><span>5. PCB 的作用和特点</span></a></h3><ul><li><p>核心作用</p><ol><li>记录进程的基本信息（进程 ID、进程状态、优先级）。</li><li>记录进程的资源占用情况（内存地址、打开的文件、占用的设备）。</li><li>记录进程的执行上下文（寄存器值、程序计数器 PC、堆栈指针）。</li></ol></li><li><p>特点</p><ul><li>常驻内存（PCB 始终在内存中，直到进程终止）。</li><li>每个进程对应唯一的 PCB，OS 通过 PCB 链表管理所有进程。</li></ul></li></ul><h3 id="_6-进程的状态及其变迁-并能说出原因" tabindex="-1"><a class="header-anchor" href="#_6-进程的状态及其变迁-并能说出原因"><span>6. 进程的状态及其变迁（并能说出原因）</span></a></h3><ul><li><p>三种基本状态</p><ol><li><strong>就绪态</strong>：进程已分配到除 CPU 外的所有资源，等待 CPU 调度（如进程创建后、时间片用完后、被唤醒后）。</li></ol></li></ul><ol start="2"><li><strong>运行态</strong>：进程占用 CPU，正在执行程序（仅单 CPU 系统中，同一时刻只有一个进程处于运行态）。</li><li><strong>阻塞态（等待态）</strong>：进程因等待某事件发生（如 I/O 完成、等待信号量）而暂停执行，释放 CPU（如进程调用 read 函数读取文件，需等待磁盘 I/O 完成）。</li></ol><ul><li><p><strong>状态变迁原因</strong></p><ul><li>就绪态→运行态：CPU 空闲，调度程序选中一个就绪进程（调度触发）。</li><li>运行态→就绪态：时间片用完，或有更高优先级进程进入就绪态（抢占式调度）。</li><li>运行态→阻塞态：进程<strong>请求某事件</strong>（如 I/O、等待信号量），主动放弃 CPU。</li><li>阻塞态→就绪态：等待的事件发生（如 I/O 完成、收到信号量），由 OS 唤醒。</li></ul></li></ul><h3 id="_7-处理机的执行状态-核心态、用户态" tabindex="-1"><a class="header-anchor" href="#_7-处理机的执行状态-核心态、用户态"><span>7. 处理机的执行状态（核心态、用户态）</span></a></h3><ul><li>与第一章 “运行模式” 一致，补充：进程在运行态时，可能在用户态执行（应用程序代码）或内核态执行（系统调用、中断处理）。</li></ul><h3 id="_8-内核的定义及功能-原语的定义及功能" tabindex="-1"><a class="header-anchor" href="#_8-内核的定义及功能-原语的定义及功能"><span>8. 内核的定义及功能；原语的定义及功能</span></a></h3><ul><li><p>内核</p><ul><li>定义：OS 的核心部分，运行在核心态，提供最基本的服务（进程管理、内存管理、中断处理）。</li><li>功能：进程调度、内存分配、设备驱动、中断处理、系统调用处理。</li></ul></li><li><p>原语</p><ul><li>定义：由若干条指令组成的 “原子操作”（执行过程中不可中断，<strong>要么全做，要么全不做</strong>）。</li><li>功能：保证操作的完整性和一致性（避免并发冲突）。</li><li>常见原语：进程创建原语（fork）、进程终止原语（exit）、P 操作原语、V 操作原语。</li></ul></li></ul><h3 id="_9-进程控制方式" tabindex="-1"><a class="header-anchor" href="#_9-进程控制方式"><span>9. 进程控制方式</span></a></h3><ul><li><p>定义：OS 对进程生命周期的管理（创建、终止、阻塞、唤醒、切换）。</p></li><li><p>核心手段：通过原语实现（因进程控制操作需原子性）。</p></li><li><p>具体操作：</p><ol><li><strong>进程创建</strong>：触发事件（用户登录、应用程序启动、父进程创建子进程）→ 分配 PCB→ 分配资源→ 将 PCB 加入就绪队列。</li><li><strong>进程终止</strong>：触发事件（程序执行完毕、异常终止、被父进程终止）→ 释放资源→ 回收 PCB→ 通知父进程。</li><li><strong>进程阻塞</strong>：进程请求某事件→ 保存上下文→ 状态改为阻塞态→ 加入阻塞队列→ 调度其他进程。</li><li><strong>进程唤醒</strong>：等待事件发生→ 找到对应阻塞进程→ 状态改为就绪态→ 加入就绪队列。</li></ol></li></ul><h3 id="_10-进程同步与互斥的定义" tabindex="-1"><a class="header-anchor" href="#_10-进程同步与互斥的定义"><span>10. 进程同步与互斥的定义</span></a></h3><ul><li><p>进程互斥：多个进程竞争临界资源（如打印机、共享变量）时，同一时刻只能有一个进程访问，其他进程需等待（避免资源冲突）。</p><ul><li>例子：两个进程同时往一个文件写数据，会导致数据错乱，需互斥访问。</li></ul></li><li><p>进程同步：多个进程按 “约定的顺序” 执行（协调进程间的协作关系）。</p><ul><li>例子：生产者进程生产数据后，消费者进程才能消费，需同步。</li></ul></li><li><p>核心区别：互斥是 “竞争关系”（同一资源），同步是 “协作关系”（顺序约定）。</p></li></ul><h3 id="_11-临界资源与临界区的定义" tabindex="-1"><a class="header-anchor" href="#_11-临界资源与临界区的定义"><span>11. 临界资源与临界区的定义</span></a></h3><ul><li><strong>临界资源</strong>：一次只能被一个进程访问的资源（硬件：打印机、扫描仪；软件：共享变量、共享文件）。</li><li><strong>临界区</strong>：进程中访问临界资源的代码段（如写共享变量的代码、打印文件的代码）。</li><li>核心原则：所有进程的临界区需互斥执行（同一时刻只有一个进程进入临界区）。</li></ul><h3 id="_12-好的互斥方案应遵循的条件-四大原则-也称进程同步四大原则" tabindex="-1"><a class="header-anchor" href="#_12-好的互斥方案应遵循的条件-四大原则-也称进程同步四大原则"><span>12. 好的互斥方案应遵循的条件（四大原则） 也称进程同步四大原则</span></a></h3><ul><li><strong>空闲让进</strong>：临界区空闲时，允许等待的进程进入。</li><li><strong>忙则等待</strong>：临界区被占用时，其他进程需等待，不能进入。</li><li><strong>有限等待</strong>：进程等待进入临界区的时间是有限的（避免饥饿）。</li><li><strong>让权等待</strong>：进程等待时，释放 CPU（<strong>避免忙等，提高 CPU 利用率</strong>）。</li></ul><h3 id="_13-信号量机制-p-down-v-up-操作的原理-特别重点" tabindex="-1"><a class="header-anchor" href="#_13-信号量机制-p-down-v-up-操作的原理-特别重点"><span>13. 信号量机制 P（down）V (up) 操作的原理（特别重点）</span></a></h3><ul><li><p><strong>信号量（S）</strong>：一个整型变量，用于表示 “可用资源的数量” 或 “等待事件的数量”，只能通过 P、V 原语操作。</p></li><li><p>P 操作（down 操作）</p><ul><li>指令：S = S - 1；</li></ul></li><li><p>若 S ≥ 0：进程继续执行（成功获取资源）；</p><ul><li>若 S ＜ 0：进程被阻塞，加入该信号量的等待队列。</li></ul></li><li><p>V 操作（up 操作）</p><ul><li>指令：S = S + 1；</li></ul></li><li><p>若 S ＞ 0：进程继续执行（释放资源后无等待进程）；</p><ul><li>若 S ≤ 0：从该信号量的等待队列中唤醒一个进程，使其进入就绪态。</li></ul></li><li><p>核心本质：P 操作 “申请资源”（S 减 1），V 操作 “释放资源”（S 加 1）。</p></li></ul><h3 id="_14-pv-操作解决互斥问题-特别重点" tabindex="-1"><a class="header-anchor" href="#_14-pv-操作解决互斥问题-特别重点"><span>14. PV 操作解决互斥问题（特别重点）</span></a></h3><ul><li><p>解题步骤</p><ol><li>确定临界资源，定义互斥信号量（初始值 S=1，代表临界资源可用）。</li><li>每个进程在进入临界区前执行 P (S)（申请资源）。</li><li>每个进程在退出临界区后执行 V (S)（释放资源）。</li></ol></li><li><p>例子</p><p>两个进程 P1、P2 互斥访问打印机。</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">信号量 mutex = 1;  // 互斥信号量，初始值1</span>
<span class="line">P1:                P2:</span>
<span class="line">  P(mutex);          P(mutex);</span>
<span class="line">  打印数据（临界区）;  打印数据（临界区）;</span>
<span class="line">  V(mutex);          V(mutex);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>原理：初始时 mutex=1，P1 执行 P (mutex) 后 mutex=0，进入临界区；若 P2 此时执行 P (mutex)，mutex=-1，P2 阻塞；P1 退出时 V (mutex)，mutex=0，唤醒 P2，P2 进入临界区。</p></li></ul><h3 id="_15-pv-操作解决生产者与消费者问题-特别重点" tabindex="-1"><a class="header-anchor" href="#_15-pv-操作解决生产者与消费者问题-特别重点"><span>15. PV 操作解决生产者与消费者问题（特别重点）</span></a></h3><ul><li><p><strong>问题描述</strong>：生产者进程生产数据放入缓冲区，消费者进程从缓冲区取数据消费；缓冲区满时生产者不能生产，缓冲区空时消费者不能消费；缓冲区是临界资源，需互斥访问。</p></li><li><p>解题步骤：</p><ol><li><p>定义信号量：</p><ul><li>空缓冲区信号量 empty（初始值 = 缓冲区大小 n，代表可用空缓冲区数量）；</li><li>满缓冲区信号量 full（初始值 = 0，代表可用数据数量）；</li><li>互斥信号量 mutex（初始值 = 1，保护缓冲区访问）。</li></ul></li><li><p>生产者进程：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">while(1) {</span>
<span class="line">  生产数据;</span>
<span class="line">  P(empty);  // 申请空缓冲区（empty减1）</span>
<span class="line">  P(mutex);  // 申请临界资源（缓冲区）</span>
<span class="line">  将数据放入缓冲区;</span>
<span class="line">  V(mutex);  // 释放临界资源</span>
<span class="line">  V(full);   // 通知消费者有新数据（full加1）</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>消费者进程：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">while(1) {</span>
<span class="line">  P(full);   // 申请满缓冲区（full减1）</span>
<span class="line"> P(mutex);  // 申请临界资源</span>
<span class="line">  从缓冲区取数据;</span>
<span class="line"> V(mutex);  // 释放临界资源</span>
<span class="line">  V(empty);  // 通知生产者有空缓冲区（empty加1）</span>
<span class="line"> 消费数据;</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol></li><li><p><strong>注意</strong>：P 操作顺序不能颠倒（<strong>先申请资源，再申请互斥</strong>），否则会导致死锁（如生产者先 P (mutex) 再 P (empty)，若缓冲区满，生产者阻塞，持有 mutex，消费者无法获取 mutex，也阻塞）。</p></li></ul><h3 id="_16-进程通信的类型及其过程和特点" tabindex="-1"><a class="header-anchor" href="#_16-进程通信的类型及其过程和特点"><span>16. 进程通信的类型及其过程和特点</span></a></h3><ul><li><p>定义：进程间交换数据的方式（高于 PV 操作，可传递大量数据）。</p></li><li><p>分类及特点</p><ol><li><p>共享存储</p><ul><li>原理：两个进程共享一块内存区域，通过读写该区域交换数据。</li><li>过程：OS 分配共享内存→ 进程 A 将数据写入共享内存→ 进程 B 从共享内存读取数据。</li><li>优点：速度快（直接访问内存）；缺点：需互斥访问，编程复杂。</li></ul></li><li><p>消息传递</p><ul><li>原理：进程通过发送 / 接收消息（含数据和控制信息）通信，OS 提供消息队列管理。</li><li>过程：进程 A 创建消息→ 调用 send 函数发送到消息队列→ 进程 B 调用 recv 函数从队列接收消息。</li><li>优点：安全（OS 管理消息队列）、灵活；缺点：开销较大（需 OS 转发）。</li><li>分类：直接通信（进程间直接发送，如管道）、间接通信（通过消息队列，如 MQ）。</li></ul></li><li><p>管道通信</p><ul><li>原理：特殊的文件（管道文件），用于父子进程或兄弟进程间通信，<strong>数据单向流动（半双工）</strong>。</li><li>过程：父进程创建管道→ fork 创建子进程→ 父进程写管道，子进程读管道（或反之）。</li><li>优点：简单易用；缺点：只能用于亲缘进程，半双工。</li></ul></li></ol></li></ul><h3 id="_17-进程调度的概念、方式、原因、过程" tabindex="-1"><a class="header-anchor" href="#_17-进程调度的概念、方式、原因、过程"><span>17. 进程调度的概念、方式、原因、过程</span></a></h3><ul><li><p><strong>概念</strong>：OS 按一定算法从就绪队列中选择一个进程，将 CPU 分配给它执行。</p></li><li><p>调度方式</p><ol><li><strong>非抢占式调度</strong>：一旦进程获得 CPU，直到它主动放弃（如完成、阻塞）才释放 CPU（优点：开销小；缺点：响应慢，不适用于分时系统）。</li><li><strong>抢占式调度</strong>：进程获得 CPU 后，OS 可强制剥夺其 CPU（如更高优先级进程进入就绪态）（优点：响应快；缺点：开销大，需保存上下文）。</li></ol></li><li><p>调度原因</p><ol><li>进程终止或阻塞（主动放弃 CPU）；</li><li>时间片用完（被动放弃 CPU）；</li><li>更高优先级进程进入就绪态（抢占式调度）。</li></ol></li><li><p>调度过程</p><ol><li>保存当前运行进程的上下文（寄存器、PC）；</li><li>从就绪队列中选择一个进程（按调度算法）；</li><li>恢复选中进程的上下文；</li><li>将 CPU 分配给该进程，使其从就绪态变为运行态。</li></ol></li></ul><h3 id="_18-进程调度的算法-特别重点" tabindex="-1"><a class="header-anchor" href="#_18-进程调度的算法-特别重点"><span>18. 进程调度的算法（特别重点）</span></a></h3><table><thead><tr><th style="text-align:center;">算法名称</th><th style="text-align:center;">核心思想</th><th style="text-align:center;">优点</th><th style="text-align:center;">缺点</th><th style="text-align:center;">适用场景</th></tr></thead><tbody><tr><td style="text-align:center;">先来先服务（FCFS）</td><td style="text-align:center;">按进程到达就绪队列的顺序调度</td><td style="text-align:center;">简单公平，无饥饿</td><td style="text-align:center;">短作业等待长作业，吞吐量低</td><td style="text-align:center;">批处理系统</td></tr><tr><td style="text-align:center;">短作业优先（SJF）</td><td style="text-align:center;">选择 “估计运行时间最短” 的就绪进程</td><td style="text-align:center;">缩短平均等待时间，吞吐量高</td><td style="text-align:center;">长作业饥饿，无法预估运行时间</td><td style="text-align:center;">批处理系统（已知作业运行时间）</td></tr><tr><td style="text-align:center;">最短剩余时间优先（SRTF）</td><td style="text-align:center;">SJF 的抢占式版本，选择 “剩余运行时间最短” 的进程</td><td style="text-align:center;">平均等待时间更短</td><td style="text-align:center;">长作业饥饿，上下文切换开销大</td><td style="text-align:center;">批处理系统</td></tr><tr><td style="text-align:center;">优先级调度</td><td style="text-align:center;">按进程优先级（静态 / 动态）调度</td><td style="text-align:center;">响应紧急进程（如实时进程）</td><td style="text-align:center;">低优先级进程饥饿</td><td style="text-align:center;">实时系统、分时系统</td></tr><tr><td style="text-align:center;">时间片轮转（RR）</td><td style="text-align:center;">给每个就绪进程分配固定时间片（如 10ms），轮流执行</td><td style="text-align:center;">响应快，无饥饿，适合交互</td><td style="text-align:center;">时间片过小：开销大；过大：响应慢</td><td style="text-align:center;">分时系统（Windows、Linux）</td></tr><tr><td style="text-align:center;">高响应比优先（HRRN）</td><td style="text-align:center;">选择 “响应比最高” 的进程（响应比 =（等待时间 + 运行时间）/ 运行时间）</td><td style="text-align:center;">兼顾短作业和长作业，无饥饿</td><td style="text-align:center;">计算响应比开销大</td><td style="text-align:center;">批处理系统</td></tr></tbody></table><h3 id="_19-高级调度-作业调度-的算法-特别重点" tabindex="-1"><a class="header-anchor" href="#_19-高级调度-作业调度-的算法-特别重点"><span>19. 高级调度（作业调度）的算法（特别重点）</span></a></h3><ul><li><p><strong>作业调度</strong>：从 “后备队列”（作业已提交但未装入内存）中选择作业，装入内存并创建进程，加入就绪队列（又称 “长程调度”）。</p></li><li><p><strong>核心区别</strong>：进程调度是 “短程调度”（分配 CPU），作业调度是 “长程调度”（分配内存）。</p></li><li><p>常用算法：与进程调度算法类似，重点掌握：</p><ol><li><strong>FCFS</strong>：按作业提交顺序调度，简单公平。</li><li><strong>短作业优先（SJF）</strong>：选择运行时间最短的作业，提高吞吐量。</li><li><strong>高响应比优先（HRRN）</strong>：兼顾短作业和长作业，无饥饿。</li><li><strong>优先级调度</strong>：优先调度高优先级作业（如紧急作业）。</li></ol></li></ul><h3 id="_20-线程的定义和作用-线程与进程的联系与区别、线程的类型-特别重点" tabindex="-1"><a class="header-anchor" href="#_20-线程的定义和作用-线程与进程的联系与区别、线程的类型-特别重点"><span>20. 线程的定义和作用；线程与进程的联系与区别、线程的类型（特别重点）</span></a></h3><ul><li><p>线程（轻量级进程 LWP）</p><ul><li>定义：进程内的 “执行单元”，是<strong>系统调度的基本单位</strong>（比进程更小，开销更低）。</li><li>作用：减少进程切换开销，提高并发效率（如浏览器的多个标签页对应多个线程，共享浏览器进程的资源）。</li></ul></li><li><p>线程与进程的联系与区别</p><p>| 维度 | 进程 | 线程 | | :------: | :----------------------------------: | :-----------------------------------: | | 资源分配 | 资源分配的基本单位（有独立地址空间） | 不分配资源（<strong>共享所属进程的资源</strong>） | | 调度 | 资源分配和资源调度的基本单位 | 系统调度的基本单位 | | 切换开销 | 大（需切换地址空间、资源上下文） | 小（仅切换执行上下文，如 PC、寄存器） | | 并发性 | 进程间并发 | 进程内线程并发 + 进程间并发 | | 生命周期 | 独立（父进程终止不影响子进程） | 依赖进程（进程终止，线程全部终止） | | 通信方式 | 需进程通信（共享存储、消息传递） | 直接共享进程资源（全局变量、文件） |</p></li><li><p>线程的类型</p><ol><li><p>用户级线程（ULT）</p><ul><li>管理主体：用户态线程库（如 POSIX 线程库），OS 内核不感知线程存在。</li><li>优点：切换开销小（用户态完成），灵活；缺点：一个线程阻塞，整个进程阻塞（内核只调度进程）。</li></ul></li><li><p>内核级线程（KLT）</p><ul><li>管理主体：OS 内核，每个线程对应一个内核线程（KT）。</li><li>优点：线程阻塞不影响其他线程，并发效率高；缺点：切换开销大（需内核态）。</li></ul></li><li><p><strong>混合级线程</strong>：用户级线程映射到内核级线程（如 N:M 映射），兼顾灵活性和并发效率（现代 OS 常用）。</p></li></ol></li></ul><h3 id="_21-死锁的定义" tabindex="-1"><a class="header-anchor" href="#_21-死锁的定义"><span>21. 死锁的定义</span></a></h3><ul><li>定义：多个进程因竞争资源而互相等待，且 “永远无法继续执行” 的状态（如进程 A 持有资源 1，等待资源 2；进程 B 持有资源 2，等待资源 1，两者互相等待，无法前进）。</li></ul><h3 id="_22-死锁发生的条件-四大必要条件-特别重点" tabindex="-1"><a class="header-anchor" href="#_22-死锁发生的条件-四大必要条件-特别重点"><span>22. 死锁发生的条件（四大必要条件，特别重点）</span></a></h3><ul><li><strong>互斥条件</strong>：资源只能被一个进程占用（临界资源）。</li><li><strong>请求与保持条件</strong>：进程持有部分资源，同时请求其他资源（不释放已持有资源）。</li><li><strong>不可剥夺条件</strong>：资源一旦分配给进程，不能被强制剥夺（只能由进程主动释放）。</li><li><strong>循环等待条件</strong>：多个进程形成 “资源请求循环链”（如 A→B→C→A）。</li><li>核心结论：死锁发生的充要条件是四个条件同时满足；只要破坏其中一个条件，就能避免死锁。</li></ul><h3 id="_23-处理死锁的常见方法-特别重点" tabindex="-1"><a class="header-anchor" href="#_23-处理死锁的常见方法-特别重点"><span>23. 处理死锁的常见方法（特别重点）</span></a></h3><ul><li><strong>四大方法</strong>： <ul><li>预防死锁</li><li>避免死锁</li><li>死锁的监测和恢复</li><li>忽略死锁</li></ul></li></ul><h3 id="_24-死锁-具体解决方法详解" tabindex="-1"><a class="header-anchor" href="#_24-死锁-具体解决方法详解"><span>24.死锁 具体解决方法详解</span></a></h3><ul><li><p>预防死锁</p><ul><li><p>原理：破坏死锁的一个或多个必要条件。</p></li><li><p>具体措施：</p><ol><li>破坏互斥条件：将临界资源改为共享资源（如虚拟打印机）。</li><li>破坏请求与保持条件：进程启动前一次性申请所有资源（缺点：资源利用率低）。</li><li>破坏不可剥夺条件：允许 OS 强制剥夺进程的资源（如高优先级进程抢占低优先级进程的资源）。</li><li>破坏循环等待条件：<strong>给资源编号</strong>，进程按 “升序” 申请资源（如资源 1→资源 2→资源 3）。</li></ol></li></ul></li><li><p>避免死锁（银行家算法，特别重点）</p><ul><li><p>原理：在资源分配前，判断 “分配后是否会导致死锁”，若不会则分配，否则拒绝。</p></li><li><p>核心概念：</p><ol><li>最大需求矩阵 Max：每个进程对每种资源的最大需求量。</li><li>已分配矩阵 Allocation：每个进程已获得的每种资源数量。</li><li>剩余需求矩阵 Need：Max - Allocation（进程还需要的资源数量）。</li><li>可用资源向量 Available：系统当前剩余的每种资源数量。</li></ol></li><li><p>算法步骤（以单种资源为例）：</p><ol><li><p>进程 P 请求资源 Request；</p></li><li><p>检查 Request ≤ Need（请求不超过剩余需求）；</p></li><li><p>检查 Request ≤ Available（系统有足够资源）；</p></li><li><p>假设分配资源，更新 Available = Available - Request，Allocation = Allocation + Request，Need = Need - Request；</p></li><li><p>检查更新后的系统是否处于 “安全状态”（存在一个安全序列，所有进程能顺利完成）；</p></li><li><p>若安全则分配，否则拒绝分配。</p></li></ol></li><li><p>安全状态：存在一个进程序列 P1、P2、…、Pn，使得每个进程 Pi 的 Need ≤ 系统当前可用资源，且 Pi 完成后释放资源，使后续进程能完成。</p></li></ul><p>​</p></li><li><p>死锁的检测和恢复（特别重点）</p><ul><li><p>原理：允许死锁发生，定期检测系统是否存在死锁（通过资源分配图化简）。</p></li><li><p>检测工具：资源分配图（节点：进程、资源；边：进程→资源（请求边）、资源→进程（分配边））。</p></li><li><p>死锁定理：资源分配图 “不可完全化简” 时，系统存在死锁。</p></li><li><p>化简步骤：</p><ol><li>找到 “没有请求边” 或 “请求边的资源都可用” 的进程，删除其所有边（分配边→释放资源，请求边→放弃请求）；</li><li>重复步骤 1，直到无法删除任何进程；</li><li>若所有进程都被删除（完全化简），则无死锁；否则，剩余进程构成死锁进程。</li></ol><p>死锁的恢复</p></li><li><p>原理：死锁发生后，采取措施打破死锁。</p></li><li><p>具体措施：</p><ol><li>资源剥夺：强制剥夺死锁进程的部分资源，分配给其他死锁进程。</li><li>进程终止：终止部分死锁进程（优先级低、运行时间短的进程），释放资源。</li><li>进程回滚：将死锁进程回滚到之前的安全状态（需记录进程运行状态）。</li></ol></li></ul><p>忽略死锁：鸵鸟算法</p><p>原理：忽略死锁（假设死锁很少发生），发生后重启系统。</p><p>优点：简单，开销小；缺点：适用于死锁影响小的场景（如个人电脑）。</p></li></ul><h3 id="_25-操作系统接口" tabindex="-1"><a class="header-anchor" href="#_25-操作系统接口"><span>25. 操作系统接口</span></a></h3><ul><li><p>命令接口：用户直接与 OS 交互的接口（分为两类）：</p><ol><li>联机命令接口（交互式）：如 Windows 的 CMD、Linux 的 Shell（输入命令，OS 立即响应）。</li></ol></li></ul><ol start="2"><li>脱机命令接口（批处理）：用户将命令写入批处理文件（如.bat 文件），OS 批量执行。</li></ol><ul><li><strong>程序接口（系统调用）</strong>：应用程序通过调用 OS 提供的函数（如 open、read、write）请求服务，是应用程序与 OS 内核的接口（详细见第一章）。</li></ul><h3 id="教材重点补充" tabindex="-1"><a class="header-anchor" href="#教材重点补充"><span>教材重点补充</span></a></h3><ul><li><p>教材 P49 导致进程创建的 4 种主要事件</p><ol><li>用户登录（如登录 Windows 系统，创建桌面进程）；</li><li>应用程序启动（如双击浏览器，创建浏览器进程）；</li><li>进程创建（父进程通过 fork 创建子进程）；</li><li>作业调度（批处理系统中，作业调度程序将作业装入内存，创建进程）。</li></ol></li><li><p>教材 P51 引起进程终止的条件</p><ol><li>正常终止（程序执行完毕，调用 exit 函数）；</li><li>异常终止（如除零错误、内存访问越界、非法指令）；</li><li>外界干预（如用户强制关闭进程、父进程终止子进程）。</li></ol></li><li><p>教材 P88 批处理系统的调度（作业调度）</p><p>作业调度的流程：作业提交→ 进入后备队列→ 作业调度算法选择作业→ 装入内存→ 创建进程→ 加入就绪队列→ 进程调度分配 CPU。</p></li></ul><h2 id="第三章-存储管理" tabindex="-1"><a class="header-anchor" href="#第三章-存储管理"><span>第三章 存储管理</span></a></h2><h3 id="_1-存储管理的功能-六大核心" tabindex="-1"><a class="header-anchor" href="#_1-存储管理的功能-六大核心"><span>1. 存储管理的功能（六大核心）</span></a></h3><ul><li><strong>内存分配</strong>：为进程分配内存空间（连续 / 非连续）。</li><li><strong>内存回收</strong>：进程终止后，回收其占用的内存空间。</li><li><strong>内存保护</strong>：防止进程访问其他进程的内存空间（如进程 A 不能修改进程 B 的内存数据）。</li><li><strong>地址映射（重定位）</strong>：将进程的逻辑地址转换为物理地址（因进程加载到内存的地址不固定）。</li><li><strong>内存共享</strong>：多个进程共享同一内存区域（如共享库、共享变量），节省内存。</li><li><strong>虚拟存储</strong>：通过 “内存 + 磁盘” 结合，为进程提供比物理内存更大的逻辑地址空间。</li></ul><h3 id="_2-存储空间和地址重定位-地址映射" tabindex="-1"><a class="header-anchor" href="#_2-存储空间和地址重定位-地址映射"><span>2. 存储空间和地址重定位（地址映射）</span></a></h3><ul><li><p>地址分类</p><ol><li>逻辑地址（虚拟地址）：进程代码中使用的地址（如变量的地址，由编译器分配，与物理内存无关）。</li><li>物理地址：内存单元的实际地址（硬件地址，进程执行时需访问物理地址）。</li></ol></li><li><p>地址重定位</p><ul><li><p>定义：将逻辑地址转换为物理地址的过程。</p></li><li><p>分类：</p><ol><li>静态重定位：进程加载到内存时，一次性完成地址转换（逻辑地址 + 加载起始地址 = 物理地址），运行时不能移动内存位置（优点：简单；缺点：灵活性差）。</li><li>动态重定位：进程运行时，每次访问内存都进行地址转换（需硬件支持：重定位寄存器），进程可移动（优点：灵活，支持内存共享；缺点：开销大）。</li></ol></li></ul></li></ul><h3 id="_3-分区存储管理-固定、动态、动态重定位" tabindex="-1"><a class="header-anchor" href="#_3-分区存储管理-固定、动态、动态重定位"><span>3. 分区存储管理：固定、动态、动态重定位</span></a></h3><ul><li><p>固定分区存储管理</p><ul><li><p>原理：将物理内存划分为若干个 “大小固定” 的分区，每个分区只能装入一个进程。</p></li><li><p>分配方式：根据进程大小，选择一个足够大的空闲分区装入。</p></li><li><p>映射：静态重定位（加载时确定物理地址）。</p></li><li><p>保护：通过分区表记录每个分区的起始地址和大小，防止进程越界。</p></li><li><p>数据结构：分区表（记录分区号、起始地址、大小、状态）。</p></li><li><p>优点：简单；缺点：内部碎片（分区内未使用的空间），资源利用率低。</p></li></ul></li><li><p>动态分区（可变分区）存储管理</p><ul><li>原理：根据进程大小 “动态划分” 内存分区，分区大小与进程大小一致。</li><li>分配方式：按需划分，无固定分区大小。</li><li>映射：动态重定位（需重定位寄存器）。</li><li>保护：通过进程控制块记录进程的内存起始地址和大小，访问时检查是否越界。</li><li>数据结构：空闲分区链（用链表记录空闲分区的起始地址和大小）。</li><li>优点：无内部碎片；缺点：外部碎片（空闲分区分散，无法满足大进程需求）。</li></ul></li><li><p>动态重定位分区管理</p><ul><li>原理：在动态分区基础上，通过 “紧凑（拼接）” 技术，将所有空闲分区合并为一个连续分区，解决外部碎片问题。</li><li>紧凑：移动所有已分配分区到内存一端，空闲分区集中到另一端（需动态重定位支持，因进程地址改变）。</li></ul></li></ul><h3 id="_4-动态分区分配算法" tabindex="-1"><a class="header-anchor" href="#_4-动态分区分配算法"><span>4. 动态分区分配算法</span></a></h3><table><thead><tr><th style="text-align:center;">算法名称</th><th style="text-align:center;">核心思想</th><th style="text-align:center;">优点</th><th style="text-align:center;">缺点</th></tr></thead><tbody><tr><td style="text-align:center;">首次适应（FF）</td><td style="text-align:center;">从空闲分区链头开始，选择第一个能容纳进程的空闲分区</td><td style="text-align:center;">简单，开销小，优先使用低地址空间</td><td style="text-align:center;">低地址空间碎片多，大进程难以分配</td></tr><tr><td style="text-align:center;">循环首次适应（NF）</td><td style="text-align:center;">从上次分配的分区后开始查找，选择第一个能容纳的分区</td><td style="text-align:center;">空闲分区分布均匀，避免低地址碎片</td><td style="text-align:center;">可能导致高地址空间碎片多</td></tr><tr><td style="text-align:center;">最佳适应（BF）</td><td style="text-align:center;">选择 “最小的能容纳进程” 的空闲分区</td><td style="text-align:center;">充分利用小分区，减少大分区浪费</td><td style="text-align:center;">产生大量小碎片，查找开销大</td></tr><tr><td style="text-align:center;">最坏适应（WF）</td><td style="text-align:center;">选择 “最大的空闲分区” 分配给进程</td><td style="text-align:center;">减少小碎片，适合大进程</td><td style="text-align:center;">大分区被拆分，后续大进程无法分配</td></tr></tbody></table><h3 id="_5-虚拟存储的概念-特别重点" tabindex="-1"><a class="header-anchor" href="#_5-虚拟存储的概念-特别重点"><span>5. 虚拟存储的概念（特别重点）</span></a></h3><ul><li><strong>核心问题</strong>：物理内存容量有限，无法同时装入所有进程，或大进程无法装入内存。</li><li><strong>定义</strong>：基于 “局部性原理”，将进程的部分代码和数据装入内存，其余部分放在磁盘（虚拟内存文件），运行时按需调入内存，实现 “逻辑内存＞物理内存”。</li><li><strong>局部性原理</strong>：进程运行时，只访问部分代码和数据（时间局部性：近期访问的指令再次访问；空间局部性：访问某地址时，附近地址也可能被访问）—— 虚拟存储的理论基础。</li><li><strong>优点</strong>：提高内存利用率，支持大进程运行，多进程并发度提高。</li><li><strong>缺点</strong>：增加磁盘 I/O 开销，可能导致 “抖动”（频繁缺页）。</li></ul><h3 id="_6-覆盖和对换技术的原理、特点" tabindex="-1"><a class="header-anchor" href="#_6-覆盖和对换技术的原理、特点"><span>6. 覆盖和对换技术的原理、特点</span></a></h3><ul><li><p>覆盖技术</p><ul><li>原理：将进程分为 “常驻部分”（核心代码）和 “覆盖部分”（不同时执行的代码），覆盖部分共享同一内存区域（覆盖区）。</li><li>特点：无硬件支持，需程序员手动划分覆盖段（编程复杂），<strong>仅适用于单进程</strong>。</li></ul></li><li><p>对换技术（交换技术）</p><ul><li>原理：将内存中暂时不用的进程（或进程的部分数据）换出到<strong>磁盘交换区</strong>，释放内存给其他进程；需要时再将其换入内存。</li><li>分类：整体对换（<strong>换出整个进程</strong>）、页面对换（<strong>换出部分页面，虚拟存储核心</strong>）。</li><li>特点：无需程序员干预，OS 自动管理，支持多进程并发；缺点：换入换出开销大（磁盘 I/O）。</li></ul></li></ul><h3 id="_7-页式存储分配主要是解决什么问题-按物理大小划分且无外部碎片" tabindex="-1"><a class="header-anchor" href="#_7-页式存储分配主要是解决什么问题-按物理大小划分且无外部碎片"><span>7. 页式存储分配主要是解决什么问题（按物理大小划分且无外部碎片）</span></a></h3><ul><li>核心问题：解决动态分区的 “外部碎片” 问题，提高内存利用率。</li><li>原理：将物理内存和进程的逻辑地址空间都划分为 “<strong>大小相等的页</strong>（Page）”，物理内存的页称为 “物理块（Block）”，通过页表将逻辑页映射到物理块。</li></ul><h3 id="_8-分页原理-逻辑地址到页号和页内偏移量的转换方法" tabindex="-1"><a class="header-anchor" href="#_8-分页原理-逻辑地址到页号和页内偏移量的转换方法"><span>8. 分页原理；逻辑地址到页号和页内偏移量的转换方法</span></a></h3><ul><li><p>分页原理</p><ul><li>逻辑地址空间：分为 n 个逻辑页（页号 0、1、2…n-1），每页大小为 2^k 字节（如 4KB=2^12 字节）。</li><li>物理内存：分为 m 个物理块（块号 0、1、2…m-1），<strong>块大小 = 页大小（保证页能装入块）</strong>。</li></ul></li><li><p><strong>逻辑地址结构</strong>：逻辑地址 = 页号（高位） + 页内偏移量（低位）（拼接）。例如：逻辑地址 <code>0x00003A68</code>（二进制 <code>... 0011 1010 0110 1000</code>），取低12位 <code>0xA68</code> 就是偏移量，剩下的高位就是页号。（0x表十六进制）</p></li><li><p>转换方法</p><ol><li><p>公式法</p><ul><li>页号 = 逻辑地址 ÷ 页大小（整除）；</li><li>页内偏移量 = 逻辑地址 % 页大小（取余）。</li><li>例子：页大小 4KB（4096），逻辑地址 10000 → 页号 = 10000÷4096=2，页内偏移量 = 10000%4096=1808。</li></ul></li><li><p>二进制法</p></li></ol><ul><li>页大小 = 2^k → 页内偏移量占 k 位，页号占剩余高位。</li><li>例子：页大小 4KB（2^12），逻辑地址 16 位 → 低 12 位是页内偏移量，高 4 位是页号。</li></ul></li></ul><h3 id="_9-页式存储的地址映射过程" tabindex="-1"><a class="header-anchor" href="#_9-页式存储的地址映射过程"><span>9. 页式存储的地址映射过程</span></a></h3><ul><li><p><strong>核心硬件</strong>：页表寄存器（PTR），存储页表在内存的起始地址。</p></li><li><p>映射步骤</p><ol><li>进程执行时，CPU 给出逻辑地址；</li><li>拆分逻辑地址为页号（P）和页内偏移量（W）；</li><li>检查页号是否超出页表长度（避免越界）；</li><li>计算页表项地址 = 页表起始地址（PTR） + P × 页表项大小；</li><li>从页表项中读取物理块号（B）；</li><li>物理地址 = B × 页大小 + W；</li><li>访问物理地址对应的内存单元。</li></ol></li></ul><h3 id="_10-二级页表的一级、二级页号和页内偏移量的计算" tabindex="-1"><a class="header-anchor" href="#_10-二级页表的一级、二级页号和页内偏移量的计算"><span>10. 二级页表的一级、二级页号和页内偏移量的计算</span></a></h3><ul><li><p><strong>问题背景</strong>：单级页表的页表可能很大（如逻辑地址 32 位，页大小 4KB → 页号 20 位 → 页表项 2^20=1048576 个），占用大量连续内存。</p></li><li><p><strong>二级页表原理</strong>：将页表再分页，形成 “一级页表（页目录）” 和 “二级页表”，一级页表的页表项指向二级页表的起始地址。</p></li><li><p><strong>逻辑地址结构</strong>：逻辑地址 = 一级页号（P1） + 二级页号（P2） + 页内偏移量（W）。</p></li><li><p>计算方法</p><ul><li><p>假设页大小 = 2^k，一级页表项数 = 2^a，二级页表项数 = 2^b → k+a+b = 逻辑地址位数。</p></li><li><p>一级页号（P1）= 逻辑地址 &gt;&gt; (b+k)（右移 b+k 位）；</p></li><li><p>二级页号（P2）= (逻辑地址&gt;&gt; k) &amp; (2^b - 1)（右移 k 位，与掩码取低 b 位）；</p></li><li><p>页内偏移量（W）= 逻辑地址 &amp; (2^k - 1)（取低 k 位）。</p></li></ul></li><li><p><strong>例子</strong>：逻辑地址 32 位，页大小 4KB（k=12），一级页号 8 位（a=8），二级页号 12 位（b=12） → P1 = 高 8 位，P2 = 中间 12 位，W = 低 12 位。</p></li></ul><h3 id="_11-请求分页原理-局部性原理-页表结构与缺页中断-特别重点" tabindex="-1"><a class="header-anchor" href="#_11-请求分页原理-局部性原理-页表结构与缺页中断-特别重点"><span>11. 请求分页原理；局部性原理；页表结构与缺页中断（特别重点）</span></a></h3><ul><li><p><strong>请求分页原理</strong>：虚拟存储的实现方式，进程加载时，只将部分页面装入内存，其余页面放在磁盘；运行时访问到未装入内存的页面，触发 “缺页中断”，OS 将页面从磁盘调入内存。</p></li><li><p><strong>局部性原理</strong>：见 “虚拟存储” 部分，是请求分页的理论基础（确保大部分访问的页面已在内存）。</p></li><li><p>请求分页页表结构,在普通页表项基础上增加控制位：</p><ul><li><p>存在位（P）：1 = 页面在内存，0 = 页面在磁盘；</p></li><li><p>访问位（A）：记录页面是否被访问（用于页面置换算法）；</p></li><li><p>修改位（M）：记录页面是否被修改（修改过的页面换出时需写回磁盘）；</p></li><li><p>磁盘地址：页面在磁盘上的位置（缺页时调入）。</p></li></ul></li><li><p>缺页中断</p><ul><li><p>定义：访问的页面不在内存时触发的中断（内中断）。</p></li><li><p>处理过程：</p><ol><li>保存当前进程上下文；</li><li>检查页表，确认页面在磁盘的位置；</li><li>若内存有空闲块，分配一块；若无，选择一个页面置换（页面置换算法）；</li><li>将页面从磁盘调入内存，更新页表项（存在位 = 1，物理块号 = 分配的块号）；</li><li>恢复进程上下文，重新执行被中断的指令。</li></ol></li></ul></li></ul><h3 id="_12-请求分页的地址变换" tabindex="-1"><a class="header-anchor" href="#_12-请求分页的地址变换"><span>12. 请求分页的地址变换</span></a></h3><ul><li><p>在普通页式地址映射基础上增加 “缺页检查”：</p><ol><li>拆分逻辑地址为页号和页内偏移量；</li><li>查找页表，检查存在位（P）；</li><li>若 P=1：按普通页式映射计算物理地址；</li><li>若 P=0：触发缺页中断，OS 调入页面后，再执行步骤 3。</li></ol></li></ul><h3 id="_13-页面置换算法-页面置换算法-教材-p119" tabindex="-1"><a class="header-anchor" href="#_13-页面置换算法-页面置换算法-教材-p119"><span>13. 页面置换算法（页面置换算法，教材 P119）</span></a></h3><ul><li><p><strong>核心问题</strong>：内存无空闲块时，选择哪个页面换出磁盘，以减少缺页率。</p></li><li><p>常用算法</p><table><thead><tr><th style="text-align:center;">算法名称</th><th style="text-align:center;">核心思想</th><th style="text-align:center;">优点</th><th style="text-align:center;">缺点</th></tr></thead><tbody><tr><td style="text-align:center;">最佳置换算法（OPT）</td><td style="text-align:center;">选择 “未来最长时间不被访问” 的页面换出</td><td style="text-align:center;">缺页率最低（理论最优）</td><td style="text-align:center;">无法实现（无法预知未来访问）</td></tr><tr><td style="text-align:center;">先进先出算法（FIFO）</td><td style="text-align:center;">选择 “最早装入内存” 的页面换出</td><td style="text-align:center;">简单，易实现</td><td style="text-align:center;">Belady 异常（内存块增加，缺页率反而上升）</td></tr><tr><td style="text-align:center;">最近最久未使用算法（LRU）</td><td style="text-align:center;">选择 “最近最长时间未被访问” 的页面换出</td><td style="text-align:center;">接近 OPT，缺页率低</td><td style="text-align:center;">需记录页面访问时间，开销大（硬件支持）</td></tr><tr><td style="text-align:center;">时钟算法（Clock）</td><td style="text-align:center;">页面设置访问位，内存块形成循环队列；检查访问位：1→置 0，继续；0→换出</td><td style="text-align:center;">开销小，易实现</td><td style="text-align:center;">缺页率略高于 LRU</td></tr><tr><td style="text-align:center;">改进 Clock 算法</td><td style="text-align:center;">同时检查访问位和修改位：优先换出 “访问位 = 0 且修改位 = 0” 的页面，其次 “访问位 = 0 且修改位 = 1”，最后 “访问位 = 1 且修改位 = 0”</td><td style="text-align:center;">减少磁盘 I/O（修改位 = 0 的页面无需写回）</td><td style="text-align:center;">实现稍复杂</td></tr></tbody></table></li></ul><h3 id="_14-分配置换策略-抖动定义" tabindex="-1"><a class="header-anchor" href="#_14-分配置换策略-抖动定义"><span>14. 分配置换策略；抖动定义</span></a></h3><ul><li><p>分配置换策略</p><ol><li><strong>固定分配局部置换</strong>：为每个进程分配固定数量的内存块，置换时仅从该进程的页面中选择（优点：公平；缺点：可能导致抖动）。</li><li><strong>可变分配全局置换</strong>：进程的内存块数量可动态调整，置换时从所有进程的页面中选择（优点：灵活，缺页率低；缺点：可能导致部分进程饥饿）。</li><li><strong>可变分配局部置换</strong>：为每个进程分配基础内存块，缺页率高时增加块数，缺页率低时减少块数，置换时仅从该进程页面中选择（兼顾公平和灵活，常用）。</li></ol></li><li><p>抖动（Thrashing）</p><ul><li>定义：进程频繁发生缺页中断，导致 CPU 大部分时间用于页面换入换出，进程执行效率急剧下降。</li><li>原因：内存分配不足，进程的工作集（当前运行所需的页面集合）未完全装入内存。</li><li>解决方法：增加进程的内存块数，或采用 “工作集模型”（按工作集大小分配内存）。</li></ul></li></ul><h3 id="_15-分段存储管理的目的-按逻辑来但有外部碎片" tabindex="-1"><a class="header-anchor" href="#_15-分段存储管理的目的-按逻辑来但有外部碎片"><span>15. 分段存储管理的目的（按逻辑来但有外部碎片）</span></a></h3><ul><li><p>解决页式存储的 “逻辑地址与用户逻辑不匹配” 问题（<strong>页式按物理大小划分，与程序的逻辑结构无关</strong>）。</p></li><li><p>满足用户需求：</p><ol><li>程序模块化（如函数、数据段作为独立段）；</li><li>分段共享（共享一个段，如共享库函数）；</li><li>分段保护（不同段设置不同权限，如代码段只读，数据段可读写）；</li><li>动态增长（如栈段、堆段可动态扩展）。</li></ol></li></ul><h3 id="_16-分段存储的地址结构" tabindex="-1"><a class="header-anchor" href="#_16-分段存储的地址结构"><span>16. 分段存储的地址结构</span></a></h3><ul><li>逻辑地址 = 段号（S） + 段内偏移量（W）。</li><li>段号：标识进程的某个段（如代码段、数据段、栈段）。</li><li>段内偏移量：段内的地址（不能超过段的长度，否则越界）。</li></ul><h3 id="_17-分段存储的地址变换过程" tabindex="-1"><a class="header-anchor" href="#_17-分段存储的地址变换过程"><span>17. 分段存储的地址变换过程</span></a></h3><ul><li><p><strong>核心数据结构</strong>：段表（每个进程一张段表，记录段号、段的起始地址、段的长度、权限）。</p></li><li><p>变换步骤</p><ol><li>拆分逻辑地址为段号（S）和段内偏移量（W）；</li><li>检查段号是否超出段表长度（段号越界）；</li><li>检查 W 是否超出该段的长度（段内越界）；</li><li>从段表中读取该段的起始地址（Base）；</li><li>物理地址 = Base + W；</li><li>访问物理地址对应的内存单元。</li></ol></li></ul><h3 id="_18-段页式存储管理原理和地址变换过程" tabindex="-1"><a class="header-anchor" href="#_18-段页式存储管理原理和地址变换过程"><span>18. 段页式存储管理原理和地址变换过程</span></a></h3><ul><li><p><strong>原理</strong>：结合分段和分页的优点（分段的逻辑清晰 + 分页的无外部碎片）。</p></li><li><p>核心思想</p><ol><li>逻辑地址空间：按用户逻辑划分为段，每个段再划分为页；</li><li>物理内存：划分为物理块；</li><li>数据结构：段表（每个段对应一个段表项，记录该段的页表起始地址） + 页表（每个段一张页表，记录页到物理块的映射）。</li></ol></li><li><p><strong>逻辑地址结构</strong>：逻辑地址 = 段号（S） + 页号（P） + 页内偏移量（W）。</p></li><li><p>地址变换步骤</p><ol><li>拆分逻辑地址为 S、P、W；</li><li>检查 S 是否越界，W 是否超出页大小；</li><li>查找段表，获取该段的页表起始地址；</li><li>查找该段的页表，获取物理块号（B）；</li><li>物理地址 = B × 页大小 + W；</li><li>访问物理内存。</li></ol></li></ul><h3 id="_19-请求段页式存储管理原理" tabindex="-1"><a class="header-anchor" href="#_19-请求段页式存储管理原理"><span>19. 请求段页式存储管理原理</span></a></h3><ul><li><p>结合请求分页和分段的优点，实现虚拟存储：</p><ul><li>逻辑地址空间：分段 + 分页；</li><li>内存中仅装入部分段的部分页面，其余页面在磁盘；</li><li>访问未装入内存的页面时，触发缺页中断，OS 调入页面；</li><li>段表项和页表项均包含存在位、磁盘地址等控制位。</li></ul></li></ul><h2 id="第四章-设备管理-输入输出" tabindex="-1"><a class="header-anchor" href="#第四章-设备管理-输入输出"><span>第四章 设备管理（输入输出）</span></a></h2><h3 id="_1-字符设备与块设备的分类" tabindex="-1"><a class="header-anchor" href="#_1-字符设备与块设备的分类"><span>1. 字符设备与块设备的分类</span></a></h3><ul><li><p>字符设备（字符流设备）</p><ul><li><p>定义：按字符为单位传输数据，无缓冲区（或仅有小缓冲区），实时性强。</p></li><li><p>特点：传输速率低，不可随机访问（只能顺序访问）。</p></li><li><p>例子：键盘、鼠标、打印机、串口。</p></li></ul></li><li><p>块设备</p><ul><li>定义：按块为单位传输数据（块大小固定，如 512 字节、4KB），有缓冲区。</li><li>特点：传输速率高，可随机访问（直接访问任意块）。</li><li>例子：硬盘、U 盘、光盘。</li></ul></li></ul><h3 id="_2-资源共享分类-独占设备、共享设备、虚拟设备" tabindex="-1"><a class="header-anchor" href="#_2-资源共享分类-独占设备、共享设备、虚拟设备"><span>2. 资源共享分类：独占设备、共享设备、虚拟设备</span></a></h3><ul><li><p>独占设备</p><ul><li>定义：一次只能分配给一个进程使用的设备（临界资源）。</li><li>例子：打印机、键盘（避免多个进程同时使用导致数据错乱）。</li></ul></li><li><p>共享设备</p><ul><li>定义：可同时被多个进程共享使用的设备（并发访问）。</li><li>例子：硬盘、U 盘（多个进程通过 OS 调度实现并发读写）。</li></ul></li><li><p>虚拟设备</p><ul><li>定义：通过软件（如 SPOOLING 技术）将<strong>独占设备抽象为多个 “逻辑共享设备”</strong>。</li><li>例子：虚拟打印机（多个进程同时提交打印任务，OS 缓存到磁盘，再依次打印）。</li></ul></li></ul><h3 id="_3-i-o设备的控制传输方式" tabindex="-1"><a class="header-anchor" href="#_3-i-o设备的控制传输方式"><span>3. I/O设备的控制传输方式</span></a></h3><table><thead><tr><th style="text-align:center;">控制方式</th><th style="text-align:center;">核心思想</th><th style="text-align:center;">优点</th><th style="text-align:center;">缺点</th><th style="text-align:center;">适用场景</th></tr></thead><tbody><tr><td style="text-align:center;">程序查询方式（忙等）</td><td style="text-align:center;">CPU 不断查询设备状态，直到设备就绪</td><td style="text-align:center;">简单，无硬件支持</td><td style="text-align:center;">CPU 利用率极低（忙等）</td><td style="text-align:center;">低速设备（如 LED 灯）</td></tr><tr><td style="text-align:center;">中断驱动方式</td><td style="text-align:center;">设备就绪后主动向 CPU 发中断，CPU 响应</td><td style="text-align:center;">CPU 利用率高，实时性强</td><td style="text-align:center;">需中断控制器，编程复杂</td><td style="text-align:center;">中低速设备（键盘、打印机）</td></tr><tr><td style="text-align:center;">DMA 方式（直接存储存取）</td><td style="text-align:center;">设备通过 DMA 控制器直接与内存交换数据，CPU 不参与</td><td style="text-align:center;">CPU 利用率最高，传输速率快</td><td style="text-align:center;">需 DMA 控制器，硬件成本高</td><td style="text-align:center;">高速设备（硬盘、网卡）</td></tr><tr><td style="text-align:center;">通道方式</td><td style="text-align:center;">专用通道处理器控制设备与内存交换数据，CPU 仅发命令</td><td style="text-align:center;">支持多设备并发，CPU 开销小</td><td style="text-align:center;">需通道硬件，成本高</td><td style="text-align:center;">大型机、服务器（多高速设备）</td></tr></tbody></table><h3 id="_4-dma-的工作原理和通道的工作原理-特别重点" tabindex="-1"><a class="header-anchor" href="#_4-dma-的工作原理和通道的工作原理-特别重点"><span>4. DMA 的工作原理和通道的工作原理（特别重点）</span></a></h3><ul><li><p>DMA 的工作原理（作为中间代理人）</p><ul><li><p>核心硬件：DMA 控制器（独立于 CPU 的硬件）。</p></li><li><p>工作过程：</p><ol><li>进程请求 I/O（如读取硬盘数据），CPU 向 DMA 控制器发送命令（设备地址、内存地址、传输长度）；</li><li>CPU 继续执行其他任务，DMA 控制器控制设备与内存直接交换数据；</li><li>数据传输完成后，DMA 控制器向 CPU 发中断；</li><li>CPU 响应中断，通知进程 I/O 完成。</li></ol></li></ul><p>进程请求I/O，cpu找dma控制器，完成后向cpu发终端，cpu响应中断，通知进程完成</p><ul><li>核心优势：CPU 无需参与数据传输，仅需发命令和处理中断，极大提高 CPU 利用率。</li></ul></li><li><p>通道的工作原理</p><ul><li><p>核心硬件：通道处理器（专用的 I/O 处理器，有自己的指令系统）。</p></li><li><p>工作过程：</p><ol><li>CPU 向通道发送 “通道程序”（包含 I/O 命令、设备地址、内存地址）；</li><li>通道执行通道程序，控制设备与内存交换数据，可同时控制多个设备；</li><li>所有 I/O 完成后，通道向 CPU 发中断；</li><li>CPU 响应中断，处理后续工作。</li></ol></li><li><p>核心优势：CPU 只需启动通道，无需干预 I/O 过程，支持多设备并发，适合大型系统。</p></li></ul></li></ul><h3 id="_5-缓冲技术-特别重点" tabindex="-1"><a class="header-anchor" href="#_5-缓冲技术-特别重点"><span>5. 缓冲技术（特别重点）</span></a></h3><ul><li><p><strong>核心问题</strong>：解决 CPU 与 I/O 设备之间 “速度不匹配” 的问题（CPU 快，I/O 设备慢），减少 CPU 等待时间。</p></li><li><p><strong>缓冲的定义</strong>：在内存中开辟一块区域（缓冲区），用于临时存放 CPU 与设备之间传输的数据。</p></li><li><p>缓冲的类型</p><ol><li><p>单缓冲</p><ul><li>结构：内存中一个缓冲区，CPU 与设备交替使用。</li><li>过程：设备将数据写入缓冲区→ CPU 从缓冲区读取数据（设备等待）；或 CPU 将数据写入缓冲区→ 设备从缓冲区读取数据（CPU 等待）。</li><li>优点：简单；缺点：<strong>CPU 与设备无法并行工作</strong>。</li></ul></li><li><p>双缓冲</p><ul><li>结构：内存中两个缓冲区（缓冲 1、缓冲 2）。</li><li>过程：设备写入缓冲 1 时，CPU 读取缓冲 2；设备写入缓冲 2 时，CPU 读取缓冲 1（<strong>并行工作</strong>）。</li><li>优点：CPU 与设备并行工作，提高效率；缺点：缓冲区开销大。</li></ul></li><li><p>循环缓冲</p><ul><li>结构：多个缓冲区组成循环队列（生产者 - 消费者模型）。</li><li>过程：设备（生产者）向队列写入数据，CPU（消费者）从队列读取数据，队列满时设备等待，队列空时 CPU 等待。</li><li>优点：支持高并发，适合批量数据传输。</li></ul></li><li><p>缓冲池</p><ul><li>结构：多个缓冲区组成的池（包含空闲缓冲队列、输入缓冲队列、输出缓冲队列），多个进程共享。</li><li>优点：缓冲区利用率高，支持多进程并发 I/O；缺点：管理复杂。</li></ul></li></ol></li></ul><h3 id="_6-设备分配的原则、策略、过程和使用的数据结构" tabindex="-1"><a class="header-anchor" href="#_6-设备分配的原则、策略、过程和使用的数据结构"><span>6. 设备分配的原则、策略、过程和使用的数据结构</span></a></h3><ul><li><p>设备分配原则</p><ol><li>安全性（避免死锁）；</li><li>高效性（提高设备利用率）；</li><li>公平性（多个进程公平竞争设备）。</li></ol></li><li><p>设备分配策略</p><ol><li><strong>静态分配</strong>：进程启动前<strong>一次性分配所有</strong>所需设备，终止后释放（优点：安全；缺点：利用率低）。</li><li><strong>动态分配</strong>：进程运行时按需申请设备，使用完毕后释放（优点：利用率高；缺点：需避免死锁）。</li><li><strong>抢占式分配</strong>：高优先级进程可抢占低优先级进程的设备（仅适用于可剥夺设备，如磁盘）。</li></ol></li><li><p>设备分配过程</p><ol><li><p>进程调用设备分配原语，申请设备；</p></li><li><p>检查设备是否空闲：</p><ul><li>若空闲：分配设备，更新设备控制表（DCT）的状态为 “忙”；</li><li>若忙：将进程加入设备的等待队列。</li></ul></li><li><p>分配控制器（设备需通过控制器连接内存）：</p><ul><li>检查控制器是否空闲：空闲则分配，否则将进程加入控制器等待队列。</li></ul></li><li><p>分配通道（大型机）：同理分配通道。</p></li></ol></li><li><p>核心数据结构</p><ol><li>设备控制表（DCT）：每个设备一张，记录设备编号、状态、控制器地址、等待队列。</li><li>控制器控制表（COCT）：每个控制器一张，记录控制器编号、状态、通道地址、等待队列。</li><li>通道控制表（CHCT）：每个通道一张，记录通道编号、状态、等待队列。</li><li>系统设备表（SDT）：整个系统一张，记录所有设备的 DCT 地址，是 OS 管理设备的入口。</li></ol></li></ul><h3 id="_7-设备的虚拟性与独立性的原理和实现-特别重点" tabindex="-1"><a class="header-anchor" href="#_7-设备的虚拟性与独立性的原理和实现-特别重点"><span>7. 设备的虚拟性与独立性的原理和实现（特别重点）</span></a></h3><ul><li><p>设备独立性（设备无关性）</p><ul><li><p>定义：应用程序不直接访问物理设备，而是通过 “逻辑设备名” 访问设备，OS 将逻辑设备名映射为物理设备名。</p></li><li><p>原理：OS 提供统一的设备接口，应用程序调用接口时使用逻辑设备名，OS 通过 “逻辑设备表（LUT）” 将逻辑设备名转换为物理设备名。</p></li><li><p>优点：应用程序无需修改即可适应不同物理设备（如更换打印机，只需修改 LUT），提高可移植性。</p></li><li><p>实现：逻辑设备表（LUT）记录逻辑设备名、物理设备名、设备驱动程序地址。</p></li></ul></li><li><p>设备的虚拟性</p><ul><li>定义：将物理设备抽象为多个逻辑设备，供多个进程同时使用（如 SPOOLING 技术将一台物理打印机抽象为多个虚拟打印机）。</li><li>原理：通过缓冲区和队列管理，将多个进程的 I/O 请求缓存，依次提交给物理设备。</li><li>实现：SPOOLING 技术（详细见下）。</li></ul></li></ul><h3 id="_8-spooling-技术-特别重点" tabindex="-1"><a class="header-anchor" href="#_8-spooling-技术-特别重点"><span>8. SPOOLING 技术（特别重点）</span></a></h3><ul><li><p><strong>定义</strong>：Simultaneous Peripheral Operations On-Line（联机并行外围操作），是<strong>一种将独占设备转换为虚拟设备的技术</strong>。</p></li><li><p><strong>核心思想</strong>：利用磁盘作为 “缓冲区”，将进程的 I/O 请求缓存到磁盘的 “输入井” <strong>或</strong> “输出井”(这取决于设备是输出设备还是输入设备)，再由 “井管理程序” 依次将请求提交给物理设备。</p></li><li><p>组成部分</p><ol><li>输入井：磁盘上的区域，存放进程的输入数据（从输入设备读入）。</li><li>输出井：磁盘上的区域，存放进程的输出数据（待输出到设备）。</li><li>输入井管理程序：控制输入设备将数据写入输入井。</li><li>输出井管理程序：控制输出井的数据写入输出设备。</li><li>虚拟设备：进程访问的逻辑设备（对应输入井 / 输出井）。</li></ol></li><li><p>例子（虚拟打印机）</p><ol><li>多个进程提交打印任务，OS 将打印数据写入输出井；</li><li>输出井管理程序按顺序将数据发送给物理打印机；</li><li>进程无需等待打印完成，可继续执行（异步 I/O）。</li></ol></li><li><p><strong>优点</strong>：提高独占设备利用率，实现多进程并发 I/O，提高系统吞吐量。</p></li></ul><h3 id="_9-设备驱动程序的功能、特点和工作过程-特别重点" tabindex="-1"><a class="header-anchor" href="#_9-设备驱动程序的功能、特点和工作过程-特别重点"><span>9. 设备驱动程序的功能、特点和工作过程（特别重点）</span></a></h3><ul><li><p><strong>设备驱动程序</strong>：OS 内核中与硬件设备直接交互的软件模块，是 OS 与硬件的接口。</p></li><li><p>核心功能</p><ol><li>接收 OS 的 I/O 命令（如 read、write）；</li><li>将 OS 的抽象命令转换为设备能理解的硬件指令（如磁盘的寻道指令、扇区读写指令）；</li><li>控制设备执行 I/O 操作；</li><li>检测设备状态（如是否就绪、是否出错）；</li><li>处理设备中断（如 I/O 完成中断）。</li></ol></li><li><p>特点</p><ol><li>与硬件紧密相关（不同设备的驱动程序不同）；</li><li>运行在核心态（需访问硬件资源）；</li><li>可加载 / 卸载（如 USB 设备插入时加载驱动，拔出时卸载）。</li></ol></li><li><p>工作过程（以磁盘读操作为例）</p><ol><li>应用程序调用 read 系统调用，请求读取磁盘数据；</li><li>OS 将请求传递给磁盘驱动程序；</li><li>驱动程序将抽象的 “读取逻辑地址” 转换为磁盘的 “物理地址”（磁头、柱面、扇区）；</li><li>驱动程序向磁盘控制器发送硬件指令（寻道、旋转、读数据）；</li><li>磁盘控制器执行指令，将数据从磁盘读入内存缓冲区；</li><li>数据传输完成后，磁盘控制器向 CPU 发中断；</li><li>驱动程序处理中断，通知 OS 数据读取完成；</li><li>OS 将数据从缓冲区复制到应用程序的地址空间，返回给应用程序。</li></ol></li></ul><h3 id="教材重点补充-必须掌握" tabindex="-1"><a class="header-anchor" href="#教材重点补充-必须掌握"><span>教材重点补充（必须掌握）</span></a></h3><ul><li><p>5.1.2 设备控制器</p><ul><li>定义：连接 CPU 与设备的硬件接口，负责接收 CPU 的指令，控制设备执行 I/O 操作。</li><li>组成：数据寄存器（存放传输数据）、控制寄存器（存放 CPU 指令）、状态寄存器（存放设备状态）。</li></ul></li><li><p>5.1.3 内存映射</p><ul><li>原理：将设备控制器的寄存器地址映射到物理内存地址空间，CPU 通过访问内存地址间接访问设备寄存器（无需专用 I/O 指令）。</li><li>优点：简化编程（CPU 访问设备寄存器与访问内存一致）。</li></ul></li><li><p><strong>5.1.4 DMA</strong>：见 “DMA 的工作原理”。</p></li><li><p>5.1.5 重温中断</p><ul><li><p>中断定义：设备或硬件发生事件时，向 CPU 发送信号，请求 CPU 暂停当前任务，处理该事件。</p></li><li><p>中断处理过程：保存上下文→ 执行中断服务程序→ 恢复上下文。</p></li><li><p>中断优先级：不同中断的优先级不同（如 DMA 中断优先级高于键盘中断）。</p></li></ul></li><li><p>5.2 I/O 软件原理</p><ul><li>I/O 软件的目标：设备独立性、统一接口、高效性、可靠性。</li></ul></li><li><p>5.3 I/O 软件层次</p><p>（从底层到上层）：</p><ol><li>硬件层：设备、控制器、DMA；</li><li>中断处理程序：处理设备中断；</li><li>设备驱动程序：控制设备执行 I/O；</li><li>设备独立性软件：提供统一接口、逻辑设备名映射、缓冲管理；</li><li>应用程序层：调用系统调用请求 I/O。</li></ol><ul><li>需弄懂图 5-11（I/O 软件层次结构）、图 5-13（中断处理流程）、图 5-17（SPOOLING 系统结构）。</li></ul></li></ul><h2 id="第五章-文件系统" tabindex="-1"><a class="header-anchor" href="#第五章-文件系统"><span>第五章 文件系统</span></a></h2><h3 id="_1-文件的定义" tabindex="-1"><a class="header-anchor" href="#_1-文件的定义"><span>1. 文件的定义</span></a></h3><ul><li>定义：由创建者定义的、具有文件名的一组相关数据的集合（是 OS 管理磁盘数据的基本单位）。</li><li>组成：文件内容（数据） + 文件属性（文件名、大小、创建时间、权限、物理地址）。</li></ul><h3 id="_2-文件类型" tabindex="-1"><a class="header-anchor" href="#_2-文件类型"><span>2. 文件类型</span></a></h3><ul><li><p>按用途分类：</p><ul><li>系统文件（OS 内核、驱动程序）、用户文件（文档、图片）、库文件（共享函数库）。</li></ul></li><li><p>按访问方式分类：</p><ul><li>顺序文件（只能顺序访问）、随机文件（可直接访问任意记录）。</li></ul></li><li><p>按物理结构分类：</p><ul><li>顺序文件、链接文件、索引文件。</li></ul></li><li><p>按文件格式分类：</p><ul><li>文本文件（ASCII 码）、二进制文件（二进制数据）。</li></ul></li></ul><h3 id="_3-文件系统的功能-六大核心" tabindex="-1"><a class="header-anchor" href="#_3-文件系统的功能-六大核心"><span>3. 文件系统的功能（六大核心）</span></a></h3><ul><li><strong>文件管理</strong>：文件的创建、删除、读写、修改。</li><li><strong>目录管理</strong>：目录的创建、删除、检索（查找文件）。</li><li><strong>存储空间管理</strong>：管理磁盘空闲空间（分配、回收）。</li><li><strong>文件保护</strong>：防止文件被非法访问（读、写、执行）。</li><li><strong>接口管理</strong>：提供文件操作的系统调用（open、read、write、close）。</li><li><strong>性能优化</strong>：提高文件访问速度（如缓存、磁盘调度）。</li></ul><h3 id="_4-文件系统的结构-层次结构-从底层到上层" tabindex="-1"><a class="header-anchor" href="#_4-文件系统的结构-层次结构-从底层到上层"><span>4. 文件系统的结构（层次结构，从底层到上层）</span></a></h3><ul><li><strong>物理层</strong>：磁盘硬件（磁头、柱面、扇区），处理物理 I/O。</li><li><strong>物理文件系统层</strong>：管理磁盘空闲空间，将逻辑块映射为物理扇区。</li><li><strong>文件组织模块层</strong>：管理文件的物理结构（顺序、链接、索引）。</li><li><strong>基本文件系统层</strong>：处理文件控制块（FCB）和目录，提供文件检索。</li><li><strong>存取控制验证层</strong>：检查用户对文件的访问权限。</li><li><strong>用户接口层</strong>：提供文件操作接口（系统调用、命令接口）。</li></ul><h3 id="_5-文件的逻辑结构和物理结构-特别重点" tabindex="-1"><a class="header-anchor" href="#_5-文件的逻辑结构和物理结构-特别重点"><span>5. 文件的逻辑结构和物理结构（特别重点）</span></a></h3><h4 id="_1-文件的逻辑结构-续" tabindex="-1"><a class="header-anchor" href="#_1-文件的逻辑结构-续"><span>（1）文件的逻辑结构（续）</span></a></h4><ol><li><p>索引顺序结构</p><ul><li>定义：结合顺序结构和索引结构的优点，将文件的逻辑记录分为若干 “组”，每组内记录顺序存放，同时为每组建立一个索引项（记录组的起始地址和组内记录数），所有索引项组成索引表。</li><li>优点：兼顾顺序访问（组内顺序）和随机访问（通过索引定位组），插入 / 删除比纯顺序结构灵活；</li><li>缺点：索引表占用一定空间，组内插入 / 删除仍需移动记录；</li><li>适用场景：大型文件（如数据库表），需频繁顺序访问和偶尔随机访问。</li></ul></li></ol><h4 id="_2-文件的物理结构-文件在磁盘上的实际存储方式-与存储介质相关" tabindex="-1"><a class="header-anchor" href="#_2-文件的物理结构-文件在磁盘上的实际存储方式-与存储介质相关"><span>（2）文件的物理结构（文件在磁盘上的实际存储方式，与存储介质相关）</span></a></h4><ol><li><p><strong>顺序结构（连续结构）</strong>：</p><ul><li><p>定义：文件的所有数据块连续存放在磁盘的连续物理扇区中（如磁盘上的一块连续空间）。</p></li><li><p>逻辑块与物理块的映射：逻辑块号 i → 物理块号 = 起始物理块号 + i；</p></li><li><p>优点：</p><ul><li>访问速度快（磁盘寻道一次后，可连续读取所有数据，减少寻道时间）；</li></ul></li></ul></li></ol><ul><li><p>管理简单（仅需记录文件的起始物理块号和总块数）；</p></li><li><p>缺点：</p><ul><li>磁盘空间利用率低（易产生外部碎片，连续空间不足时无法存储大文件）；</li></ul></li><li><p>扩展困难（文件增大时需重新分配连续空间，移动已有数据）；</p><ul><li>不适合频繁修改（插入 / 删除数据需移动后续数据块）；</li></ul></li><li><p>适用场景：小型静态文件（如系统配置文件、只读文件）。</p></li></ul><ol start="2"><li><p><strong>链接结构（链式结构）</strong>：</p><ul><li><p>定义：文件的数据块分散存放在磁盘的非连续扇区中，每个数据块通过 “链接指针” 指向后续数据块，最后一个数据块的指针为 NULL。</p></li><li><p>分类：</p><ul><li>隐式链接：链接指针存放在数据块的末尾（用户不可见），如 FAT 文件系统；</li><li>显式链接：链接指针单独存放在 “文件分配表（FAT）” 中（FAT 表是一张全局表，记录所有数据块的链接关系）；</li></ul></li><li><p>逻辑块与物理块的映射：通过 FAT 表查找，逻辑块号 i 需从起始块开始依次遍历 i 个指针；</p></li><li><p>优点：</p><ul><li>无外部碎片（数据块可分散分配）；</li><li>扩展灵活（文件增大时直接分配空闲块，更新链接指针即可）；</li></ul></li><li><p>缺点：</p><ul><li>随机访问极慢（访问第 i 个逻辑块需遍历前 i-1 个块的指针，“链式查找” 开销大）；</li><li>可靠性差（链接指针损坏会导致文件数据丢失，如 FAT 表损坏）；</li><li>链接指针占用数据块空间（隐式链接）；</li></ul></li><li><p>适用场景：大型顺序访问文件（如视频文件、日志文件），无需随机访问。</p></li></ul></li><li><p><strong>索引结构</strong>：</p><ul><li><p>定义：文件的数据块分散存放，为文件建立一张 “索引表”（单独存放在磁盘的索引块中），索引表的每个表项对应一个数据块，记录该数据块的物理块号。</p></li><li><p>逻辑块与物理块的映射：逻辑块号 i → 索引表第 i 项 → 物理块号；</p></li><li><p>优点：</p><ul><li>随机访问快（直接通过逻辑块号查找索引表，无需遍历）；</li><li>无外部碎片（数据块分散分配）；</li><li>扩展灵活（新增数据块时，只需在索引表中新增一项）；</li><li>插入 / 删除方便（仅需修改索引表，无需移动数据块）；</li></ul></li><li><p>缺点：</p><ul><li>索引块占用磁盘空间（文件越小，索引块开销占比越高）；</li><li>访问文件需两次磁盘 I/O（先读索引块，再读数据块）；</li></ul></li><li><p>适用场景：需频繁随机访问的文件（如数据库文件、文档文件），是现代文件系统的主流结构。</p></li></ul></li></ol><h3 id="_6-unix-的多级索引结构-特别重点" tabindex="-1"><a class="header-anchor" href="#_6-unix-的多级索引结构-特别重点"><span>6. Unix 的多级索引结构（特别重点）</span></a></h3><ul><li><p><strong>背景</strong>：普通索引结构的索引表若过大，会占用多个连续索引块，管理不便。Unix（如 ext2/ext3）采用 “多级索引” 优化，支持大文件存储。</p></li><li><p>结构组成：文件控制块（FCB）中记录 13 个索引项（直接索引项 + 间接索引项）：</p><ol><li>前 10 个：直接索引项 → 直接指向文件的前 10 个数据块（逻辑块 0~9）；</li><li>第 11 个：一级间接索引项 → 指向一个 “一级间接索引块”，该块中存放多个数据块的物理块号（逻辑块 10~10+k-1，k 为索引块可容纳的表项数，如 4KB 索引块可存 1024 个表项）；</li><li>第 12 个：二级间接索引项 → 指向一个 “二级间接索引块”，该块中存放多个一级间接索引块的物理块号，每个一级间接索引块再指向数据块（逻辑块 10+k~10+k+k²-1）；</li><li>第 13 个：三级间接索引项 → 指向一个 “三级间接索引块”，该块指向多个二级间接索引块，以此类推（逻辑块 10+k+k²~10+k+k²+k³-1）。</li></ol></li><li><p><strong>逻辑地址拆分</strong>：逻辑块号 → 确定索引级别（直接 / 一级间接 / 二级间接 / 三级间接）→ 查找对应索引块 → 定位物理块号；</p></li><li><p>优点</p><ul><li>支持超大文件存储（如 4KB 块大小，k=1024 时，最大文件大小 = 10 + 1024 + 1024² + 1024³ ≈ 1TB）；</li><li>小文件无需多级索引（直接索引），访问效率高；</li></ul></li><li><p>缺点</p><ul><li>多级索引访问需多次磁盘 I/O（如三级间接索引需读 4 次磁盘：三级索引块→二级索引块→一级索引块→数据块）；</li><li>索引块占用一定空间。</li></ul></li></ul><h3 id="_7-文件存储空间的管理-空闲块管理-特别重点" tabindex="-1"><a class="header-anchor" href="#_7-文件存储空间的管理-空闲块管理-特别重点"><span>7. 文件存储空间的管理（空闲块管理，特别重点）</span></a></h3><ul><li><p><strong>核心任务</strong>：记录磁盘上的空闲物理块，为新文件分配空闲块，回收被删除文件的物理块，避免空间浪费。</p></li><li><p>常用管理方法</p><ol><li><strong>空闲块链法</strong>：</li></ol><ul><li><p>原理：将所有空闲物理块用 “链接指针” 串联成一个链表，链表头记录在文件系统的超级块中。</p></li><li><p>分配过程：从链表头取下所需数量的空闲块，更新链表头指针；</p></li><li><p>回收过程：将释放的物理块插入空闲块链表（表头或表尾）；</p></li><li><p>分类：</p><ul><li><p>隐式链接（指针存放在空闲块内部）：管理简单，但遍历链表慢；</p></li><li><p>显式链接（指针存放在单独的 “空闲块链表文件” 中）：是链表，遍历效率高于隐式链接；</p></li><li><p>优点：管理简单，无额外空间开销（指针存放在空闲块或专用文件）；</p></li></ul></li><li><p>缺点：</p><ul><li><p>分配 n 个块需遍历链表 n 次（效率低）；</p></li><li><p>链表指针损坏会导致 “空闲块丢失”；</p></li><li><p>适用场景：小型文件系统或磁盘空间较小的场景。</p></li></ul></li></ul></li></ul><ol start="2"><li><p><strong>位示图法</strong>：</p><ul><li><p>原理：用一张 “位示图”（二进制数组）表示磁盘物理块的状态，每位对应一个物理块：0 = 空闲，1 = 已分配。</p></li><li><p>磁盘物理块总数 = 位示图的位数（如磁盘有 1000 个物理块，位示图为 1000 位，即 125 字节）；</p></li><li><p>分配过程：</p><ol><li>遍历位示图，查找值为 0 的位（空闲块）；</li><li>若找到，将该位置 1，并计算对应的物理块号（物理块号 = 字节号 ×8 + 位号）；</li></ol><ul><li><p>回收过程：</p><ol><li>计算释放块对应的字节号和位号；</li></ol></li></ul></li></ul><ol start="2"><li>将该位置 0；</li></ol><ul><li><p>优点：</p><ul><li>分配和回收速度快（位运算效率高）；</li></ul></li><li><p>位示图占用空间小（如 1TB 磁盘，4KB 块大小 → 物理块数 = 268435456 → 位示图大小 = 32MB）；</p></li><li><p>便于查找连续空闲块（适合顺序结构文件）；</p></li><li><p>缺点：位示图需常驻内存（占用少量内存）；</p><ul><li>适用场景：大中型文件系统（如 Windows、Linux），是最常用的空闲块管理方法。</li></ul></li></ul></li><li><p><strong>成组链接法</strong>：</p><ul><li><p>原理：结合空闲块链和空闲块表的优点，将空闲块分成若干 “组”，每组的第一个块（“组长块”）记录该组内所有空闲块的块号和下一组的组长块号，最后一组的组长块号为 NULL。</p></li><li><p>分配过程：</p><ol><li>从当前组中分配空闲块（优先分配非组长块）；</li><li>若当前组无空闲块，读取下一组的组长块，更新当前组信息；</li></ol><ul><li><p>回收过程：</p><ol><li>将释放的块加入当前组；</li><li>若当前组满，新释放的块作为新组长块，链接到原组长块前；</li></ol></li><li><p>优点：</p><ul><li>分配效率高（组内块号可直接访问，无需遍历整个链表）；</li><li>支持大磁盘（分组管理减少遍历开销）；</li></ul></li><li><p>缺点：实现复杂；</p></li><li><p>适用场景：大型文件系统（如 Unix、Linux 的 ext 系列文件系统）。</p></li></ul></li></ul></li><li><p><strong>空闲块表法</strong>：</p><ul><li><p>原理：用一张 “空闲块表” 记录所有空闲块，表项包含 “空闲块起始块号” 和 “空闲块个数”（连续空闲块）。</p></li><li><p>分配过程：按分配算法（如首次适应、最佳适应）查找空闲块表，找到足够大的连续空闲块，分割后更新表项；</p></li><li><p>回收过程：检查释放块的前后是否有连续空闲块，合并后更新表项；</p></li><li><p>优点：适合分配连续空闲块（顺序结构文件）；</p></li><li><p>缺点：</p><ul><li><p>空闲块表占用内存（块数越多，表越大）；</p><ul><li>合并空闲块开销大；</li></ul></li><li><p>适用场景：以顺序结构为主的文件系统。</p></li></ul></li></ul></li></ol><h3 id="_8-磁盘-i-o-调度算法-特别重点-教材-5-4-3" tabindex="-1"><a class="header-anchor" href="#_8-磁盘-i-o-调度算法-特别重点-教材-5-4-3"><span>8. 磁盘 I/O 调度算法（特别重点，教材 5.4.3）</span></a></h3><ul><li><strong>核心问题</strong>：磁盘 I/O 的瓶颈是 “寻道时间”（磁头移动到目标磁道的时间），调度算法的目标是减少总寻道时间，提高磁盘 I/O 吞吐量。</li><li><strong>磁盘物理结构</strong>：磁盘由多个盘片组成，每个盘片有上下两个盘面，每个盘面划分多个 “磁道”（同心圆），每个磁道划分多个 “扇区”（数据存储单元）；磁头沿盘面径向移动，寻道时间是磁头从当前磁道到目标磁道的时间。</li><li><strong>常用调度算法</strong>：</li></ul><table><thead><tr><th style="text-align:center;">算法名称</th><th style="text-align:center;">核心思想</th><th style="text-align:center;">优点</th><th style="text-align:center;">缺点</th><th style="text-align:center;">适用场景</th></tr></thead><tbody><tr><td style="text-align:center;">先来先服务（FCFS）</td><td style="text-align:center;">按 I/O 请求到达的顺序处理，磁头按请求顺序移动</td><td style="text-align:center;">简单公平，无饥饿</td><td style="text-align:center;">寻道时间长（可能频繁在远近距离磁道间移动，“抖动”）</td><td style="text-align:center;">小型系统、请求少的场景</td></tr><tr><td style="text-align:center;">最短寻道时间优先（SSTF）</td><td style="text-align:center;">选择 “当前磁头位置到目标磁道距离最短” 的 I/O 请求先处理</td><td style="text-align:center;">寻道时间短，吞吐量高于 FCFS</td><td style="text-align:center;">低优先级请求饥饿（远磁道请求长期被忽略）</td><td style="text-align:center;">请求较均衡的场景</td></tr><tr><td style="text-align:center;">扫描算法（SCAN，电梯算法）</td><td style="text-align:center;">磁头沿一个方向（如从内到外）移动，处理沿途所有 I/O 请求，到达磁盘边缘后反向移动</td><td style="text-align:center;">无饥饿，寻道时间较均衡</td><td style="text-align:center;">靠近边缘的磁道请求等待时间长</td><td style="text-align:center;">大中型系统、请求密集的场景（如服务器）</td></tr><tr><td style="text-align:center;">循环扫描算法（C-SCAN）</td><td style="text-align:center;">磁头沿一个方向移动，处理沿途请求，到达磁盘边缘后直接返回另一端起始位置（不处理反向沿途请求）</td><td style="text-align:center;">请求等待时间更均匀，减少边缘磁道延迟</td><td style="text-align:center;">仍有部分请求等待时间较长</td><td style="text-align:center;">对延迟敏感的场景</td></tr><tr><td style="text-align:center;">LOOK 算法（改进 SCAN）</td><td style="text-align:center;">磁头沿一个方向移动，仅处理当前方向上有请求的磁道，无请求时立即反向（不走到磁盘边缘）</td><td style="text-align:center;">减少无效寻道（避免磁头走到无请求的边缘）</td><td style="text-align:center;">实现稍复杂</td><td style="text-align:center;">现代操作系统（如 Windows、Linux）</td></tr><tr><td style="text-align:center;">循环 LOOK 算法（C-LOOK）</td><td style="text-align:center;">磁头沿一个方向移动，处理沿途请求，无请求时直接返回当前方向的最远端请求磁道（不走到磁盘边缘）</td><td style="text-align:center;">寻道效率最高，等待时间最均匀</td><td style="text-align:center;">实现复杂</td><td style="text-align:center;">高性能服务器、大型存储系统</td></tr></tbody></table><ul><li><p>示例：假设当前磁头在磁道 100，待处理 I/O 请求的磁道号为：55、58、39、18、90、160、150、38、184。</p><ul><li>FCFS 处理顺序：100→55→58→39→18→90→160→150→38→184，总寻道距离 = 45+3+19+21+72+70+10+112+146=498；</li><li>SSTF 处理顺序：100→90→58→55→39→38→18→150→160→184，总寻道距离 = 10+32+3+16+1+20+132+10+24=248；</li><li>SCAN 处理顺序（从内到外，假设磁盘磁道 0~199）：100→90→58→55→39→38→18→150→160→184，总寻道距离 = 10+32+3+16+1+20+132+10+24=248（与 SSTF 相同，因请求分布特殊）；</li><li>C-LOOK 处理顺序：100→90→58→55→39→38→18→150→160→184，总寻道距离同上，但若后续无请求，磁头无需走到 199，直接返回 18。</li></ul></li></ul><h3 id="_9-文件目录和检索" tabindex="-1"><a class="header-anchor" href="#_9-文件目录和检索"><span>9. 文件目录和检索</span></a></h3><h4 id="_1-文件目录的定义" tabindex="-1"><a class="header-anchor" href="#_1-文件目录的定义"><span>（1）文件目录的定义</span></a></h4><ul><li>文件目录是 “文件控制块（FCB）的集合”，用于记录文件的属性信息（如文件名、物理地址、权限），实现文件的 “按名存取”（用户通过文件名查找文件，无需知道物理地址）。</li><li>目录本身也是一种文件（称为 “目录文件”），存储在磁盘上。</li></ul><h4 id="_2-文件目录的结构" tabindex="-1"><a class="header-anchor" href="#_2-文件目录的结构"><span>（2）文件目录的结构</span></a></h4><ol><li><p><strong>单级目录结构</strong>：</p><ul><li>定义：整个文件系统只有一个目录，所有文件的 FCB 都存放在该目录中。</li></ul></li></ol><ul><li>优点：结构简单，查找快（适合文件少的场景）； <ul><li>缺点：文件名冲突（不同用户不能用相同文件名）、目录庞大时查找慢；</li><li>适用场景：单用户小型系统（如早期 DOS）。</li></ul></li></ul><ol start="2"><li><p><strong>二级目录结构</strong>：</p><ul><li>定义：分为 “主目录（MFD）” 和 “用户目录（UFD）”：主目录记录每个用户的用户目录地址，用户目录记录该用户的所有文件 FCB。</li><li>优点：解决文件名冲突（不同用户可重名）、查找效率高于单级目录；</li><li>缺点：不支持文件共享、用户无法创建子目录；</li><li>适用场景：多用户小型系统。</li></ul></li><li><p><strong>多级目录结构（树形目录结构）</strong>：</p><ul><li><p>定义：目录呈树形，根目录为顶层，每个目录下可包含文件和子目录（如 Windows 的 “文件夹” 结构）。</p></li><li><p>关键概念：</p><ul><li>绝对路径：从根目录开始的路径（如 C:\\Users\\Document\\test.txt）；</li><li>相对路径：从当前工作目录开始的路径（如当前在 C:\\Users，相对路径为 Document\\test.txt）；</li></ul></li><li><p>优点：</p><ul><li>文件名冲突彻底解决（不同目录下可重名）；</li><li>支持文件分类管理（子目录分组）；</li><li>支持文件共享（通过链接实现）；</li></ul></li><li><p>缺点：目录深度过深时，查找路径长；</p></li><li><p>适用场景：现代操作系统（Windows、Linux、Unix）。</p></li></ul></li></ol><h4 id="_3-文件检索过程-以多级目录为例" tabindex="-1"><a class="header-anchor" href="#_3-文件检索过程-以多级目录为例"><span>（3）文件检索过程（以多级目录为例）</span></a></h4><ul><li><p>示例：查找绝对路径 “/home/user/test.txt”（Linux 系统）：</p><ol><li>从根目录 “/” 开始，查找目录项 “home”，获取其物理地址；</li><li>访问 “home” 目录文件，查找目录项 “user”，获取其物理地址；</li><li>访问 “user” 目录文件，查找目录项 “test.txt”，获取其 FCB；</li><li>从 FCB 中读取文件的物理地址，完成检索。</li></ol></li></ul><h3 id="_10-文件控制块-fcb-和目录文件" tabindex="-1"><a class="header-anchor" href="#_10-文件控制块-fcb-和目录文件"><span>10. 文件控制块（FCB）和目录文件</span></a></h3><h4 id="_1-文件控制块-fcb" tabindex="-1"><a class="header-anchor" href="#_1-文件控制块-fcb"><span>（1）文件控制块（FCB）</span></a></h4><ul><li><p>定义：FCB 是文件的 “身份证”，记录文件的所有属性信息，是 OS 管理文件的核心数据结构。</p></li><li><p>核心内容</p><ol><li>基本信息：文件名、文件类型、文件大小、创建时间、修改时间、访问时间；</li></ol></li></ul><ol start="2"><li>存储信息：文件的物理结构（顺序 / 链接 / 索引）、物理地址（起始块号、索引块地址）、总块数；</li><li>访问控制信息：文件所有者、所属组、其他用户的访问权限（读 r、写 w、执行 x）；</li><li>管理信息：文件的打开次数、当前状态（打开 / 关闭）、链接数。</li></ol><ul><li>特点：每个文件对应唯一的 FCB，目录文件的内容就是多个 FCB 的集合。</li></ul><h4 id="_2-目录文件" tabindex="-1"><a class="header-anchor" href="#_2-目录文件"><span>（2）目录文件</span></a></h4><ul><li>定义：专门用于存储目录信息的文件，本质是 “FCB 的集合”（普通文件存储数据，目录文件存储 FCB）。</li><li>结构：与普通文件类似，可采用顺序、链接或索引物理结构；</li><li>作用：实现文件的按名存取，OS 通过目录文件查找文件的 FCB，再通过 FCB 找到文件数据。</li></ul><h3 id="_11-文件保护-存取控制表和用户权限表-特别重点" tabindex="-1"><a class="header-anchor" href="#_11-文件保护-存取控制表和用户权限表-特别重点"><span>11. 文件保护：存取控制表和用户权限表（特别重点）</span></a></h3><ul><li>核心目标：防止文件被未授权用户访问（如读取、修改、删除），保证文件的安全性和保密性。</li><li><strong>两种核心实现方式</strong>：</li></ul><h4 id="_1-存取控制表-access-control-list-acl" tabindex="-1"><a class="header-anchor" href="#_1-存取控制表-access-control-list-acl"><span>（1）存取控制表（Access Control List, ACL）</span></a></h4><ul><li><p>原理：为每个文件建立一张 “存取控制表”，表中记录 “用户 / 用户组” 与 “对应的访问权限” 的映射关系。</p></li><li><p>表项结构：用户 ID（或组 ID） + 权限（r - 读、w - 写、x - 执行）；</p></li><li><p>示例：文件 test.txt 的 ACL 表：</p><table><thead><tr><th style="text-align:center;">用户 / 组</th><th style="text-align:center;">权限</th></tr></thead><tbody><tr><td style="text-align:center;">所有者（user1）</td><td style="text-align:center;">rwx</td></tr><tr><td style="text-align:center;">所属组（group1）</td><td style="text-align:center;">r-x</td></tr><tr><td style="text-align:center;">其他用户</td><td style="text-align:center;">r--</td></tr></tbody></table></li><li><p>访问验证过程：</p><ol><li>用户访问文件时，OS 查找该文件的 ACL 表；</li><li>按 “所有者→所属组→其他用户” 的顺序匹配用户身份；</li><li>若找到匹配项，检查用户请求的操作（如写）是否在权限范围内；</li><li>允许合法操作，拒绝非法操作。</li></ol></li><li><p>优点：细粒度控制（可针对单个用户设置权限）；</p></li><li><p>缺点：ACL 表占用磁盘空间（文件越多、用户越多，表越大）；</p></li><li><p>适用场景：对权限控制要求高的系统（如 Linux、Unix、Windows Server）。</p></li></ul><h4 id="_2-用户权限表-capability-list" tabindex="-1"><a class="header-anchor" href="#_2-用户权限表-capability-list"><span>（2）用户权限表（Capability List）</span></a></h4><ul><li><p>原理：为每个用户建立一张 “用户权限表”，表中记录该用户可访问的所有文件及对应的权限，文件本身不存储权限信息。</p></li><li><p>表项结构：文件标识（文件名 / 文件 ID） + 权限（rwx）；</p></li><li><p>示例：用户 user1 的权限表：</p><table><thead><tr><th style="text-align:center;">文件标识</th><th style="text-align:center;">权限</th></tr></thead><tbody><tr><td style="text-align:center;">/home/user1/test.txt</td><td style="text-align:center;">rwx</td></tr><tr><td style="text-align:center;">/home/group1/share.txt</td><td style="text-align:center;">r-x</td></tr><tr><td style="text-align:center;">/etc/passwd</td><td style="text-align:center;">r--</td></tr></tbody></table></li><li><p>访问验证过程：</p><ol><li>用户访问文件时，OS 查找该用户的权限表；</li><li>检查表中是否存在该文件的条目，且请求的操作在权限范围内；</li><li>允许合法操作，拒绝非法操作。</li></ol></li><li><p>优点：权限管理集中（仅维护用户权限表），文件本身无需存储权限；</p></li><li><p>缺点：用户权限表庞大（用户可访问的文件越多，表越大），不支持临时授权；</p></li><li><p>适用场景：用户数量少、文件访问关系固定的系统。</p></li></ul><h3 id="_12-打开文件-系统打开文件表、用户打开文件表、文件描述字-fd-特别重点" tabindex="-1"><a class="header-anchor" href="#_12-打开文件-系统打开文件表、用户打开文件表、文件描述字-fd-特别重点"><span>12. 打开文件：系统打开文件表、用户打开文件表、文件描述字 fd（特别重点）</span></a></h3><ul><li><strong>背景</strong>：每次访问文件时，若直接从磁盘读取 FCB（目录检索），会产生频繁磁盘 I/O，效率低。“打开文件” 机制将 FCB 的核心信息加载到内存，后续访问直接操作内存中的信息，提高效率。</li></ul><h4 id="_1-三个核心数据结构" tabindex="-1"><a class="header-anchor" href="#_1-三个核心数据结构"><span>（1）三个核心数据结构</span></a></h4><ol><li><p><strong>文件控制块（FCB）</strong>：存储在磁盘目录文件中，记录文件的完整属性（见 10.1）；</p></li><li><p>系统打开文件表（System Open File Table）</p><ul><li><p>定义：OS 维护的全局表，记录所有当前被打开的文件的核心信息（从 FCB 复制而来）；</p></li><li><p>核心内容：</p><ul><li>文件的物理地址、物理结构、当前读写指针（记录下次读写的位置）；</li></ul></li></ul></li></ol><ul><li>文件的打开次数（引用计数，多个进程可同时打开同一个文件）； <ul><li>文件的访问权限、共享模式；</li></ul></li></ul><ol start="3"><li><p>用户打开文件表（User Open File Table）</p><ul><li><p>定义：每个进程维护一张私有表，记录该进程打开的所有文件的信息；</p></li><li><p>核心内容：</p><ul><li>系统打开文件表的入口指针（指向该文件在系统表中的表项）；</li><li>该进程对文件的访问权限（可能是系统表中权限的子集）；</li><li>文件描述符（fd，File Descriptor）：进程访问文件的 “索引”（如 0 = 标准输入、1 = 标准输出、2 = 标准错误）。</li></ul></li></ul></li></ol><h4 id="_2-文件描述符-fd" tabindex="-1"><a class="header-anchor" href="#_2-文件描述符-fd"><span>（2）文件描述符（fd）</span></a></h4><ul><li>定义：非负整数，是用户打开文件表的索引（如 fd=3 对应用户表中第 3 项），进程通过 fd 访问文件（无需记住文件名或物理地址）；</li><li>分配规则：进程打开文件时，OS 为其分配最小的未使用的 fd；</li><li>示例：Linux 进程默认 fd 分配：0（stdin）、1（stdout）、2（stderr），首次打开文件分配 fd=3，再次打开分配 fd=4。</li></ul><h4 id="_3-打开文件的过程" tabindex="-1"><a class="header-anchor" href="#_3-打开文件的过程"><span>（3）打开文件的过程</span></a></h4><ol><li>进程调用<code>open()</code>系统调用，传入文件名和打开模式（读 / 写 / 追加）；</li><li>OS 执行目录检索（从磁盘读取目录文件，查找文件名对应的 FCB）；</li><li>检查用户对该文件的访问权限（是否允许打开模式）；</li><li>若权限通过，OS 在系统打开文件表中创建一个新表项，复制 FCB 的核心信息，初始化引用计数 = 1、当前读写指针 = 0；</li><li>进程的用户打开文件表中创建一个新表项，指向系统打开文件表的该表项，分配一个未使用的 fd；</li><li><code>open()</code>系统调用返回 fd 给进程，后续进程通过 fd 调用<code>read()</code>、<code>write()</code>等系统调用访问文件。</li></ol><h4 id="_4-关闭文件的过程" tabindex="-1"><a class="header-anchor" href="#_4-关闭文件的过程"><span>（4）关闭文件的过程</span></a></h4><ol><li>进程调用<code>close(fd)</code>系统调用；</li><li>OS 通过 fd 找到该进程用户打开文件表中的表项，获取系统打开文件表的入口指针；</li><li>系统打开文件表中该文件的引用计数减 1；</li><li>若引用计数 = 0（无进程打开该文件），删除系统打开文件表中的表项；</li><li>删除用户打开文件表中的对应表项，释放 fd；</li><li><code>close()</code>系统调用返回成功。</li></ol><h4 id="_5-多个进程共享打开文件的场景" tabindex="-1"><a class="header-anchor" href="#_5-多个进程共享打开文件的场景"><span>（5）多个进程共享打开文件的场景</span></a></h4><ul><li><p>若进程 A 和进程 B 同时打开同一个文件：</p><ol><li>进程 A 打开文件：系统打开文件表创建表项，引用计数 = 1，进程 A 的用户表项指向该表项，fd=3；</li><li>进程 B 打开同一文件：系统打开文件表的引用计数 = 2，进程 B 的用户表项指向同一个系统表项，fd=3（进程 B 的 fd 分配）；</li><li>进程 A 关闭文件：引用计数 = 1，系统表项不删除；</li><li>进程 B 关闭文件：引用计数 = 0，删除系统表项。</li></ol></li><li><p>特点：多个进程共享同一个文件的当前读写指针（若打开模式为 “共享写”），或各自维护读写指针（若打开模式为 “独立写”），由系统打开文件表控制。</p></li></ul><h3 id="教材重点补充-必须掌握-1" tabindex="-1"><a class="header-anchor" href="#教材重点补充-必须掌握-1"><span>教材重点补充（必须掌握）</span></a></h3><h4 id="_1-5-4-3-磁盘臂调度算法" tabindex="-1"><a class="header-anchor" href="#_1-5-4-3-磁盘臂调度算法"><span>（1）5.4.3 磁盘臂调度算法</span></a></h4><ul><li>核心结论：实际操作系统中，优先采用 LOOK 或 C-LOOK 算法（平衡寻道效率和请求公平性）；</li><li>补充：磁盘 I/O 的总时间 = 寻道时间（主要）+ 旋转延迟时间（磁头等待目标扇区旋转到下方）+ 传输时间（数据读写时间），调度算法仅优化寻道时间。</li></ul><h4 id="_2-4-4-4-改善文件系统性能的三种方法" tabindex="-1"><a class="header-anchor" href="#_2-4-4-4-改善文件系统性能的三种方法"><span>（2）4.4.4 改善文件系统性能的三种方法</span></a></h4><ol><li><p><strong>文件缓存（Buffer Cache）</strong>：</p><ul><li>原理：在内存中开辟一块缓存区，存放最近访问的文件数据块；</li><li>优化逻辑：利用局部性原理，下次访问同一数据时，直接从内存缓存读取，避免磁盘 I/O；</li><li>实现：OS 维护缓存目录（记录缓存的数据块对应的文件和块号），采用 LRU 等算法替换缓存。</li></ul></li><li><p><strong>磁盘碎片整理</strong>：</p><ul><li>原理：针对顺序结构文件，将分散的文件数据块整理为连续块，减少寻道时间；</li><li>适用场景：机械硬盘（HDD），固态硬盘（SSD）无需碎片整理（无寻道时间问题）；</li><li>注意：碎片整理会占用磁盘 I/O，需在系统空闲时执行。</li></ul></li><li><p><strong>合理的文件物理结构选择</strong>：</p><ul><li>小型静态文件：采用顺序结构（访问快）；</li><li>大型顺序访问文件：采用链接结构（无外部碎片）；</li><li>需随机访问的文件：采用索引结构（随机访问快）；</li><li>超大文件：采用多级索引结构（如 Unix）。</li></ul></li></ol>`,205)])])}const d=i(a,[["render",s]]),h=JSON.parse('{"path":"/posts/classlearning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E9%9A%BE%E7%82%B9.html","title":"操作系统期末重难点知识点详解","lang":"zh-CN","frontmatter":{"date":"2025-01-04T00:00:00.000Z","category":["期末复习"],"tag":["操作系统"]},"headers":[{"level":2,"title":"第一章 引论","slug":"第一章-引论","link":"#第一章-引论","children":[{"level":3,"title":"1. 操作系统定义","slug":"_1-操作系统定义","link":"#_1-操作系统定义","children":[]},{"level":3,"title":"2. 操作系统在计算机系统中的位置和作用","slug":"_2-操作系统在计算机系统中的位置和作用","link":"#_2-操作系统在计算机系统中的位置和作用","children":[]},{"level":3,"title":"3. 关键概念区分","slug":"_3-关键概念区分","link":"#_3-关键概念区分","children":[]},{"level":3,"title":"4. 基本操作系统类型及其特点","slug":"_4-基本操作系统类型及其特点","link":"#_4-基本操作系统类型及其特点","children":[]},{"level":3,"title":"5. 网络操作系统与分布式操作系统的特点和联系","slug":"_5-网络操作系统与分布式操作系统的特点和联系","link":"#_5-网络操作系统与分布式操作系统的特点和联系","children":[]},{"level":3,"title":"6. 操作系统的特征（四大核心）","slug":"_6-操作系统的特征-四大核心","link":"#_6-操作系统的特征-四大核心","children":[]},{"level":3,"title":"7. 操作系统的功能（五大核心）","slug":"_7-操作系统的功能-五大核心","link":"#_7-操作系统的功能-五大核心","children":[]},{"level":3,"title":"8. 操作系统的设计结构及其特点（教材 P36 1.7.1-1.7.4）","slug":"_8-操作系统的设计结构及其特点-教材-p36-1-7-1-1-7-4","link":"#_8-操作系统的设计结构及其特点-教材-p36-1-7-1-1-7-4","children":[]},{"level":3,"title":"9. 操作系统的运行模式：内核态与用户态（特别重点）","slug":"_9-操作系统的运行模式-内核态与用户态-特别重点","link":"#_9-操作系统的运行模式-内核态与用户态-特别重点","children":[]},{"level":3,"title":"教材重点补充（P16-P17 IO 设备 + P29 系统调用）","slug":"教材重点补充-p16-p17-io-设备-p29-系统调用","link":"#教材重点补充-p16-p17-io-设备-p29-系统调用","children":[]}]},{"level":2,"title":"第二章 进程（处理机管理）—— 期末核心重点章节","slug":"第二章-进程-处理机管理-——-期末核心重点章节","link":"#第二章-进程-处理机管理-——-期末核心重点章节","children":[{"level":3,"title":"1. 进程的定义","slug":"_1-进程的定义","link":"#_1-进程的定义","children":[]},{"level":3,"title":"2. 进程的特征（五大核心）","slug":"_2-进程的特征-五大核心","link":"#_2-进程的特征-五大核心","children":[]},{"level":3,"title":"3. 进程与程序的区别和联系","slug":"_3-进程与程序的区别和联系","link":"#_3-进程与程序的区别和联系","children":[]},{"level":3,"title":"4. 进程实体的组成","slug":"_4-进程实体的组成","link":"#_4-进程实体的组成","children":[]},{"level":3,"title":"5. PCB 的作用和特点","slug":"_5-pcb-的作用和特点","link":"#_5-pcb-的作用和特点","children":[]},{"level":3,"title":"6. 进程的状态及其变迁（并能说出原因）","slug":"_6-进程的状态及其变迁-并能说出原因","link":"#_6-进程的状态及其变迁-并能说出原因","children":[]},{"level":3,"title":"7. 处理机的执行状态（核心态、用户态）","slug":"_7-处理机的执行状态-核心态、用户态","link":"#_7-处理机的执行状态-核心态、用户态","children":[]},{"level":3,"title":"8. 内核的定义及功能；原语的定义及功能","slug":"_8-内核的定义及功能-原语的定义及功能","link":"#_8-内核的定义及功能-原语的定义及功能","children":[]},{"level":3,"title":"9. 进程控制方式","slug":"_9-进程控制方式","link":"#_9-进程控制方式","children":[]},{"level":3,"title":"10. 进程同步与互斥的定义","slug":"_10-进程同步与互斥的定义","link":"#_10-进程同步与互斥的定义","children":[]},{"level":3,"title":"11. 临界资源与临界区的定义","slug":"_11-临界资源与临界区的定义","link":"#_11-临界资源与临界区的定义","children":[]},{"level":3,"title":"12. 好的互斥方案应遵循的条件（四大原则） 也称进程同步四大原则","slug":"_12-好的互斥方案应遵循的条件-四大原则-也称进程同步四大原则","link":"#_12-好的互斥方案应遵循的条件-四大原则-也称进程同步四大原则","children":[]},{"level":3,"title":"13. 信号量机制 P（down）V (up) 操作的原理（特别重点）","slug":"_13-信号量机制-p-down-v-up-操作的原理-特别重点","link":"#_13-信号量机制-p-down-v-up-操作的原理-特别重点","children":[]},{"level":3,"title":"14. PV 操作解决互斥问题（特别重点）","slug":"_14-pv-操作解决互斥问题-特别重点","link":"#_14-pv-操作解决互斥问题-特别重点","children":[]},{"level":3,"title":"15. PV 操作解决生产者与消费者问题（特别重点）","slug":"_15-pv-操作解决生产者与消费者问题-特别重点","link":"#_15-pv-操作解决生产者与消费者问题-特别重点","children":[]},{"level":3,"title":"16. 进程通信的类型及其过程和特点","slug":"_16-进程通信的类型及其过程和特点","link":"#_16-进程通信的类型及其过程和特点","children":[]},{"level":3,"title":"17. 进程调度的概念、方式、原因、过程","slug":"_17-进程调度的概念、方式、原因、过程","link":"#_17-进程调度的概念、方式、原因、过程","children":[]},{"level":3,"title":"18. 进程调度的算法（特别重点）","slug":"_18-进程调度的算法-特别重点","link":"#_18-进程调度的算法-特别重点","children":[]},{"level":3,"title":"19. 高级调度（作业调度）的算法（特别重点）","slug":"_19-高级调度-作业调度-的算法-特别重点","link":"#_19-高级调度-作业调度-的算法-特别重点","children":[]},{"level":3,"title":"20. 线程的定义和作用；线程与进程的联系与区别、线程的类型（特别重点）","slug":"_20-线程的定义和作用-线程与进程的联系与区别、线程的类型-特别重点","link":"#_20-线程的定义和作用-线程与进程的联系与区别、线程的类型-特别重点","children":[]},{"level":3,"title":"21. 死锁的定义","slug":"_21-死锁的定义","link":"#_21-死锁的定义","children":[]},{"level":3,"title":"22. 死锁发生的条件（四大必要条件，特别重点）","slug":"_22-死锁发生的条件-四大必要条件-特别重点","link":"#_22-死锁发生的条件-四大必要条件-特别重点","children":[]},{"level":3,"title":"23. 处理死锁的常见方法（特别重点）","slug":"_23-处理死锁的常见方法-特别重点","link":"#_23-处理死锁的常见方法-特别重点","children":[]},{"level":3,"title":"24.死锁 具体解决方法详解","slug":"_24-死锁-具体解决方法详解","link":"#_24-死锁-具体解决方法详解","children":[]},{"level":3,"title":"25. 操作系统接口","slug":"_25-操作系统接口","link":"#_25-操作系统接口","children":[]},{"level":3,"title":"教材重点补充","slug":"教材重点补充","link":"#教材重点补充","children":[]}]},{"level":2,"title":"第三章 存储管理","slug":"第三章-存储管理","link":"#第三章-存储管理","children":[{"level":3,"title":"1. 存储管理的功能（六大核心）","slug":"_1-存储管理的功能-六大核心","link":"#_1-存储管理的功能-六大核心","children":[]},{"level":3,"title":"2. 存储空间和地址重定位（地址映射）","slug":"_2-存储空间和地址重定位-地址映射","link":"#_2-存储空间和地址重定位-地址映射","children":[]},{"level":3,"title":"3. 分区存储管理：固定、动态、动态重定位","slug":"_3-分区存储管理-固定、动态、动态重定位","link":"#_3-分区存储管理-固定、动态、动态重定位","children":[]},{"level":3,"title":"4. 动态分区分配算法","slug":"_4-动态分区分配算法","link":"#_4-动态分区分配算法","children":[]},{"level":3,"title":"5. 虚拟存储的概念（特别重点）","slug":"_5-虚拟存储的概念-特别重点","link":"#_5-虚拟存储的概念-特别重点","children":[]},{"level":3,"title":"6. 覆盖和对换技术的原理、特点","slug":"_6-覆盖和对换技术的原理、特点","link":"#_6-覆盖和对换技术的原理、特点","children":[]},{"level":3,"title":"7. 页式存储分配主要是解决什么问题（按物理大小划分且无外部碎片）","slug":"_7-页式存储分配主要是解决什么问题-按物理大小划分且无外部碎片","link":"#_7-页式存储分配主要是解决什么问题-按物理大小划分且无外部碎片","children":[]},{"level":3,"title":"8. 分页原理；逻辑地址到页号和页内偏移量的转换方法","slug":"_8-分页原理-逻辑地址到页号和页内偏移量的转换方法","link":"#_8-分页原理-逻辑地址到页号和页内偏移量的转换方法","children":[]},{"level":3,"title":"9. 页式存储的地址映射过程","slug":"_9-页式存储的地址映射过程","link":"#_9-页式存储的地址映射过程","children":[]},{"level":3,"title":"10. 二级页表的一级、二级页号和页内偏移量的计算","slug":"_10-二级页表的一级、二级页号和页内偏移量的计算","link":"#_10-二级页表的一级、二级页号和页内偏移量的计算","children":[]},{"level":3,"title":"11. 请求分页原理；局部性原理；页表结构与缺页中断（特别重点）","slug":"_11-请求分页原理-局部性原理-页表结构与缺页中断-特别重点","link":"#_11-请求分页原理-局部性原理-页表结构与缺页中断-特别重点","children":[]},{"level":3,"title":"12. 请求分页的地址变换","slug":"_12-请求分页的地址变换","link":"#_12-请求分页的地址变换","children":[]},{"level":3,"title":"13. 页面置换算法（页面置换算法，教材 P119）","slug":"_13-页面置换算法-页面置换算法-教材-p119","link":"#_13-页面置换算法-页面置换算法-教材-p119","children":[]},{"level":3,"title":"14. 分配置换策略；抖动定义","slug":"_14-分配置换策略-抖动定义","link":"#_14-分配置换策略-抖动定义","children":[]},{"level":3,"title":"15. 分段存储管理的目的（按逻辑来但有外部碎片）","slug":"_15-分段存储管理的目的-按逻辑来但有外部碎片","link":"#_15-分段存储管理的目的-按逻辑来但有外部碎片","children":[]},{"level":3,"title":"16. 分段存储的地址结构","slug":"_16-分段存储的地址结构","link":"#_16-分段存储的地址结构","children":[]},{"level":3,"title":"17. 分段存储的地址变换过程","slug":"_17-分段存储的地址变换过程","link":"#_17-分段存储的地址变换过程","children":[]},{"level":3,"title":"18. 段页式存储管理原理和地址变换过程","slug":"_18-段页式存储管理原理和地址变换过程","link":"#_18-段页式存储管理原理和地址变换过程","children":[]},{"level":3,"title":"19. 请求段页式存储管理原理","slug":"_19-请求段页式存储管理原理","link":"#_19-请求段页式存储管理原理","children":[]}]},{"level":2,"title":"第四章 设备管理（输入输出）","slug":"第四章-设备管理-输入输出","link":"#第四章-设备管理-输入输出","children":[{"level":3,"title":"1. 字符设备与块设备的分类","slug":"_1-字符设备与块设备的分类","link":"#_1-字符设备与块设备的分类","children":[]},{"level":3,"title":"2. 资源共享分类：独占设备、共享设备、虚拟设备","slug":"_2-资源共享分类-独占设备、共享设备、虚拟设备","link":"#_2-资源共享分类-独占设备、共享设备、虚拟设备","children":[]},{"level":3,"title":"3. I/O设备的控制传输方式","slug":"_3-i-o设备的控制传输方式","link":"#_3-i-o设备的控制传输方式","children":[]},{"level":3,"title":"4. DMA 的工作原理和通道的工作原理（特别重点）","slug":"_4-dma-的工作原理和通道的工作原理-特别重点","link":"#_4-dma-的工作原理和通道的工作原理-特别重点","children":[]},{"level":3,"title":"5. 缓冲技术（特别重点）","slug":"_5-缓冲技术-特别重点","link":"#_5-缓冲技术-特别重点","children":[]},{"level":3,"title":"6. 设备分配的原则、策略、过程和使用的数据结构","slug":"_6-设备分配的原则、策略、过程和使用的数据结构","link":"#_6-设备分配的原则、策略、过程和使用的数据结构","children":[]},{"level":3,"title":"7. 设备的虚拟性与独立性的原理和实现（特别重点）","slug":"_7-设备的虚拟性与独立性的原理和实现-特别重点","link":"#_7-设备的虚拟性与独立性的原理和实现-特别重点","children":[]},{"level":3,"title":"8. SPOOLING 技术（特别重点）","slug":"_8-spooling-技术-特别重点","link":"#_8-spooling-技术-特别重点","children":[]},{"level":3,"title":"9. 设备驱动程序的功能、特点和工作过程（特别重点）","slug":"_9-设备驱动程序的功能、特点和工作过程-特别重点","link":"#_9-设备驱动程序的功能、特点和工作过程-特别重点","children":[]},{"level":3,"title":"教材重点补充（必须掌握）","slug":"教材重点补充-必须掌握","link":"#教材重点补充-必须掌握","children":[]}]},{"level":2,"title":"第五章 文件系统","slug":"第五章-文件系统","link":"#第五章-文件系统","children":[{"level":3,"title":"1. 文件的定义","slug":"_1-文件的定义","link":"#_1-文件的定义","children":[]},{"level":3,"title":"2. 文件类型","slug":"_2-文件类型","link":"#_2-文件类型","children":[]},{"level":3,"title":"3. 文件系统的功能（六大核心）","slug":"_3-文件系统的功能-六大核心","link":"#_3-文件系统的功能-六大核心","children":[]},{"level":3,"title":"4. 文件系统的结构（层次结构，从底层到上层）","slug":"_4-文件系统的结构-层次结构-从底层到上层","link":"#_4-文件系统的结构-层次结构-从底层到上层","children":[]},{"level":3,"title":"5. 文件的逻辑结构和物理结构（特别重点）","slug":"_5-文件的逻辑结构和物理结构-特别重点","link":"#_5-文件的逻辑结构和物理结构-特别重点","children":[]},{"level":3,"title":"6. Unix 的多级索引结构（特别重点）","slug":"_6-unix-的多级索引结构-特别重点","link":"#_6-unix-的多级索引结构-特别重点","children":[]},{"level":3,"title":"7. 文件存储空间的管理（空闲块管理，特别重点）","slug":"_7-文件存储空间的管理-空闲块管理-特别重点","link":"#_7-文件存储空间的管理-空闲块管理-特别重点","children":[]},{"level":3,"title":"8. 磁盘 I/O 调度算法（特别重点，教材 5.4.3）","slug":"_8-磁盘-i-o-调度算法-特别重点-教材-5-4-3","link":"#_8-磁盘-i-o-调度算法-特别重点-教材-5-4-3","children":[]},{"level":3,"title":"9. 文件目录和检索","slug":"_9-文件目录和检索","link":"#_9-文件目录和检索","children":[]},{"level":3,"title":"10. 文件控制块（FCB）和目录文件","slug":"_10-文件控制块-fcb-和目录文件","link":"#_10-文件控制块-fcb-和目录文件","children":[]},{"level":3,"title":"11. 文件保护：存取控制表和用户权限表（特别重点）","slug":"_11-文件保护-存取控制表和用户权限表-特别重点","link":"#_11-文件保护-存取控制表和用户权限表-特别重点","children":[]},{"level":3,"title":"12. 打开文件：系统打开文件表、用户打开文件表、文件描述字 fd（特别重点）","slug":"_12-打开文件-系统打开文件表、用户打开文件表、文件描述字-fd-特别重点","link":"#_12-打开文件-系统打开文件表、用户打开文件表、文件描述字-fd-特别重点","children":[]},{"level":3,"title":"教材重点补充（必须掌握）","slug":"教材重点补充-必须掌握-1","link":"#教材重点补充-必须掌握-1","children":[]}]}],"git":{"updatedTime":1768621358000,"contributors":[{"name":"ksldnasx","username":"ksldnasx","email":"wh8261408@126.com","commits":3,"url":"https://github.com/ksldnasx"}],"changelog":[{"hash":"1f864259e832e26b375fa180e4e2da1fa0f7da94","time":1768621358000,"email":"wh8261408@126.com","author":"ksldnasx","message":"fix"},{"hash":"5cf1f85300a734535f9a3af2a60b7420f39a47cf","time":1767608274000,"email":"wh8261408@126.com","author":"ksldnasx","message":"feat:sdn题目"},{"hash":"45631f3e07c87d7a13e6aaae3afde88f19810e12","time":1767540983000,"email":"wh8261408@126.com","author":"ksldnasx","message":"feat:操作系统AI总结"}]},"filePathRelative":"posts/classlearning/操作系统重难点.md","excerpt":"\\n<h2>第一章 引论</h2>\\n<h3>1. 操作系统定义</h3>\\n<ul>\\n<li>\\n<p><strong>定义</strong>：操作系统是计算机系统中的核心软件，负责协调管理计算机系统硬件与软件资源，并为用户和应用程序提供高效的交互环境。</p>\\n</li>\\n<li>\\n<p>特征：</p>\\n<ul>\\n<li>\\n<p>并发性</p>\\n</li>\\n<li>\\n<p>异步性</p>\\n</li>\\n<li>\\n<p>共享性</p>\\n</li>\\n<li>\\n<p>异步性</p>\\n</li>\\n</ul>\\n</li>\\n</ul>\\n<h3>2. 操作系统在计算机系统中的位置和作用</h3>\\n<ul>\\n<li>\\n<p><strong>位置</strong>：位于计算机硬件之上，应用软件之下，是一层 “中间件”。</p>\\n</li>\\n<li>\\n<p>核心作用</p>\\n<ol>\\n<li>资源管理：统一管理 CPU、内存、设备、文件等软硬件资源，避免冲突。</li>\\n<li>提供接口：给用户（命令接口、图形接口）和应用程序（系统调用接口）提供便捷操作方式。</li>\\n<li>优化系统性能：通过调度算法、资源分配策略提升系统吞吐量、响应速度。</li>\\n<li>屏蔽硬件差异：使应用程序无需关注具体硬件型号，实现 “硬件无关性”。</li>\\n</ol>\\n</li>\\n</ul>"}');export{d as comp,h as data};
