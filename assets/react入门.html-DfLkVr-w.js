import{_ as n,c as a,a as e,o as t}from"./app-UmXydJji.js";const p={};function c(o,s){return t(),a("div",null,[...s[0]||(s[0]=[e(`<h1 id="react基础入门" tabindex="-1"><a class="header-anchor" href="#react基础入门"><span>React基础入门</span></a></h1><h2 id="基础入门" tabindex="-1"><a class="header-anchor" href="#基础入门"><span>基础入门</span></a></h2><h3 id="一、核心认知-react-是什么-类比-vue" tabindex="-1"><a class="header-anchor" href="#一、核心认知-react-是什么-类比-vue"><span>一、核心认知：React 是什么？（类比 Vue）</span></a></h3><p>Vue3 是「渐进式框架」，有完整的模板、指令、响应式体系；React 是「UI 库」（核心只管视图渲染），更像「函数式的视图生成器」，核心思想：<strong>用函数描述 UI，数据变了函数重新执行，UI 就更新</strong>。</p><h3 id="关键类比-vue3-→-react" tabindex="-1"><a class="header-anchor" href="#关键类比-vue3-→-react"><span>关键类比（Vue3 → React）</span></a></h3><table><thead><tr><th>Vue3 概念</th><th>React 对应概念</th><th>核心差异</th></tr></thead><tbody><tr><td>单文件组件.vue</td><td>组件文件.tsx/.jsx</td><td>React 用 JSX 写模板（HTML 嵌 JS）</td></tr><tr><td>setup () 语法糖</td><td>函数组件</td><td>React 组件本质是返回 JSX 的函数</td></tr><tr><td>ref/reactive</td><td>useState/useReducer</td><td>React 响应式是「显式更新」</td></tr><tr><td>watch/watchEffect</td><td>useEffect/useLayoutEffect</td><td>副作用监听需手动指定依赖</td></tr><tr><td>Props 传值</td><td>Props 传值</td><td>逻辑一致，TS 类型声明方式不同</td></tr><tr><td>插槽 Slot</td><td>组件传子元素 / Props</td><td>React 无插槽，用「传元素」替代</td></tr></tbody></table><h3 id="二、极速上手-从「写一个按钮」开始" tabindex="-1"><a class="header-anchor" href="#二、极速上手-从「写一个按钮」开始"><span>二、极速上手：从「写一个按钮」开始</span></a></h3><h4 id="_1-环境准备-类比-vue-cli-vite" tabindex="-1"><a class="header-anchor" href="#_1-环境准备-类比-vue-cli-vite"><span>1. 环境准备（类比 Vue CLI/Vite）</span></a></h4><p>React 常用构建工具：</p><ul><li>Vite：<code>npm create vite@latest my-react -- --template react-ts</code>（和 Vue3 用 Vite 几乎一样）</li><li>启动：<code>cd my-react &amp;&amp; npm i &amp;&amp; npm run dev</code></li></ul><h4 id="_2-第一个组件-tsx-版-类比-vue3-单文件组件" tabindex="-1"><a class="header-anchor" href="#_2-第一个组件-tsx-版-类比-vue3-单文件组件"><span>2. 第一个组件（TSX 版，类比 Vue3 单文件组件）</span></a></h4><p>Vue3 你习惯这么写：</p><div class="language-vue line-numbers-mode" data-highlighter="prismjs" data-ext="vue"><pre><code><span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span></span>
<span class="line">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>count++<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>点击{{ count }}次<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">setup</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>ts<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript"></span>
<span class="line"><span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span>
<span class="line"></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>React 等价写法（TSX）：</p><div class="language-tsx line-numbers-mode" data-highlighter="prismjs" data-ext="tsx"><pre><code><span class="line"><span class="token comment">// src/Button.tsx</span></span>
<span class="line"><span class="token keyword">import</span> <span class="token punctuation">{</span> useState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;react&#39;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 函数组件 = Vue3 setup + template 合体</span></span>
<span class="line"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">MyButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">// useState：类比 ref(0)，返回[值, 修改值的方法]（React 必须用方法更新，不能直接改）</span></span>
<span class="line">  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useState</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">  <span class="token comment">// JSX = Vue 模板，语法更贴近 JS</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token punctuation">(</span></span>
<span class="line">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text"></span>
<span class="line">      点击</span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token plain-text">次</span>
<span class="line">    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span></span>
<span class="line">  <span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="核心形象化理解" tabindex="-1"><a class="header-anchor" href="#核心形象化理解"><span>核心形象化理解：</span></a></h4><ul><li>React 组件 = 「UI 工厂函数」：输入 Props / 状态，输出 JSX（UI）；</li><li>useState = 「状态盒子」：盒子里装着 count，只有用 setCount 才能打开盒子改值（Vue 的 ref 是「自动更新的盒子」）；</li><li>onClick = 「事件触发器」：和 Vue 的 @click 一样，只是 React 用驼峰命名（onClick、onChange）。</li></ul><h4 id="_3-组件传值-props-类比-vue-props" tabindex="-1"><a class="header-anchor" href="#_3-组件传值-props-类比-vue-props"><span>3. 组件传值（Props，类比 Vue Props）</span></a></h4><p>Vue3 传值：</p><div class="language-vue line-numbers-mode" data-highlighter="prismjs" data-ext="vue"><pre><code><span class="line"><span class="token comment">&lt;!-- 父组件 --&gt;</span></span>
<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MyButton</span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>测试按钮<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span></span>
<span class="line"></span>
<span class="line"><span class="token comment">&lt;!-- 子组件 --&gt;</span></span>
<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">setup</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>ts<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript"></span>
<span class="line">defineProps<span class="token operator">&lt;</span><span class="token punctuation">{</span> <span class="token literal-property property">title</span><span class="token operator">:</span> string <span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>React 等价写法：</p><div class="language-tsx line-numbers-mode" data-highlighter="prismjs" data-ext="tsx"><pre><code><span class="line"><span class="token comment">// 子组件 Button.tsx</span></span>
<span class="line"><span class="token keyword">interface</span> <span class="token class-name">ButtonProps</span> <span class="token punctuation">{</span></span>
<span class="line">  title<span class="token operator">:</span> <span class="token builtin">string</span></span>
<span class="line">  count<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token comment">// 可选属性，类比 Vue Props 可选</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// Props 作为函数参数传入</span></span>
<span class="line"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">MyButton</span><span class="token punctuation">(</span>props<span class="token operator">:</span> ButtonProps<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token punctuation">(</span></span>
<span class="line">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text"></span>
<span class="line">      </span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>title<span class="token punctuation">}</span><span class="token plain-text">：点击</span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token plain-text">次</span>
<span class="line">    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span></span>
<span class="line">  <span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 父组件 App.tsx</span></span>
<span class="line"><span class="token keyword">import</span> MyButton <span class="token keyword">from</span> <span class="token string">&#39;./Button&#39;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token punctuation">(</span></span>
<span class="line">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text"></span>
<span class="line">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">MyButton</span></span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>测试按钮<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text"></span>
<span class="line">    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span></span>
<span class="line">  <span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="形象化" tabindex="-1"><a class="header-anchor" href="#形象化"><span>形象化：</span></a></h4><p>React Props = 「工厂的原材料」：父组件把 title 传给子组件（工厂），工厂用原材料生产 UI。</p><h4 id="_4-副作用-类比-vue-watch-watcheffect" tabindex="-1"><a class="header-anchor" href="#_4-副作用-类比-vue-watch-watcheffect"><span>4. 副作用（类比 Vue watch/watchEffect）</span></a></h4><p>Vue3 监听 count 变化：</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code><span class="line"><span class="token function">watch</span><span class="token punctuation">(</span>count<span class="token punctuation">,</span> <span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;count变了：&#39;</span><span class="token punctuation">,</span> newVal<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>React 用 useEffect 实现：</p><div class="language-tsx line-numbers-mode" data-highlighter="prismjs" data-ext="tsx"><pre><code><span class="line"><span class="token keyword">import</span> <span class="token punctuation">{</span> useState<span class="token punctuation">,</span> useEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;react&#39;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">MyButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">  <span class="token comment">// useEffect = 「副作用容器」：组件渲染/更新后执行</span></span>
<span class="line">  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;count变了：&#39;</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span></span>
<span class="line">    <span class="token comment">// 依赖数组 = 监听的状态，类比 Vue watch 的第一个参数</span></span>
<span class="line">  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">  <span class="token keyword">return</span> <span class="token punctuation">(</span></span>
<span class="line">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">点击</span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token plain-text">次</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span></span>
<span class="line">  <span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="核心形象化" tabindex="-1"><a class="header-anchor" href="#核心形象化"><span>核心形象化：</span></a></h4><p>useEffect = 「善后处理员」：组件渲染完（UI 画好），处理异步、监听、DOM 操作等「善后工作」；依赖数组 = 「触发开关」：只有数组里的状态变了，才会重新执行 useEffect（空数组 = 只执行一次，类比 Vue 的 watch 立即执行 + 只监听一次）。</p><h3 id="三、react-核心灵魂-jsx-语法-类比-vue-模板" tabindex="-1"><a class="header-anchor" href="#三、react-核心灵魂-jsx-语法-类比-vue-模板"><span>三、React 核心灵魂：JSX 语法（类比 Vue 模板）</span></a></h3><p>JSX 是「JS 的语法扩展」，可以理解为「能写 HTML 的 JS」，核心规则：</p><ol><li>标签必须闭合：<code>&lt;div /&gt;</code>（类比 Vue 自闭合标签）；</li><li>只能有一个根节点：用 <code>&lt;&gt;&lt;/&gt;</code>（空标签，类比 Vue 的 <code>&lt;template&gt;</code> 根节点）包裹；</li><li>插值用 <code>{}</code>：<code>{count}</code>、<code>{props.title}</code>（类比 Vue 的 <code>{{}}</code>）；</li><li>样式用对象：<code>style={{ color: &#39;red&#39;, fontSize: &#39;16px&#39; }}</code>（类比 Vue 的 :style）；</li><li>class 用 className：<code>&lt;div className=&quot;box&quot; /&gt;</code>（因为 class 是 JS 关键字）。</li></ol><p>形象化：</p><p>JSX = 「HTML 和 JS 的混血儿」：既像 HTML 一样写结构，又能直接在里面写 JS 逻辑（比如 <code>{count &gt; 5 &amp;&amp; &lt;span&gt;超过5次&lt;/span&gt;}</code>，类比 Vue 的 <code>v-if</code>）。</p><h3 id="四、vue3-→-react-核心思维转换" tabindex="-1"><a class="header-anchor" href="#四、vue3-→-react-核心思维转换"><span>四、Vue3 → React 核心思维转换</span></a></h3><ol><li>「自动响应式」→「显式更新」：Vue 改 ref/reactive 自动更 UI，React 必须调用 setXxx 触发重渲染；</li><li>「模板分离」→「JSX 融合」：Vue 模板和逻辑分开，React 逻辑和 UI 写在同一个函数里（更贴近「数据驱动 UI」的本质）；</li><li>「指令化」→「函数式」：Vue 用 v-if/v-for 指令，React 用 JS 的 if/for 写逻辑（比如 <code>{list.map(item =&gt; &lt;li key={item.id}&gt;{item.name}&lt;/li&gt;)}</code> 类比 v-for）。</li></ol><h2 id="pick" tabindex="-1"><a class="header-anchor" href="#pick"><span>Pick</span></a></h2><h3 id="一、核心含义" tabindex="-1"><a class="header-anchor" href="#一、核心含义"><span>一、核心含义</span></a></h3><p><code>Pick&lt;SearchCriteria, &quot;page&quot; | &quot;pageSize&quot;&gt;</code> ，这是 TypeScript 内置的<strong>工具类型 <code>Pick</code></strong>，作用是<strong>从一个已有类型中「挑选」指定的属性，生成一个全新的、仅包含这些属性的类型</strong>，是 TS 类型编程中最常用的工具之一（你有 Vue3+TS 基础，理解这个会很轻松）。</p><h4 id="_1-语法拆解" tabindex="-1"><a class="header-anchor" href="#_1-语法拆解"><span>1. 语法拆解</span></a></h4><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code><span class="line">Pick<span class="token operator">&lt;</span>原类型<span class="token punctuation">,</span> 要挑选的属性名 <span class="token operator">|</span> 多个属性用 <span class="token operator">|</span> 分隔<span class="token operator">&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>对应到代码里：</p><ul><li><code>SearchCriteria</code>：原类型（你项目中定义的筛选条件完整类型，包含 <code>page</code>、<code>pageSize</code>、<code>startTime</code>、<code>keyword</code>、<code>minExecutionTime</code> 等所有字段）；</li><li><code>&quot;page&quot; | &quot;pageSize&quot;</code>：要挑选的属性（仅保留分页相关的 <code>page</code> 和 <code>pageSize</code>，排除其他筛选字段）；</li><li>最终 <code>Pick&lt;SearchCriteria, &quot;page&quot; | &quot;pageSize&quot;&gt;</code> 生成的新类型 = <strong>只有 <code>page</code> 和 <code>pageSize</code> 两个属性的类型</strong>，没有 <code>startTime</code>、<code>keyword</code> 等其他字段。</li></ul><h4 id="_2-形象化理解-类比-vue3-ts-场景" tabindex="-1"><a class="header-anchor" href="#_2-形象化理解-类比-vue3-ts-场景"><span>2. 形象化理解（类比 Vue3+TS 场景）</span></a></h4><p>假设你的 <code>SearchCriteria</code> 完整类型是这样的：</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code><span class="line"><span class="token comment">// 完整的筛选条件类型</span></span>
<span class="line"><span class="token keyword">interface</span> <span class="token class-name">SearchCriteria</span> <span class="token punctuation">{</span></span>
<span class="line">  page<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> <span class="token comment">// 页码</span></span>
<span class="line">  pageSize<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> <span class="token comment">// 页大小</span></span>
<span class="line">  keyword<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> <span class="token comment">// 关键词</span></span>
<span class="line">  startTime<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> <span class="token comment">// 开始时间</span></span>
<span class="line">  endTime<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> <span class="token comment">// 结束时间</span></span>
<span class="line">  minExecutionTime<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> <span class="token comment">// 最小执行时间</span></span>
<span class="line">  databaseName<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> <span class="token comment">// 数据库名</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>用 <code>Pick&lt;SearchCriteria, &quot;page&quot; | &quot;pageSize&quot;&gt;</code> 后，生成的新类型等价于：</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code><span class="line"><span class="token comment">// Pick 自动生成的新类型（无需手动写）</span></span>
<span class="line"><span class="token keyword">interface</span> <span class="token class-name">PickedCriteria</span> <span class="token punctuation">{</span></span>
<span class="line">  page<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span></span>
<span class="line">  pageSize<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_3-为什么要用-pick-核心价值" tabindex="-1"><a class="header-anchor" href="#_3-为什么要用-pick-核心价值"><span>3. 为什么要用 <code>Pick</code>（核心价值）</span></a></h4><p>在之前的代码中，<code>getBaseCriteria</code> 函数的目的是「仅返回分页相关的基础字段」，用 <code>Pick</code> 有 3 个关键作用：</p><ul><li><strong>类型安全</strong>：强制函数返回值只能包含 <code>page</code> 和 <code>pageSize</code>，如果不小心返回了 <code>startTime</code> 等字段，TS 会直接报错（避免手写漏检）；</li><li><strong>复用已有类型</strong>：不用重新写一个只有 <code>page</code>/<code>pageSize</code> 的新接口，直接复用 <code>SearchCriteria</code>，后续如果 <code>SearchCriteria</code> 里的 <code>page</code> 类型从 <code>number</code> 改成其他，这里会自动同步，减少维护成本；</li><li><strong>语义清晰</strong>：一眼就能看出「从完整筛选条件中挑选分页字段」，比手动写新接口更易读。</li></ul><h4 id="_4-对比-不用-pick-会怎么样" tabindex="-1"><a class="header-anchor" href="#_4-对比-不用-pick-会怎么样"><span>4. 对比：不用 <code>Pick</code> 会怎么样？</span></a></h4><p>如果不用 <code>Pick</code>，你需要手动写一个新接口：</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code><span class="line"><span class="token comment">// 手动定义基础分页类型（等价于 Pick 的效果，但冗余）</span></span>
<span class="line"><span class="token keyword">interface</span> <span class="token class-name">BaseCriteria</span> <span class="token punctuation">{</span></span>
<span class="line">  page<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span></span>
<span class="line">  pageSize<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">const</span> getBaseCriteria <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> BaseCriteria <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token punctuation">{</span> page<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> pageSize<span class="token operator">:</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种方式可行，但如果 <code>SearchCriteria</code> 中的 <code>page</code>/<code>pageSize</code> 类型修改（比如 <code>pageSize</code> 改成 <code>10 | 20 | 50</code>），你需要同时改 <code>BaseCriteria</code>，而用 <code>Pick</code> 会自动同步，更高效。</p><h3 id="二、代码中-pick-的实际作用" tabindex="-1"><a class="header-anchor" href="#二、代码中-pick-的实际作用"><span>二、代码中 <code>Pick</code> 的实际作用</span></a></h3><p>在 <code>getBaseCriteria</code> 函数中：</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code><span class="line"><span class="token keyword">const</span> getBaseCriteria <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Pick<span class="token operator">&lt;</span>SearchCriteria<span class="token punctuation">,</span> <span class="token string">&quot;page&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;pageSize&quot;</span><span class="token operator">&gt;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token punctuation">{</span></span>
<span class="line">    page<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token comment">// 快捷筛选强制重置到第1页</span></span>
<span class="line">    pageSize<span class="token operator">:</span> localCriteria<span class="token punctuation">.</span>pageSize <span class="token operator">||</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token comment">// 保留用户之前设置的页大小</span></span>
<span class="line">  <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>返回值类型被 <code>Pick</code> 约束，确保函数只能返回 <code>page</code> 和 <code>pageSize</code>，不会混入 <code>startTime</code> 等筛选字段；</li><li>结合后续的 <code>...getBaseCriteria()</code> + <code>...filterCriteria</code>，能精准实现「仅保留分页字段 + 当前快捷筛选条件」，彻底避免旧筛选条件残留。</li></ul><h2 id="usecallback" tabindex="-1"><a class="header-anchor" href="#usecallback"><span>useCallback</span></a></h2><p>在 <code>useCallback</code>中列出依赖项数组，本质上是在告诉 React：“<strong>只有当这个数组里的值发生变化时，才需要重新创建我包裹的这个函数。</strong>” 这是 React 用来优化性能、避免不必要的函数重建和组件重新渲染的核心机制。</p><p>为了快速抓住要点，我们先通过下面这个表格来直观理解不同依赖项设置的作用：</p><table><thead><tr><th style="text-align:left;">依赖项数组配置</th><th style="text-align:left;">函数何时重新创建？</th><th style="text-align:left;">常见使用场景与注意事项</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>空数组 <code>[]</code></strong></td><td style="text-align:left;"><strong>仅在组件首次渲染时创建一次</strong>，之后无论组件如何重新渲染，函数引用始终不变。</td><td style="text-align:left;">适用于不依赖任何组件内部状态或props的函数，例如一个固定的操作提示。需<strong>确保函数内部确实不依赖任何会变化的值</strong>，否则可能引用到旧的 state 或 props（闭包陷阱）。</td></tr><tr><td style="text-align:left;"><strong>包含特定依赖 <code>[dep1, dep2]</code></strong></td><td style="text-align:left;">在<strong>首次渲染时创建</strong>，之后<strong>仅当 <code>dep1</code>或 <code>dep2</code>的值发生变化时</strong>才会重新创建。</td><td style="text-align:left;">这是<strong>最常用和推荐</strong>的方式。用于函数内部使用了某些状态、props或函数的情况。能精准控制函数更新，平衡性能与逻辑正确性。</td></tr><tr><td style="text-align:left;"><strong>省略依赖项（不推荐）</strong></td><td style="text-align:left;"><strong>每次组件渲染时都会重新创建</strong>一个新的函数，等同于没有使用 <code>useCallback</code>。</td><td style="text-align:left;"><strong>基本失去了使用 <code>useCallback</code>的意义</strong>。ESLint 规则通常会对此发出警告，应避免这种写法。</td></tr></tbody></table><h3 id="💡-核心机制-理解闭包与稳定性" tabindex="-1"><a class="header-anchor" href="#💡-核心机制-理解闭包与稳定性"><span>💡 核心机制：理解闭包与稳定性</span></a></h3><p>依赖项列表之所以如此重要，深层原因与 JavaScript 的<strong>闭包</strong>机制有关。</p><ul><li><strong>保证逻辑正确性</strong>：当函数内部引用了组件状态（如 <code>state</code>）、<code>props</code>或其他在函数外部定义的变量时，这个函数会“记住”它被创建时所处的作用域（即形成闭包）。如果你在依赖项数组中遗漏了某个变量，<code>useCallback</code>返回的函数将继续使用该变量最初被“捕获”的值（旧值），从而导致逻辑错误。明确列出所有依赖，就是确保函数总能访问到这些变量的最新值。</li><li><strong>提供稳定性</strong>：在 React 中，一个函数如果被传递给子组件，或者作为其他 Hook（如 <code>useEffect</code>）的依赖，其引用的稳定性至关重要。<code>useCallback</code>通过依赖项数组来控制函数引用的变化，只有依赖项真的变了，函数引用才变。这种稳定性是 <code>React.memo</code>等优化手段能够生效的前提。</li></ul><h2 id="useeffect" tabindex="-1"><a class="header-anchor" href="#useeffect"><span>useEffect</span></a></h2><h3 id="一、基础用法" tabindex="-1"><a class="header-anchor" href="#一、基础用法"><span>一、基础用法</span></a></h3><p><code>useEffect(() =&gt; { fetchUserList(); }, [fetchUserList])</code> 核心拆解：这行代码是 React 中「副作用管理 + 依赖控制」的典型写法，我们先拆成<strong>基础结构</strong>和<strong>业务逻辑</strong>两层讲解，再对比 Vue3 帮你理解，最后讲这么写的「为什么」。</p><h4 id="_1-先懂-useeffect-基础语法" tabindex="-1"><a class="header-anchor" href="#_1-先懂-useeffect-基础语法"><span>1. 先懂 <code>useEffect</code> 基础语法</span></a></h4><p><code>useEffect</code> 是 React 处理「副作用」的核心 Hook，语法结构：</p><div class="language-tsx line-numbers-mode" data-highlighter="prismjs" data-ext="tsx"><pre><code><span class="line"><span class="token function">useEffect</span><span class="token punctuation">(</span></span>
<span class="line">  <span class="token comment">// 第一个参数：副作用回调函数（要执行的逻辑，比如请求、DOM操作、监听）</span></span>
<span class="line">  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">/* 要执行的代码 */</span> <span class="token punctuation">}</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token comment">// 第二个参数：依赖数组（决定回调函数「什么时候执行」）</span></span>
<span class="line">  <span class="token punctuation">[</span>依赖<span class="token number">1</span><span class="token punctuation">,</span> 依赖<span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">]</span></span>
<span class="line"><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p><strong>副作用</strong>：指「不属于组件渲染本身，但需要在渲染后执行的逻辑」（比如网络请求、操作 DOM、添加事件监听、修改全局变量等）；</p></li><li><p>依赖数组的规则</p><p>：只有数组里的变量 / 函数「引用发生变化」时，回调函数才会重新执行；</p><ul><li>依赖数组为空 <code>[]</code>：仅在组件<strong>首次挂载</strong>时执行 1 次（类比 Vue3 的 <code>onMounted</code>）；</li><li>依赖数组有值：组件挂载时执行 1 次 + 依赖项变化时再执行；</li><li>不写依赖数组：组件<strong>每次渲染 / 更新</strong>都执行（极度不推荐，会导致无限循环）。</li></ul></li></ul><h4 id="_2-拆解你问的这段代码" tabindex="-1"><a class="header-anchor" href="#_2-拆解你问的这段代码"><span>2. 拆解你问的这段代码</span></a></h4><div class="language-tsx line-numbers-mode" data-highlighter="prismjs" data-ext="tsx"><pre><code><span class="line"><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function">fetchUserList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 执行「获取用户列表」的网络请求</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>fetchUserList<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 依赖：fetchUserList 函数的引用</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_1-回调函数-fetchuserlist" tabindex="-1"><a class="header-anchor" href="#_1-回调函数-fetchuserlist"><span>（1）回调函数：<code>() =&gt; { fetchUserList(); }</code></span></a></h5><p>作用很简单：执行封装好的网络请求函数 <code>fetchUserList</code>，获取用户列表数据。</p><h5 id="_2-依赖数组-fetchuserlist" tabindex="-1"><a class="header-anchor" href="#_2-依赖数组-fetchuserlist"><span>（2）依赖数组：<code>[fetchUserList]</code></span></a></h5><p>核心是「监听 <code>fetchUserList</code> 函数的引用变化」—— 只有 <code>fetchUserList</code> 的引用变了，这个 <code>useEffect</code> 才会重新执行。</p><p>结合之前案例中 <code>fetchUserList</code> 被 <code>useCallback</code> 包裹的背景：</p><div class="language-tsx line-numbers-mode" data-highlighter="prismjs" data-ext="tsx"><pre><code><span class="line"><span class="token keyword">const</span> fetchUserList <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">// 依赖 searchParams 做请求</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>searchParams<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// fetchUserList 仅在 searchParams 变化时，引用才会更新</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以这行 <code>useEffect</code> 的<strong>实际执行逻辑</strong>是：</p><table><thead><tr><th>场景</th><th>执行行为</th><th>类比 Vue3</th></tr></thead><tbody><tr><td>组件首次挂载</td><td><code>fetchUserList</code> 有初始引用 → <code>useEffect</code> 执行 → 调用 <code>fetchUserList</code> 发初始请求</td><td><code>onMounted(() =&gt; fetchUserList())</code></td></tr><tr><td><code>searchParams</code> 变化（比如关键词 / 页码改了）</td><td><code>fetchUserList</code> 的 <code>useCallback</code> 检测到 <code>searchParams</code> 变 → <code>fetchUserList</code> 引用更新 → <code>useEffect</code> 检测到依赖变化 → 重新执行 → 调用新的 <code>fetchUserList</code> 发请求</td><td><code>watch(searchParams, () =&gt; fetchUserList(), { immediate: true })</code></td></tr><tr><td>组件其他状态变化（比如弹窗显隐）</td><td><code>searchParams</code> 没变化 → <code>fetchUserList</code> 引用不变 → <code>useEffect</code> 不执行 → 避免重复请求</td><td>无对应操作（Vue3 不监听无关状态）</td></tr></tbody></table><h3 id="二、为什么要这么写" tabindex="-1"><a class="header-anchor" href="#二、为什么要这么写"><span>二、为什么要这么写？</span></a></h3><p>（核心：避免闭包陷阱 + 减少无效请求）你可能会问：「为什么不直接把依赖写成 <code>[searchParams]</code>，比如 <code>useEffect(() =&gt; { fetchUserList(); }, [searchParams])</code>？」两种写法都能实现「searchParams 变化时重新请求」，但 <code>[fetchUserList]</code> 是更严谨的写法，原因如下：</p><h4 id="_1-避免「闭包陷阱」" tabindex="-1"><a class="header-anchor" href="#_1-避免「闭包陷阱」"><span>1. 避免「闭包陷阱」</span></a></h4><p>React 函数组件每次渲染都会创建新的变量 / 函数，<code>fetchUserList</code> 内部如果依赖多个外部变量（比如 <code>setLoading</code>、<code>message</code>、<code>searchParams</code>），直接依赖 <code>searchParams</code> 可能导致 <code>fetchUserList</code> 捕获「旧的闭包值」：</p><div class="language-tsx line-numbers-mode" data-highlighter="prismjs" data-ext="tsx"><pre><code><span class="line"><span class="token comment">// 反例：直接依赖 searchParams，可能出问题</span></span>
<span class="line"><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">// 假设 fetchUserList 没包 useCallback，这里的 fetchUserList 是「当前渲染周期的旧版本」</span></span>
<span class="line">  <span class="token comment">// 可能拿到的是旧的 searchParams/setLoading 引用</span></span>
<span class="line">  <span class="token function">fetchUserList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>searchParams<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而通过依赖「被 <code>useCallback</code> 包裹的 <code>fetchUserList</code>」，能保证每次执行的 <code>fetchUserList</code> 都是「最新的」（包含最新的 <code>searchParams</code>、<code>setLoading</code> 等依赖），彻底避免闭包陷阱。</p><h4 id="_2-符合-react-hooks-规则" tabindex="-1"><a class="header-anchor" href="#_2-符合-react-hooks-规则"><span>2. 符合 React Hooks 规则</span></a></h4><p>ESLint 的 <code>react-hooks/exhaustive-deps</code> 规则要求：<strong>useEffect 回调中用到的所有外部变量 / 函数，必须加入依赖数组</strong>。因为 <code>fetchUserList</code> 是回调中调用的外部函数，所以必须加入依赖；如果漏加，会触发报错，且可能导致逻辑异常。</p><h3 id="三、和-vue3-对比" tabindex="-1"><a class="header-anchor" href="#三、和-vue3-对比"><span>三、和 Vue3 对比</span></a></h3><p>React 的 <code>useEffect(() =&gt; { fetchUserList(); }, [fetchUserList])</code> 等价于 Vue3 中：</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code><span class="line"><span class="token comment">// Vue3 写法（onMounted + watch，且 watch 立即执行）</span></span>
<span class="line"><span class="token keyword">import</span> <span class="token punctuation">{</span> onMounted<span class="token punctuation">,</span> watch <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 组件挂载时执行一次</span></span>
<span class="line"><span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function">fetchUserList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 监听 fetchUserList 的依赖（searchParams）变化，重新执行</span></span>
<span class="line"><span class="token comment">// （Vue3 中无需监听函数本身，因为 Vue 的响应式是「自动的」）</span></span>
<span class="line"><span class="token function">watch</span><span class="token punctuation">(</span></span>
<span class="line">  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span>searchParams<span class="token punctuation">.</span>page<span class="token punctuation">,</span> searchParams<span class="token punctuation">.</span>keyword<span class="token punctuation">,</span> searchParams<span class="token punctuation">.</span>pageSize<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 监听 searchParams 核心字段</span></span>
<span class="line">  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">fetchUserList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token punctuation">{</span> immediate<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span> <span class="token comment">// 立即执行（等价于组件挂载时执行）</span></span>
<span class="line"><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>核心差异：</p><ul><li>Vue3：响应式是「自动的」，监听数据即可，无需关心函数引用；</li><li>React：是「显式依赖」，必须通过依赖数组声明要监听的变量 / 函数，且函数引用的稳定性需要用 <code>useCallback</code> 保证。</li></ul><h3 id="四、常见误区-注意事项" tabindex="-1"><a class="header-anchor" href="#四、常见误区-注意事项"><span>四、常见误区 &amp; 注意事项</span></a></h3><ol><li><p>依赖数组漏写 <code>fetchUserList</code>：</p><p>ESLint 会报错，且可能导致fetchUserList捕获旧的闭包值（比如拿到旧的searchParams），请求参数错误。</p></li><li><p><code>fetchUserList</code> 不包 <code>useCallback</code>：</p><p>每次组件渲染都会创建新的fetchUserList引用，导致useEffect每次都执行，触发重复请求（比如组件渲染 10 次，请求 10 次）。</p></li><li><p>依赖数组写空 <code>[]</code></p><p>仅挂载时执行 1 次，后续searchParams变化不会重新请求，筛选 / 分页功能失效。</p></li></ol><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p><code>useEffect(() =&gt; { fetchUserList(); }, [fetchUserList])</code> 的核心目的是：<strong>保证「只有当搜索参数（searchParams）变化时，才重新执行用户列表请求」，同时通过 <code>useCallback</code> 保证 <code>fetchUserList</code> 引用稳定，避免重复请求和闭包陷阱，完全符合 React Hooks 的规则</strong>。</p><h2 id="prev" tabindex="-1"><a class="header-anchor" href="#prev"><span>prev</span></a></h2><h3 id="一、prev-核心含义" tabindex="-1"><a class="header-anchor" href="#一、prev-核心含义"><span>一、<code>prev</code> 核心含义</span></a></h3><p><code>prev</code> 是 React 状态更新函数（如 <code>setSearchParams</code>）传给「函数式更新回调」的<strong>参数</strong>，代表「当前要更新的状态的最新快照」（即更新操作执行前，<code>searchParams</code> 的完整值）。</p><p>简单说：<code>prev = 更新前的 searchParams</code>，你可以把它理解为「状态的临时替身」，用来基于旧状态生成新状态。</p><h3 id="二、代码场景拆解" tabindex="-1"><a class="header-anchor" href="#二、代码场景拆解"><span>二、代码场景拆解</span></a></h3><p>你的代码：</p><div class="language-tsx line-numbers-mode" data-highlighter="prismjs" data-ext="tsx"><pre><code><span class="line"><span class="token keyword">const</span> <span class="token function-variable function">handleKeywordChange</span> <span class="token operator">=</span> <span class="token punctuation">(</span>e<span class="token operator">:</span> React<span class="token punctuation">.</span>ChangeEvent<span class="token operator">&lt;</span>HTMLInputElement<span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function">setSearchParams</span><span class="token punctuation">(</span>prev <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span></span>
<span class="line">    <span class="token operator">...</span>prev<span class="token punctuation">,</span> <span class="token comment">// 复制更新前的所有搜索参数（如pageSize、startTime等）</span></span>
<span class="line">    keyword<span class="token operator">:</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">,</span> <span class="token comment">// 覆盖关键词字段</span></span>
<span class="line">    page<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token comment">// 重置页码为1</span></span>
<span class="line">  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1-为什么要用「函数式更新」-prev" tabindex="-1"><a class="header-anchor" href="#_1-为什么要用「函数式更新」-prev"><span>1. 为什么要用「函数式更新」（<code>prev =&gt; {...}</code>）？</span></a></h4><p>React 的 <code>setXxx</code> 状态更新<strong>可能是异步的</strong>（比如频繁触发时，React 会批量更新），如果直接写：</p><div class="language-tsx line-numbers-mode" data-highlighter="prismjs" data-ext="tsx"><pre><code><span class="line"><span class="token comment">// 不推荐：可能拿到旧的 searchParams（闭包陷阱）</span></span>
<span class="line"><span class="token function">setSearchParams</span><span class="token punctuation">(</span><span class="token punctuation">{</span></span>
<span class="line">  <span class="token operator">...</span>searchParams<span class="token punctuation">,</span> <span class="token comment">// 这里的 searchParams 可能是组件渲染时的旧值</span></span>
<span class="line">  keyword<span class="token operator">:</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">,</span></span>
<span class="line">  page<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而用 <code>prev</code> 作为参数的函数式更新，能<strong>保证 <code>prev</code> 永远是「更新前的最新状态」</strong>，避免因异步更新导致的状态错误。</p><h4 id="_2-举个具体例子-帮你理解" tabindex="-1"><a class="header-anchor" href="#_2-举个具体例子-帮你理解"><span>2. 举个具体例子（帮你理解）</span></a></h4><p>假设当前 <code>searchParams</code> 是：</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code><span class="line"><span class="token punctuation">{</span> keyword<span class="token operator">:</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">,</span> page<span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> pageSize<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span> startTime<span class="token operator">:</span> <span class="token string">&quot;2025-01-01&quot;</span> <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>用户输入关键词「张三」触发 <code>handleKeywordChange</code> 时：</p><ul><li><code>prev</code> = <code>{ keyword: &quot;&quot;, page: 3, pageSize: 10, startTime: &quot;2025-01-01&quot; }</code>（更新前的完整状态）；</li><li><code>...prev</code> 复制所有旧字段；</li><li>覆盖 <code>keyword</code> 为「张三」，重置 <code>page</code> 为 1；</li><li>最终新的 <code>searchParams</code> = <code>{ keyword: &quot;张三&quot;, page: 1, pageSize: 10, startTime: &quot;2025-01-01&quot; }</code>。</li></ul><h3 id="三、关键注意点" tabindex="-1"><a class="header-anchor" href="#三、关键注意点"><span>三、关键注意点</span></a></h3><ol><li><p><code>prev</code> 是「只读快照」：你可以读取 <code>prev</code> 的值，但不要直接修改它（比如 <code>prev.page = 1</code>），必须通过「解构 + 覆盖」生成新对象（React 状态不可变）；</p></li><li><p>函数式更新的适用场景：只要你的新状态「依赖旧状态」（比如修改旧状态的某个字段、基于旧值计算新值），就用 <code>prev =&gt; {...}</code> 这种写法；</p></li><li><p>类比 Vue3：Vue3 中ref的函数式更新和这个逻辑一致，比如：</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code><span class="line"><span class="token comment">// Vue3 函数式更新（和 React prev 作用相同）</span></span>
<span class="line"><span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">count<span class="token punctuation">.</span><span class="token function-variable function">value</span> <span class="token operator">=</span> <span class="token punctuation">(</span>prev<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> prev <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// prev = 更新前的 count 值</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><h3 id="四、总结" tabindex="-1"><a class="header-anchor" href="#四、总结"><span>四、总结</span></a></h3><p><code>prev</code> 就是「更新前的状态副本」，用函数式更新（<code>prev =&gt; {...}</code>）能保证基于最新的旧状态生成新状态，避免 React 异步更新导致的「闭包陷阱」，是修改「对象 / 数组类型状态」的标准写法（因为 React 状态不可直接修改，必须基于旧状态创建新状态）。</p>`,122)])])}const i=n(p,[["render",c]]),u=JSON.parse('{"path":"/posts/react/react%E5%85%A5%E9%97%A8.html","title":"React基础入门","lang":"zh-CN","frontmatter":{"date":"2025-12-10T00:00:00.000Z","category":["说明文档"],"tag":["React","TypeScript"]},"headers":[{"level":2,"title":"基础入门","slug":"基础入门","link":"#基础入门","children":[{"level":3,"title":"一、核心认知：React 是什么？（类比 Vue）","slug":"一、核心认知-react-是什么-类比-vue","link":"#一、核心认知-react-是什么-类比-vue","children":[]},{"level":3,"title":"关键类比（Vue3 → React）","slug":"关键类比-vue3-→-react","link":"#关键类比-vue3-→-react","children":[]},{"level":3,"title":"二、极速上手：从「写一个按钮」开始","slug":"二、极速上手-从「写一个按钮」开始","link":"#二、极速上手-从「写一个按钮」开始","children":[]},{"level":3,"title":"三、React 核心灵魂：JSX 语法（类比 Vue 模板）","slug":"三、react-核心灵魂-jsx-语法-类比-vue-模板","link":"#三、react-核心灵魂-jsx-语法-类比-vue-模板","children":[]},{"level":3,"title":"四、Vue3 → React 核心思维转换","slug":"四、vue3-→-react-核心思维转换","link":"#四、vue3-→-react-核心思维转换","children":[]}]},{"level":2,"title":"Pick","slug":"pick","link":"#pick","children":[{"level":3,"title":"一、核心含义","slug":"一、核心含义","link":"#一、核心含义","children":[]},{"level":3,"title":"二、代码中 Pick 的实际作用","slug":"二、代码中-pick-的实际作用","link":"#二、代码中-pick-的实际作用","children":[]}]},{"level":2,"title":"useCallback","slug":"usecallback","link":"#usecallback","children":[{"level":3,"title":"💡 核心机制：理解闭包与稳定性","slug":"💡-核心机制-理解闭包与稳定性","link":"#💡-核心机制-理解闭包与稳定性","children":[]}]},{"level":2,"title":"useEffect","slug":"useeffect","link":"#useeffect","children":[{"level":3,"title":"一、基础用法","slug":"一、基础用法","link":"#一、基础用法","children":[]},{"level":3,"title":"二、为什么要这么写？","slug":"二、为什么要这么写","link":"#二、为什么要这么写","children":[]},{"level":3,"title":"三、和 Vue3 对比","slug":"三、和-vue3-对比","link":"#三、和-vue3-对比","children":[]},{"level":3,"title":"四、常见误区 & 注意事项","slug":"四、常见误区-注意事项","link":"#四、常见误区-注意事项","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}]},{"level":2,"title":"prev","slug":"prev","link":"#prev","children":[{"level":3,"title":"一、prev 核心含义","slug":"一、prev-核心含义","link":"#一、prev-核心含义","children":[]},{"level":3,"title":"二、代码场景拆解","slug":"二、代码场景拆解","link":"#二、代码场景拆解","children":[]},{"level":3,"title":"三、关键注意点","slug":"三、关键注意点","link":"#三、关键注意点","children":[]},{"level":3,"title":"四、总结","slug":"四、总结","link":"#四、总结","children":[]}]}],"git":{"updatedTime":1765529925000,"contributors":[{"name":"ksldnasx","username":"ksldnasx","email":"wh8261408@126.com","commits":1,"url":"https://github.com/ksldnasx"}],"changelog":[{"hash":"a6f99f3f499e5fabbf95e84b60432202d6227434","time":1765529925000,"email":"wh8261408@126.com","author":"ksldnasx","message":"feat: React文章"}]},"filePathRelative":"posts/react/react入门.md","excerpt":"\\n<h2>基础入门</h2>\\n<h3>一、核心认知：React 是什么？（类比 Vue）</h3>\\n<p>Vue3 是「渐进式框架」，有完整的模板、指令、响应式体系；React 是「UI 库」（核心只管视图渲染），更像「函数式的视图生成器」，核心思想：<strong>用函数描述 UI，数据变了函数重新执行，UI 就更新</strong>。</p>\\n<h3>关键类比（Vue3 → React）</h3>\\n<table>\\n<thead>\\n<tr>\\n<th>Vue3 概念</th>\\n<th>React 对应概念</th>\\n<th>核心差异</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>单文件组件.vue</td>\\n<td>组件文件.tsx/.jsx</td>\\n<td>React 用 JSX 写模板（HTML 嵌 JS）</td>\\n</tr>\\n<tr>\\n<td>setup () 语法糖</td>\\n<td>函数组件</td>\\n<td>React 组件本质是返回 JSX 的函数</td>\\n</tr>\\n<tr>\\n<td>ref/reactive</td>\\n<td>useState/useReducer</td>\\n<td>React 响应式是「显式更新」</td>\\n</tr>\\n<tr>\\n<td>watch/watchEffect</td>\\n<td>useEffect/useLayoutEffect</td>\\n<td>副作用监听需手动指定依赖</td>\\n</tr>\\n<tr>\\n<td>Props 传值</td>\\n<td>Props 传值</td>\\n<td>逻辑一致，TS 类型声明方式不同</td>\\n</tr>\\n<tr>\\n<td>插槽 Slot</td>\\n<td>组件传子元素 / Props</td>\\n<td>React 无插槽，用「传元素」替代</td>\\n</tr>\\n</tbody>\\n</table>"}');export{i as comp,u as data};
