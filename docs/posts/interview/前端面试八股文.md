---
date: 2026-01-30
category:
  - 前端面试
tag:
  - Vue3
  - React
  - JavaScript
---

# 前端面试八股文及总结

## Day 1

好的，我们来模拟一次前端的深度技术面试。我将以**面试官**（I）和**候选人**（C）的角色进行一问一答

---

### **第一幕：JavaScript 中的事件循环机制**

**I：** 请解释一下 JavaScript 中的事件循环机制。如果现在有一段包含 `setTimeout`、`Promise` 和 `async/await` 的代码，你能描述一下它们的执行顺序吗？

**C：** 事件循环是 JS 实现异步的核心。它维护一个调用栈、一个微任务队列和一个宏任务队列。

1.  同步代码执行，遇到异步任务，根据类型分发：`setTimeout` 的回调进入宏任务队列，`Promise.then` 和 `async/await` 后的代码进入微任务队列。
2.  当前调用栈清空后，会**立即清空所有微任务**。
3.  然后从宏任务队列取出**一个**任务执行，执行完毕后再次检查并清空微任务队列，如此循环。

**I：** 那么，看这段代码，输出顺序是什么？
```javascript
console.log('1');
setTimeout(() => console.log('2'), 0);
Promise.resolve().then(() => console.log('3'));
async function async1() {
    console.log('4');
    await async2();
    console.log('5');
}
async function async2() { console.log('6'); }
async1();
console.log('7');
```

**C：** 输出顺序是：**1, 4, 6, 7, 3, 5, 2**。
解析：
1.  同步输出 `1`。
2.  `setTimeout` 回调 `2` 放入宏任务队列。
3.  `Promise.then` 回调 `3` 放入微任务队列。
4.  执行 `async1()`，同步输出 `4`。
5.  执行 `await async2()`，同步输出 `6`。**`await` 后面的 `console.log('5')` 会被包裹成 Promise.then 的形式，放入微任务队列**。
6.  同步输出 `7`。
7.  调用栈清空，清空微任务队列：按入队顺序输出 `3`，然后 `5`。
8.  微任务清空后，执行下一个宏任务，输出 `2`。

---

### **第二幕：浏览器输入 URL 到页面显示过程**

**I：** 经典问题：从浏览器输入 URL 到页面显示，发生了什么？

**C：** 这是一个综合过程：

1.  **网络过程**：DNS解析 -> 建立TCP连接（三次握手） -> 发送HTTP请求 -> 服务器处理并返回响应 -> （如果是HTTPS，还有TLS握手）。
2.  **浏览器解析与渲染**：
    *   **构建DOM树**：HTML解析器将字节流转换为DOM树。
    *   **构建CSSOM树**：解析CSS，生成CSS规则树。
    *   **构建渲染树**：合并DOM和CSSOM，排除不可见元素。
    *   **布局**：计算每个节点的几何信息（位置、大小）。
    *   **绘制**：将布局信息转换为屏幕上的实际像素。
    *   **合成**：将各图层合成，最终显示到屏幕上。

**I：** 追问：在这个过程中，如何理解“重排”和“重绘”？如何避免或优化？

**C：** 
*   **重排**：当元素的几何属性（宽、高、位置）发生变化，触发布局重新计算的过程。**开销大**。
*   **重绘**：当元素的外观属性（颜色、背景、阴影）改变，但不影响布局时，会触发重绘。开销比重排小。
*   **优化**：
    1.  **避免频繁操作样式**：合并多次DOM操作（使用`DocumentFragment`或修改`className`）。
    2.  **脱离文档流**：对复杂动画使用`position: absolute/fixed`，使其脱离标准流，减少影响范围。
    3.  **GPU加速**：对动画元素使用 `transform` 和 `opacity`，它们由合成器单独处理，跳过布局和绘制。

---

### **第三幕： Vue 3 的响应式核心及与Vue 2 对比**

**I：** Vue 3 的响应式系统核心是什么？与 Vue 2 的 `Object.defineProperty` 相比有何优势？

**C：** Vue 3 使用 `Proxy` 实现响应式。
**优势**：

1.  **直接代理整个对象**：无需递归遍历所有属性，性能更好，初始化更快。
2.  **动态监听属性增删**：`Proxy` 可以拦截 `set` 和 `delete` 操作，而 `Object.defineProperty` 需要对新增属性手动调用 `Vue.set`。
3.  **更好的数组监听**：`Proxy` 可以拦截数组的索引修改、`length` 变化等所有操作。
4.  **支持更多数据结构**：可以原生支持 `Map`、`Set`、`WeakMap`、`WeakSet`。

**I：** 追问：你能简述一下 `Vue 3` 中 `ref` 和 `reactive` 的区别和使用场景吗？

**C：** 
*   `reactive`：用于创建**对象或数组**的响应式代理。它接收一个对象，返回该对象的 `Proxy`。不能用于原始值。
*   `ref`：用于创建一个包装器，使其具有响应式。它可以包装**任何类型的值**（包括原始值）。在模板和 `setup` 中会自动解包 `.value`。
*   **使用场景**：当需要响应式的**原始值**（如字符串、数字、布尔值）时，必须使用 `ref`。当需要响应式的**复杂对象**时，优先使用 `reactive`，语法更简洁。

---

### **第四幕：React 框架 (理念与 hooks)**

**I：** 谈一谈你对 React Hooks 的理解。为什么不能在循环、条件或嵌套函数中调用 Hook？

**C：** Hooks 是让函数组件拥有状态和生命周期等能力的功能函数。其核心规则是 **“只在最顶层调用 Hook”**。
**原因**：React 依赖于 **Hook 的调用顺序** 来正确关联每次渲染的 `state`。如果在条件语句中调用 Hook，会打乱这个顺序，导致后续 Hook 与之前的 `state` 错位匹配，引发 bug。React 内部通过一个“记忆单元格”链表来跟踪 Hook，顺序至关重要。

**I：** 那么 `useEffect` 和 `useLayoutEffect` 有什么区别？

**C：** 
*   `useEffect`：是**异步**执行的。它会在浏览器完成当前的布局与绘制**之后**才执行，不会阻塞浏览器的渲染。适合执行数据获取、订阅、手动修改 DOM（非即时）等副作用。
*   `useLayoutEffect`：是**同步**执行的。它会在所有 DOM 变更之后、浏览器绘制**之前**同步执行。会阻塞浏览器的绘制。适合执行需要**同步读取 DOM 布局**或**进行 DOM 样式修改**（如测量元素、设置动画初始状态）的操作，以避免视觉上的闪烁。

---

### **第五幕： Webpack 与性能 **

**I：** Webpack 的核心概念有哪些？Tree Shaking 是如何工作的？

**C：** 核心概念：**入口、出口、Loader、Plugin、模式**。
**Tree Shaking** 是一个通过静态分析来剔除项目中未使用代码（dead code）的优化技术。

*   **工作原理**：
    1.  **依赖 ES6 模块语法**：因为 ES Module 是静态的（`import/export`），可以在编译时分析出依赖关系。
    2.  **标记未使用代码**：在编译阶段，Webpack 会分析出哪些 `export` 被 `import` 了，哪些没有被引用。
    3.  **在压缩阶段剔除**：在代码压缩（如 TerserPlugin）阶段，将这些标记为“未使用”的代码安全地删除。

**I：** 如果让你优化一个首屏加载过慢的 Vue/React 单页应用，你会从哪些方面入手？

**C：** 这是一个系统工程：
1.  **分析**：使用 Lighthouse、Webpack Bundle Analyzer 分析瓶颈（大资源、未压缩、无用代码）。
2.  **加载优化**：
    *   **代码分割**：使用路由懒加载、组件异步加载，拆分主包。
    *   **图片优化**：使用 WebP 格式、懒加载、雪碧图、CDN。
    *   **资源压缩**：开启 Gzip/Brotli 压缩。
3.  **构建优化**：
    *   升级 Webpack/Vite 到最新版。
    *   配置 `splitChunks` 分离公共依赖。
    *   开启 `Tree Shaking`。
4.  **缓存策略**：为静态资源设置强缓存（`Cache-Control`）。
5.  **运行时优化**：
    *   **SSR/SSG**：对于内容型网站，考虑服务端渲染或静态生成，提升首屏速度。
    *   **骨架屏**：提升用户体验感知。

---

