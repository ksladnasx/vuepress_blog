# 基础算法

## 接雨水问题

> 给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。



核心是要理解，对于每一个位置（数组中每一个数），它能接的雨水量取决于：

```py
min(左边最大高度, 右边最大高度) - 当前高度
```



### 双指针法：

1. 用两个指针从两端向中间移动
2. 维护左右两边的最大高度
3. 每次处理较矮的那一边（因为矮边决定了水位上限）

```py
def trap_rain_water(height):
    """
    计算接雨水的总量
    思路：双指针法，时间复杂度 O(n)
    """
    if not height or len(height) < 3:
        return 0
    
    left, right = 0, len(height) - 1
    left_max, right_max = 0, 0
    water = 0
    
    while left < right:
        # 哪边矮，就先处理哪边
        if height[left] < height[right]:
            # 更新左边最大值
            if height[left] >= left_max:
                left_max = height[left]
            else:
                # 当前位置能接的水量 = 左边最大高度 - 当前高度
                water += left_max - height[left]
            left += 1
        else:
            # 更新右边最大值
            if height[right] >= right_max:
                right_max = height[right]
            else:
                # 当前位置能接的水量 = 右边最大高度 - 当前高度
                water += right_max - height[right]
            right -= 1
    
    return water

if __name__ == '__main__':
    n = list(map(int, input().split(",")))
    print(trap_rain_water(n))
```



### 动态规划法（更直观）:

```py
def trap_rain_water_dp(height):
    """
    动态规划法：计算每个位置的左右最大高度
    """
    if len(height) < 3:
        return 0
    
    n = len(height)
    
    # 1. 计算每个位置左边的最大高度
    left_max = [0] * n
    left_max[0] = height[0]
    for i in range(1, n):
        left_max[i] = max(left_max[i-1], height[i])
    
    # 2. 计算每个位置右边的最大高度
    right_max = [0] * n
    right_max[n-1] = height[n-1]
    for i in range(n-2, -1, -1):
        right_max[i] = max(right_max[i+1], height[i])
    
    # 3. 计算总水量
    water = 0
    for i in range(n):
        # 当前位置能接的水量 = min(左边最大, 右边最大) - 当前高度
        water += min(left_max[i], right_max[i]) - height[i]
    
    return water

if __name__ == '__main__':
    n = list(map(int, input().split(",")))
    print(trap_rain_water_dp(n))
```





## N皇后问题

> 按照国际象棋的规则，皇后可以攻击与之处在**同一行或同一列或同一斜线**上的棋子。
>
> **n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n×n` 的棋盘上，并且使皇后彼此之间不能相互攻击。
>
> 给你一个整数 `n` ，返回所有不同的 **n 皇后问题** 的解决方案。
>
> 每一种解法包含一个不同的 **n 皇后问题** 的棋子放置方案，该方案中 `'Q'` 和 `'.'` 分别代表了皇后和空位。

行和列好避免，现在主要问题是同一个斜线，实际上要理解的是，如果是主对角线：左上到右下，特点是行数减去列数是常数，即row - col = 常数。则副对角线：右上到左下，特点：row + col = 常数。

那要做很简单，首先肯定不在同一行，我们可以通过queens 列表，记录每行皇后所在的列位置，例如: queens = [1, 3, 0, 2] 表示：第0行皇后在第1列，第1行皇后在第3列。再用xy_diff: 集合记录已占用的主对角线的常数，用 xy_sum: 集合，记录已占用的副对角线，里面存的都是常数，那在判断的时候尝试在当前行的每一列放置皇后，如果列号q不在queens 列表中，且行号与列号的差值和和值不在集合中，说明条件满足，进行皇后放置（递归调用函数）

```py
"""
N皇后问题 - 回溯法
如果 q 已经在 queens 中，说明这一列已经有皇后了
# p: 当前行号（从0开始）
# q: 当前列号（从0开始）
# xy_diff: 集合，记录已占用的主对角线
# xy_sum: 集合，记录已占用的副对角线

    """
def solveNQueens(n):

    def dfs(queens, xy_diff, xy_sum):
        """
        queens: 每行皇后所在的列位置
        xy_diff: 主对角线 (row - col) 集合
        xy_sum:  副对角线 (row + col) 集合
        """
        p = len(queens)  # 当前行数
        if p == n:  # 找到一种解决方案
            result.append(queens[:])
            return

        for q in range(n):  # 尝试在当前行的每一列放置皇后
            # 检查是否冲突：同列、主对角线、副对角线
            if q not in queens and p - q not in xy_diff and p + q not in xy_sum:
                # 放置皇后，继续下一行
                dfs(queens + [q], xy_diff | {p - q}, xy_sum | {p + q})

    result = []
    dfs([], set(), set())

    # 转换为棋盘表示
    boards = []
    for solution in result:
        board = []
        for col in solution:
            row_str = '.' * col + 'Q' + '.' * (n - col - 1)
            board.append(row_str)
        boards.append(board)

    return boards


# 测试
n = 4  #整数n
solutions = solveNQueens(n)
print(f"{n}皇后问题有 {len(solutions)} 种解法:")
for i, board in enumerate(solutions, 1):
    print(f"解法{i}:")
    for row in board:
        print(" ".join(row))
    print()

```

