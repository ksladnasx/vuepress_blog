---
date: 2025-12-05
category:
  - 经验总结
tag:
  - 实习
  - SSE
---
# 实习周总结5



## sseDemo演练

### 概述

由于个人之前未进行sse的代码训练，便进行了sse的相关代码训练操作。

本周主要对SSE的项目进行了系统的训练，通过Nodejs构建后端来进行sse的本地演练测试。该实践基于nodejs的express框架搭建的后端，然后通过vuejs的前端进行请求学习。

后端部分通过设置SSE必需的响应头以及相应的定时器发送数据来建立sse接口，前端部分则通过`eventSource.value = new EventSource(sse数据接口地址)`来进行连接，利用`eventSource.value.onopen`,`eventSource.value.onmessage` 以及 `eventSource.value.addEventListener('自定义事件名'，函数)`来实现对后端数据的接收。

### 代码

前端部分：[SSEDemoFronted](https://ksladnasx.github.io/vuepress_blog/posts/code/SSEDemoFronted.html)

后端部分：[ sseDomeServer](https://ksladnasx.github.io/vuepress_blog/posts/code/sseDomeServer.html)

整体项目地址：[sse-example](https://github.com/ksladnasx/sse-example)

### 关键解读

#### 后端部分

后端部分借助了express框架，为sse的接口设置了必要的响应头。正确的 SSE 响应头可保持长连接并避免缓存：

```js
  // 设置SSE必需的响应头
  res.writeHead(200, {
    "Content-Type": "text/event-stream",
    "Cache-Control": "no-cache",
    Connection: "keep-alive",
    "Access-Control-Allow-Origin": "*",
  });
    
```

同时设置定时器对心跳进行发送，定期发送空注释（如 `:heartbeat\n\n`）保持连接活跃，避免超时：

```js
// 心跳发送：每30秒发送注释行作为心跳（浏览器不会触发 new message）
  const heartbeatInterval = setInterval(() => {
    try {
      res.write("heartbeat:\n\n"); // SSE注释行作为心跳
    } catch (e) {
      // 忽略写入错误
    }
  }, 30000); // 每30秒发送一次心跳
```

SSE 消息需遵循特定格式，每条消息以两个换行符结尾。支持以下字段

- `data`: 消息内容（必填，可多行）
- `event`: 自定义事件类型（如 `status`）
- `id`: 消息 ID（用于断线重连）
- `retry`: 重连间隔（毫秒）

然后后端就可以通过各类定时器对前端进行数据的发送，同时对于特定的事件可发送event: 事件名称 来标识这是一个特殊事件，这里是发送不同类型的data数据的示例：

```js
 const interval = setInterval(() => {
    // 构造基础的数据对象 
    count++;
    console.log(`发送事件 #${count}`);
    const data = {
      id: count,
      timestamp: new Date().toISOString(),
      type: "update",
    };

    // 可以发送不同类型的事件
    if (count % 3 === 0 && count !== 1) {
      /*当服务器发送event: status   data: {...}\n\n时，浏览器的 EventSource 会把它识别为一个自定义事件名为 "status" 的事件。*/
      // 前端通过 addEventListener('status', handler) 或 es.onstatus（非标准）来接收；没有 event: 行的消息走默认的 onmessage。
      res.write("event: status\n");
      res.write(`data: ${JSON.stringify({ ...data, status: "pause" })}\n\n`);
    } else {
      if (count === 1) {
        console.log("发送初始化事件");
        res.write("event: status\n");
        res.write(`data: ${JSON.stringify({ ...data, status: "connected" })}\n\n`);
      } else {
        res.write(
          `data: ${JSON.stringify({ ...data, value: Math.random() * 100 })}\n\n`
        );
      }
    }
```

#### 前端部分

使用 `EventSource`API 创建连接，并通过事件回调处理数据

```js
    // 创建新的EventSource实例
   const es = new EventSource('/api/sse-data');
    //基础的事件回调
   es.onopen = () => console.log('连接已建立');
   es.onerror = (e) => console.error('连接异常', e);
   es.onmessage = (e) => console.log('默认消息', e.data);
```

接收后端定义好的事件的监听器，通过 `addEventListener`监听特定事件（对应后端的 `event`字段）：

```js
  // 接收自定义 event: status
    eventSource.value.addEventListener('status', (e) => {
      const data = JSON.parse(e.data);
      // e.data 同样是服务器发送的字符串
      statusevent.value = data.status;
      if (data.status === 'done') {
        connectionStatus.value = '服务器已完成发送';
        messages.value.unshift("消息结束");
        //关闭sse连接
        disconnectSSE();
      }
    });
```

当然也可对流进行处理，以下是典型的**前端流式数据接收**机制，通过Fetch API的ReadableStream接口处理服务器发送的实时文本流。代码核心是利用`response.body.getReader()`创建可读取的流式数据通道，实现逐块处理而非一次性加载。具体描述见注释：

```js
// 连接流式文本端点
const startStream = async () => {
  if (isStreaming.value) return;

  try {
    outputText.value = '';
    isStreaming.value = true;
    const response = await fetch('http://localhost:3000/stream-text');
    if (!response.ok || !response.body) {   throw new Error('流请求失败');  }

    //将传来 的二进制数据流转换为文本
    const reader = response.body.getReader();// 获取流读取器
    const decoder = new TextDecoder();// 二进制→字符串解码器

    //注意这里是递归  
    const processStream = ({ done, value }) => {
      if (done) {isStreaming.value = false;   return;  }
      const chunk = decoder.decode(value, { stream: true });
      const lines = chunk.split('\n');
      for (const line of lines) {
        if (line.startsWith('data: ')) {
          try {
         //line.substring(6) 是为了精准剔除 SSE 协议规定的 data: 前缀（注意：data: 后有一个空格）
            const data = JSON.parse(line.substring(6));
            if (data.done) {  isStreaming.value = false;  return;   }
             //  拼接文本（区分换行符和普通字符）
             outputText.value += data.char === '\n' ? '\n' : data.char;
            // 自动滚动：Vue nextTick 确保 DOM 更新后执行滚动
            nextTick(() => {
              if (outputElement.value) {
                outputElement.value.scrollTop = outputElement.value.scrollHeight;
              }
            });
          } catch (e) { console.error('解析消息错误:', e); }
        }
      }  // 递归读取下一个块：实现流式持续处理
      return reader.read().then(processStream);
    };
      //进行数据流读取并把结果给processStream并调用它
    reader.read().then(processStream);

  } catch (error) {
    console.error('流式请求错误:', error);
    isStreaming.value = false;
  }
};

```

