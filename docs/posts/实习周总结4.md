---
date: 2025-11-28
category:
  - 经验总结
tag:
  - 实习
  - SSE
  - BroadcastChannel
---

# 实习周总结4

## 详细总结

此处包含我个人对项目代码的一些详细解读，当然为了撰写效率，其包含了ai的总结部分，但基本思路和知识是对的就行。

对于SSE的基本知识：[SSE简介 | xh's blog](https://ksladnasx.github.io/vuepress_blog/posts/SSE简介.html)

对于源项目代码的解读：[SSE服务代码解读 | xh's blog](https://ksladnasx.github.io/vuepress_blog/posts/sseService文件解析.html)

对于bug修复的思路：[最大连接次数突破 | xh's blog](https://ksladnasx.github.io/vuepress_blog/posts/BroadcastChannel方式解决sse连接数限制.html)

最终完成的文件的解读：[sseService文件解读(BroadcastChannel版) | xh's blog](https://ksladnasx.github.io/vuepress_blog/posts/BroadcastChannel版本sse解读.html)

## 开发感悟

上周由于电装实习，没有详细去总结所遇到的这些问题。趁着这周空闲，简单对上次经历的项目功能点开发进行一下简略的总结复盘。

首先我开发所遇到的问题是前后端接口混乱并且接口不对齐的问题，然后我个人代码书写的思维习惯又较差，导致后期反复修改接口之后我的代码可读性变得特别差，优化和维护变得很困难。

遇到这类问题，首先是我写代码的流程上需要进行改进。首先接手一个功能点，在会议演示的时候就应该弄清所给的参考页面到底是进行的什么请求，跟我所知的接口文档是否是能对上的，这是及其重要的。就算开始没能去搞清，也得先根据接口文档进行请求，发现问题积极与后端进行沟通。然后再进行接口的测试，这里可以使用`apipost`等工具，接口都正常了之后再根据接口需求及返回数据进行数据类型的定义，然后进行请求的撰写。最后再是页面的开发，前期开发可以根据请求返回的数据来mock一些数据进行撰写。等页面基本完成之后再将mock的数据改为实际请求的数据。

![image-20251124111838525](C:\Users\wh826\AppData\Roaming\Typora\typora-user-images\image-20251124111838525.png)

## SSE修复（重点）

SSE最大连接数的bug是我这周从学长那里接手的5G项目的一个较为棘手的bug,由于之前个人对SSE的使用甚少，便借助ai开始快速的学习并了解**HTTP/1.1**协议的痛点。在经历知识学习，bug来源确认，方案搜寻与敲定，代码编写，个人测试以及代码总结后，个人能力得到了很大的进步。

### 基本概念

**SSE（Server-Sent Events）** 是一种基于 HTTP 的协议，允许服务器向客户端单向推送实时数据。其核心特性包括：

- **单向通信**：服务器主动推送数据至客户端，客户端无需轮询。 
- **自动重连**：连接中断后，客户端会自动尝试恢复。 
- **文本流式传输**：数据格式为 text/event-stream，支持纯文本传输
- **轻量级**：相较于 WebSocket，SSE 使用简单，默认支持断线重连。 
- SSE 适合用于构建轻量级实时应用，能够显著提升现代 Web 应用的实时交互能力。

### 原始代码

原始代码创建了一个sseService.js的文件，其封装了一个功能完整的SSE（Server-Sent Events）客户端服务类，用于接收后端实时推送的设备状态变化通知。对于组件的业务代码是透明的，其不关心具体业务逻辑。业务组件只需要按需求订阅自己需要的事件即可，实现了完美的关注点分离。

其核心属性包含：

| 属性                         | 类型        | 作用                             |
| ---------------------------- | ----------- | -------------------------------- |
| `eventSource`                | EventSource | 原生SSE连接对象                  |
| `listeners`                  | Map         | 事件监听器集合                   |
| `referenceCount`             | number      | **引用计数机制**，支持多组件共享 |
| `isConnected`/`isConnecting` | boolean     | 连接状态管理                     |

### Bug来源

我在源项目代码中创建了禁用sse连接的变量标志`VITE_SSE_DISABLED=false`

同时在原sseService.js文件的开头进行环境变量的判断用于屏蔽sse服务：

```js
class SSEService {
  constructor() {
    // 添加禁用标志
    this.disabled = import.meta.env.VITE_SSE_DISABLED === "true";
    if (this.disabled) {
      console.log("SSE服务已被禁用");
      // 初始化模拟对象，避免后续操作出错
      this.eventSource = {
        readyState: EventSource.CLOSED,
        close: () => {},
      };
      this.listeners = new Map();
      this.isConnected = false;
      this.isConnecting = false;
      return; // 直接返回，不进行后续初始化
      ...
    }
 }
}
```

根据以上代码测试成功确认了这就是SSE最大连接数限制导致的问题。在我们建立SSE连接的时候，由于**HTTP/1.1**的限制，在该协议下，大多数的现代的浏览器（如Chrome、Firefox、Edge）对**同一域名（协议+域名+端口）的并发连接数限制通常为6个**。这意味着，同一个浏览器标签页（或同一浏览器实例）中，对相同域名最多只能同时建立约6个SSE连接，超出此数量的新连接会被浏览器阻塞，直到有连接被关闭。

因此该项目的代码在不断新建页面达到六个以上后，后续的新标签页将不再能成功连接sse服务而进入无限等待，导致页面数据缺失。

### 解决方案

通过各类的资料搜寻以及ai整理，一般有以下方案：

1. **升级至HTTP/2**
2. **多域名/多端口策略**
3. **动态关闭标签连接**
4. **SharedWorker**
5. **BroadcastChannel** 

其中方案1显然不现实，方案2和3对于服务器的资源消耗极大，且逻辑不好写。方案4能建立无限个连接，但是要动业务代码，且后期的调试困难。

方案5的**BroadcastChannel** 的主从模式这种解决方式，它在保证较为轻量级且兼容性更好的情况下，基本上避免了业务逻辑部分的代码的修改，只需要对SSE连接的代码的主体文件进行修改。因此最终选择方案5.

**BroadcastChannel** 的主从模式类似一个频道，对于每个打开的标签页进行选举，选举好主标签页后主标签页建立SSE连接，同时对各类服务器更新的事件，利用**BroadcastChannel**进行广播，从标签页在收到广播后触发本地的处理器并更新数据。其核心就是让多个标签页共享一个SSE连接，避免连接数超限。

### 核心设计

我在基于原始代码逻辑的基础上添加了**BroadcastChannel** 的主从模式逻辑，其包含以下核心逻辑：

1. 主标签页选举：通过`electionMaster()`方法选举主标签页：按标签页 ID（`tab-1`、`tab-2`...）排序，ID 最小的标签页当选为主标签页。标签页通过`localStorage`存储自身标识（`masterKey`），用`BroadcastChannel`广播 “主标签页宣告”（`master-announcement`），同步状态给所有从标签页。从标签页监听`localStorage`变化和广播消息，确认主标签页身份，避免重复连接。
2. 主标签页心跳检测：为防止主标签页崩溃、关闭或失去响应后导致整个 SSE 服务中断，设计了心跳检测机制，从标签页每 30 秒通过`BroadcastChannel`发送`ping`消息给主标签页然后设置 5 秒超时器（`refreshTimeout`），主标签页收到`ping`后，立即返回`pong`消息。若未收到`pong`，判定主标签页失效，触发`electionMaster()`，重新进行主标签页选举。
3. 标签页状态监控（管理活跃标签页生命周期）：标签页初始化时通过`registerActiveTab()`将自身添加到`localStorage`的活跃列表（`activeTabsKey`），包含`tabId`、`instanceId`（唯一标识，避免刷新冲突）和时间戳。标签页关闭 / 刷新时通过`unregisterActiveTab()`从活跃列表移除自身，并在列表为空时重置计数器和主标签页标识。同时通过`cleanExpiredTabs()`定期清理 5 分钟内未更新时间戳的标签页（视为已关闭或失效），确保活跃列表准确。并且每 60 秒通过定时器更新当前标签页的时间戳，标记为 “活跃”，避免被误判为过期。
4.  跨标签页消息同步（基于 BroadcastChannel）：主标签页接收 SSE 消息后，通过`broadcastSSEMessage()`将消息广播给所有从标签页（如`device-online`、`device-offline`等事件）。从标签页监听广播消息，触发本地事件回调，实现与主标签页的状态同步。

### 代码总结

本次撰写的代码通过**主从模式**解决多标签页连接限制，通过**心跳检测**确保主标签页有效性，通过**状态监控**管理标签页生命周期，通过**重连机制**保证连接稳定性，最终实现了高效、可靠的跨标签页 SSE 实时消息推送服务。

## 组件传值

我上次所撰写的页面属于一个分步骤走的流程页面，因此每个步骤页面都有共同的父组件index.vue，因此各个步骤页面的 数据都是统一通过父组件进行请求和分发的，因此只有父子组件之间的数据流动。这里我是使用的 `defineProps`和 `defineEmits`来实现组件双向绑定（v-model）的标准且兼容性广泛的方法。其核心在于理解 **v-model 本质上是语法糖**，它自动处理了一个名为 `modelValue`的 prop 和一个名为 `update:modelValue`的自定义事件 。

因此对于上次模糊的状况，这里我撰写了两个组件进行演练，其中父组件将初始值传入子组件，利用自定义名称传入，子组件通过prop接收后展示，同时子组件有个表单，在填入数据后可更新对应数据同时通过emit更新到父组件，父组件收到更新后将使得子组件展示的姓名邮箱等信息进行改变。

注意这里要多个v-model才能双向数据流动（每个变量都要对应一个v-model），直接冒号是单向传递的。

同时注意子组件的写法，个人觉得应该是这样写。同时对于Moreinfo部分并没有写专门的emit的触发事件等，实践证明这样写可以实现父子组件数据的同步。（当然刷新会消失，但是点下一步不会）

### 父组件：

```vue
<template>
  <h2>测试 Props 传值和事件更新</h2>
  <p>姓名: {{ userName }}</p>
  <p>邮箱: {{ userEmail }}</p>
  <p>年龄: {{ age }}</p>
  <p>地址：{{ Moreinfo.address }}</p>
  <p>电话：{{ Moreinfo.phone }}</p>
  <index v-if="step == 1" v-model:name="userName" v-model:email="userEmail" v-model:age="age" v-model:moreinfo="Moreinfo" />
  <ind v-if="step == 2" v-model:moreinfo="Moreinfo" />
  <el-button @click="step -= 1">上一步</el-button>
  <el-button @click="step += 1">下一步</el-button>
</template>

<script setup lang="ts">
import ind from "../views/AddBackendServerGroup/AddBackendServerGroup.vue"
import { reactive, ref } from "vue";
import index from "./TestProps.vue"
const step = ref(1);
const userName = ref('');
const userEmail = ref('');
const age = ref(0);
const Moreinfo = reactive({
  address: '张三',
  phone: ''
})
</script>

<style>
.update-btn {
  padding-top: 20px;
}
</style>
```

### 子组件

```vue
<template>
  <el-form ref="formRef" :model="form" label-width="auto">
    <el-form-item label="Name" prop="newName" label-position="left">
      <el-input v-model="form.newName" placeholder="请输入" />
    </el-form-item>
    <el-form-item label="Email" prop="newEmail" label-position="left">
      <el-input v-model="form.newEmail" placeholder="请输入" />
    </el-form-item>
    <el-form-item label="Age" prop="newAge" label-position="left">
      <el-input v-model="form.newAge" placeholder="请输入" />
    </el-form-item>
    <el-form-item ><el-button type="primary"
        @click="updateName(form.newName); updateEmail(form.newEmail); updateAge(form.newAge)">提交</el-button></el-form-item>
  </el-form>
  <el-divider />
  <el-form ref="formRef" :model="moreinfo" label-width="auto">
    <el-form-item label="Address"><el-input v-model="moreinfo.address" placeholder="请输入" /></el-form-item>
    <el-form-item label="Phone"><el-input v-model="moreinfo.phone" placeholder="请输入" /></el-form-item>
    <!-- <el-form-item><el-button type="primary"
      @click="emit('update:moreinfo',moreinfo)">提交</el-button>
    </el-form-item> -->
  </el-form>

</template>

<script setup lang='ts'>
import { reactive } from 'vue';

const form = reactive({
  newName: '',
  newEmail: '',
  newAge: 0
});
// 1. 定义接收的 props
const props = defineProps({
  name: {
    type: String,
    default: ''
  },
  email: {
    type: String,
    default: ''
  },
  age: {
    type: Number,
    default: 0
  },
  moreinfo: {
    type: Object,
    default: () => ({
      address: '',
      phone: ''
    })
  }
})
// 2. 声明对应的更新事件
const emit = defineEmits(['update:name', 'update:email', 'update:age', 'update:moreinfo'])

const updateName = (newName: string) => { emit('update:name', newName) }
const updateEmail = (newEmail: string) => { emit('update:email', newEmail); console.log("更新了：", newEmail) }
const updateAge = (newAge: number) => { emit('update:age', newAge) }

</script>

<style scoped></style>
```





