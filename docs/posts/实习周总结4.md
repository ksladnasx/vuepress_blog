---
date: 2025-11-24
category:
  - 经验总结
tag:
  - 实习
  - Vue3
---

# 实习周总结4

## 经验总结

上周由于电装实习，没有详细去总结所遇到的这些问题。趁着这周空闲，简单进行一下总结复盘。

首先我开发所遇到的问题是前后端接口混乱并且接口不对齐的问题，然后我个人代码书写的思维习惯又比较差，导致后期反复修改接口之后我的代码可读性变得特别差，优化和维护变得很困难。

遇到这类问题，首先是我写代码的流程上需要进行改进。首先接手一个功能点，在会议演示的时候就应该弄清所给的参考页面到底是进行的什么请求，跟我所知的接口文档是否是能对上的，这是及其重要的。就算开始没能去搞清，也得先根据接口文档进行请求，发现问题积极与后端进行沟通。然后再进行接口的测试，这里可以使用apipost等工具，接口都正常了之后再根据接口需求及返回数据进行数据类型的定义，然后进行请求的撰写。最后再是页面的开发，前期开发可以根据请求返回的数据来mock一些数据进行撰写。等页面基本完成之后再将mock的数据改为实际请求的数据。



### SSE

**SSE（Server-Sent Events）** 是一种基于 HTTP 的协议，允许服务器向客户端单向推送实时数据。其核心特性包括：

- **单向通信**：服务器主动推送数据至客户端，客户端无需轮询。 
- **自动重连**：连接中断后，客户端会自动尝试恢复。 
- **文本流式传输**：数据格式为 text/event-stream，支持纯文本传输
- **轻量级**：相较于 WebSocket，SSE 使用简单，默认支持断线重连。 
- SSE 适合用于构建轻量级实时应用，能够显著提升现代 Web 应用的实时交互能力。

## 组件传值

我上次所撰写的页面属于一个分步骤走的流程页面，因此每个步骤页面都有共同的父组件index.vue，因此各个步骤页面的 数据都是统一通过父组件进行请求和分发的，因此只有父子组件之间的数据流动。这里我是使用的 `defineProps`和 `defineEmits`来实现组件双向绑定（v-model）的标准且兼容性广泛的方法。其核心在于理解 **v-model 本质上是语法糖**，它自动处理了一个名为 `modelValue`的 prop 和一个名为 `update:modelValue`的自定义事件 。

### 🌟个人撰写示例（标准）

这里我撰写了两个组件进行演练，其中父组件将初始值传入子组件，利用自定义名称传入，子组件通过prop接收后展示，同时子组件有个表单，在填入数据后可更新对应数据同时通过emit更新到父组件，父组件收到更新后将使得子组件展示的姓名邮箱等信息进行改变。

注意这里要多个v-model才能双向数据流动，直接冒号是单向传递的。

同时注意子组件的写法，个人觉得应该是这样写。同时对于Moreinfo部分并没有写专门的emit的触发事件等，实践证明这样写可以实现父子组件数据的同步。（当然刷新会消失，但是点下一步不会）

#### 父组件：

```vue
<template>
  <h2>测试 Props 传值和事件更新</h2>
  <p>姓名: {{ userName }}</p>
  <p>邮箱: {{ userEmail }}</p>
  <p>年龄: {{ age }}</p>
  <p>地址：{{ Moreinfo.address }}</p>
  <p>电话：{{ Moreinfo.phone }}</p>
  <index v-model:name="userName" v-model:email="userEmail" v-model:age="age" v-model:moreinfo="Moreinfo"/>
</template>

<script setup lang="ts">
import { reactive, ref } from "vue";
import index from "./TestProps.vue"

const userName = ref('');
const userEmail = ref('');
const age = ref(0);
const Moreinfo = reactive({
  address: '张三',
  phone: ''
})
</script>
```

#### 子组件

```vue
<template>

  <el-form ref="formRef" :model="form" label-width="auto">
    <el-form-item label="Name" prop="newName" label-position="left">
      <el-input v-model="form.newName" placeholder="请输入" />
    </el-form-item>
    <el-form-item label="Email" prop="newEmail" label-position="left">
      <el-input v-model="form.newEmail" placeholder="请输入" />
    </el-form-item>
    <el-form-item label="Age" prop="newAge" label-position="left">
      <el-input v-model="form.newAge" placeholder="请输入" />
    </el-form-item>
    <el-form-item ><el-button type="primary"
        @click="updateName(form.newName); updateEmail(form.newEmail); updateAge(form.newAge)">提交</el-button></el-form-item>
  </el-form>
  <el-divider />
  <el-form ref="formRef" :model="moreinfo" label-width="auto">
    <el-form-item label="Address"><el-input v-model="moreinfo.address" placeholder="请输入" /></el-form-item>
    <el-form-item label="Phone"><el-input v-model="moreinfo.phone" placeholder="请输入" /></el-form-item>
    <!-- <el-form-item><el-button type="primary"
      @click="emit('update:moreinfo',moreinfo)">提交</el-button>
    </el-form-item> -->
  </el-form>

</template>

<script setup lang='ts'>
import { reactive } from 'vue';

const form = reactive({
  newName: '',
  newEmail: '',
  newAge: 0
});
// 1. 定义接收的 props
const props = defineProps({
  name: {
    type: String,
    default: ''
  },
  email: {
    type: String,
    default: ''
  },
  age: {
    type: Number,
    default: 0
  },
  moreinfo: {
    type: Object,
    default: () => ({
      address: '',
      phone: ''
    })
  }
})
// 2. 声明对应的更新事件
const emit = defineEmits(['update:name', 'update:email', 'update:age', 'update:moreinfo'])

const updateName = (newName: string) => { emit('update:name', newName) }
const updateEmail = (newEmail: string) => { emit('update:email', newEmail); console.log("更新了：", newEmail) }
const updateAge = (newAge: number) => { emit('update:age', newAge) }

</script>

<style scoped></style>
```



### ai总结

#### 🔧 实现步骤与代码示例

##### 父组件

在父组件中，你直接使用 `v-model`绑定一个响应式数据即可，非常简洁。

```vue
<!-- ParentComponent.vue -->
<template>
  <div>
    <p>父组件中的值: {{ message }}</p>
    <!-- 使用 v-model 绑定数据 -->
    <ChildComponent v-model="message" />
  </div>
</template>

<script setup>
import { ref } from 'vue';
import ChildComponent from './ChildComponent.vue';

// 创建响应式数据
const message = ref('Hello from Parent');
</script>
```

在这段代码中，`v-model="message"`会被 Vue 编译器展开为：

```vue
:modelValue="message" @update:modelValue="newValue => message = newValue"
```

##### 子组件

子组件需要做两件事：

1. **接收 Prop**：使用 `defineProps`声明一个名为 `modelValue`的 prop，用来接收父组件传递过来的值。
2. **触发事件**：使用 `defineEmits`声明一个名为 `update:modelValue`的事件。当子组件内部需要更新这个值时，就触发（emit）这个事件，并将新值作为参数传递给父组件。

```vue
<!-- ChildComponent.vue -->
<template>
  <input
    type="text"
    :value="modelValue" <!-- 1. 将接收到的 prop 绑定到 input 的 value -->
    @input="onInput"    <!-- 2. 监听 input 事件 -->
  />
</template>

<script setup>
// 1. 定义 props，接收名为 modelValue 的属性
const props = defineProps(['modelValue']);

// 2. 定义 emits，声明一个名为 update:modelValue 的自定义事件
const emit = defineEmits(['update:modelValue']);

// 3. 输入事件处理函数
const onInput = (event) => {
  // 当输入时，触发 'update:modelValue' 事件，并将输入框的新值传递出去
  emit('update:modelValue', event.target.value);
};
</script>
```

#### 💡 核心原理：单向数据流的体现

这种方法严格遵循了 Vue 的**单向数据流**原则 ：

- **数据下行**：数据通过 prop（`modelValue`）从父组件“向下”流动到子组件。子组件不能直接修改这个 prop。
- **事件上行**：当子组件需要更新数据时，通过“向上”触发一个事件（`update:modelValue`）来通知父组件。父组件监听这个事件，并更新自己的数据，从而间接更新了子组件接收到的 prop。

这样做的好处是数据流向清晰可预测，避免了子组件意外修改父组件状态所带来的维护难题 。

#### ⚙️ 处理对象与多个 v-model

##### 处理对象类型的 v-model

如果 `v-model`绑定的是一个对象，子组件通常需要为对象的每个属性创建“中间层”（例如使用计算属性）来处理更新，以确保不会直接修改 prop 对象本身 。

```vue
<!-- ChildComponent.vue -->
<script setup>
import { computed } from 'vue';

const props = defineProps({ modelValue: Object });
const emit = defineEmits(['update:modelValue']);

// 为对象的 name 属性创建计算属性
const nameProxy = computed({
  get: () => props.modelValue.name,
  set: (val) => {
    // 触发更新时，创建一个新对象，避免直接修改原 prop
    emit('update:modelValue', { ...props.modelValue, name: val });
  }
});
</script>

<template>
  <input v-model="nameProxy" />
</template>
```

##### 实现多个 v-model

Vue 3 支持在同一个组件上使用多个 `v-model`，只需为每个 `v-model`指定不同的参数即可。

**父组件**：

```vue
<ChildComponent v-model:first-name="firstName" v-model:last-name="lastName" />
```

**子组件**：

```vue
<!-- ChildComponent.vue -->
<script setup>
// 使用不同的参数名定义对应的 props 和 emits
const firstName = defineProps(['firstName']);
const emit = defineEmits(['update:firstName']);

const lastName = defineProps(['lastName']);
const emit = defineEmits(['update:lastName']);

const onFirstNameInput = (e) => emit('update:firstName', e.target.value);
const onLastNameInput = (e) => emit('update:lastName', e.target.value);
</script>

<template>
  <input :value="firstName" @input="onFirstNameInput" />
  <input :value="lastName" @input="onLastNameInput" />
</template>
```

#### 🔧 自定义 Prop 名称

如果你不想使用默认的 `modelValue`，可以通过给 `v-model`添加一个参数来指定自定义的 prop 名称。格式为 `v-model:yourPropName`。这在两种情况下特别有用：

**追求更清晰的语义**：例如，绑定一个“标题”时，使用 `v-model:title`比默认的 `modelValue`更易读

**实现多个 v-model 绑定**：Vue 3 支持在同一个组件上使用多个 `v-model`，这是 Vue 2 无法实现的。

**父组件**示例（绑定多个 v-model）：

```vue
<UserProfile 
  v-model:name="userName"
  v-model:email="userEmail"
  v-model:age="userAge"
/>
```

**子组件**需要接收对应的 props 并声明对应的事件：

```vue
<script setup>
// 1. 接收自定义名称的 props
const props = defineProps(['name', 'email', 'age'])
// 2. 声明对应的更新事件
const emit = defineEmits(['update:name', 'update:email', 'update:age'])

const updateName = (newName) => { emit('update:name', newName) }
const updateEmail = (newEmail) => { emit('update:email', newEmail) }
const updateAge = (newAge) => { emit('update:age', newAge) }
</script>
[3,6](@ref)
```

#### ⚠️ 注意事项

- **不要直接修改 Prop**：在子组件中，绝对不要直接执行 `props.modelValue = newValue`这样的操作。这违反了单向数据流，在 Vue 3 中也会导致运行时错误。正确的做法永远是触发事件 。
- **TypeScript 支持**：你可以使用 TypeScript 为 `defineProps`和 `defineEmits`提供更严格的类型定义，以获得更好的类型安全和 IDE 支持 。

总而言之，在 Vue 3.4 之前，基于 `defineProps`和 `defineEmits`实现 v-model 是一种可靠、显式且易于理解的方式。虽然 Vue 3.4 引入的 `defineModel`宏极大地简化了这一过程 ，但理解传统方式的工作原理对于维护旧项目和理解 Vue 的数据流机制仍然至关重要。	

## 代码规范

在 Vue 3 项目中集成 TypeScript 可以显著提升代码的健壮性和开发体验。下面我将从核心规范、组件开发、工程化配置等角度，为你梳理需要注意的代码规范和书写要点。你可以参考以下表格快速了解核心规范领域。

| 规范领域               | 核心要点             | 关键注意事项                                                 |
| ---------------------- | -------------------- | ------------------------------------------------------------ |
| **组件 Props & Emits** | 使用基于类型的声明   | 使用 `defineProps<Interface>()`和 `defineEmits<Interface>()`进行编译时类型检查；可选 Props 和默认值使用 `withDefaults`。 |
| **响应式数据**         | 明确类型，善用推断   | 复杂类型用泛型或接口显式声明；简单类型可依赖自动推断；解构响应式对象使用 `toRefs`。 |
| **组合式函数**         | 泛型强化类型安全     | 输入参数和返回值定义清晰类型；使用泛型增强灵活性，如 `useFetch<T>`。 |
| **模板引用与事件**     | 避免 `any`，精确标注 | 模板引用标注为具体的 `HTMLXxxElement \| null`；事件处理函数参数使用 `Event`或更具体的类型。 |
| **工程与代码风格**     | 严格配置，统一约定   | 启用严格类型检查；限制 `any`类型使用；使用 `import type`按需导入类型；统一文件、变量命名规范。 |

### 💡 组件开发的类型安全

在组件开发中，类型是保证代码质量的第一道防线。

- **Props 与 Emits 的类型声明**：推荐使用基于类型的语法来定义组件的 Props 和 Emits，这能提供最严格的类型检查和完善的智能提示。对于需要默认值的可选 Props，应使用 `withDefaults`辅助函数。对于 Emits，可以利用函数重载的方式精确声明事件负载（payload）的类型。
- **响应式数据的类型**：使用 `reactive`初始化复杂对象时，应通过接口或类型别名来显式标注其类型，以确保深层属性的类型安全。而对于通过 `ref`创建的简单数据，可以充分利用 TypeScript 的类型推断，减少不必要的类型声明。当需要解构一个响应式对象时，务必使用 `toRefs`，以保持解构后变量的响应式及其类型。
- **模板引用与事件处理**：为模板引用（`ref`）标注类型时，对于 DOM 元素，应指定为具体的元素类型（如 `HTMLInputElement`）并与 `null`联合；对于子组件，可使用 `InstanceType<typeof MyChild>`来获取实例类型。在处理 DOM 事件时，应为事件处理函数的参数标注明确的类型，如 `Event`，并使用类型断言来精确获取目标元素。

### 🔧 工程化与架构规范

良好的工程配置和架构约定是维持大型项目可维护性的关键。

- **严格的项目配置**：在 `tsconfig.json`中启用所有严格类型检查选项（`strict: true`）。同时，配置 ESLint 规则（如 `@typescript-eslint/strict`和 `@typescript-eslint/no-explicit-any`）来限制 `any`类型的使用，确保代码的类型覆盖率。对于 `.vue`文件，需要创建正确的类型声明文件（`shims-vue.d.ts`）以确保 TypeScript 能够正确识别。
- **类型定义与复用**：为业务实体（如 User、Product）定义清晰的接口，并鼓励使用一阶类型体操（类型组合）来提升类型的灵活性和复用性。将高复用的类型定义统一存放在项目中的 `types`文件夹内，并使用 `import type ...`语法进行导入，这有助于避免潜在的循环引用问题并减少打包体积。
- **代码风格统一**： **命名规范**：变量、函数名使用驼峰式（camelCase）；类、接口、类型别名使用帕斯卡命名法（PascalCase）；组件名、文件名、CSS 类名使用短横线分隔命名（kebab-case）。 **导入顺序**：建议按以下顺序组织 `import`语句：Vue 核心库、第三方库、内部工具函数、内部组件。

### 🚀 进阶实践与性能优化

- **类型安全的组合式函数 (Composables)** ：编写自定义组合式函数时，应使用泛型来创造高度灵活且类型安全的逻辑。例如，一个通用的数据请求函数 `useFetch<T>`可以在调用时确定返回的数据类型，从而在使用处获得完美的类型推断。
- **状态管理的类型**：如果使用 Pinia 进行状态管理，在为 Store 定义状态（state）、Getters 和 Actions 时，也应显式声明其类型，特别是在跨 Store 调用时，类型提示能确保代码的正确性。
- **性能与体积优化**：对于大型不可变数据，考虑使用 `shallowRef`来减少响应式代理的开销。坚持使用 `import type ...`来导入纯类型，这有助于打包工具进行 Tree-shaking，减小最终打包体积。

### ⚠️ 常见陷阱与规避方法

1. **避免使用 `any`类型**：滥用 `any`会彻底破坏类型系统的优势。如果遇到暂时无法确定类型的情况，可以先使用 `unknown`类型，并通过类型守卫（Type Guards）进行安全的类型收缩。
2. **第三方库类型缺失**：当遇到没有类型声明的第三方库时，可以临时在 `shims.d.ts`文件中使用 `declare module`进行声明，但长期解决方案是为其编写完整的类型定义并考虑贡献给社区。
3. **单文件组件长度**：如果一个 `.vue`文件的模板部分过长（例如超过300行），应考虑将组件拆分为更小的子组件。Vue 3 的 `provide/inject`可以很好地解决深层嵌套组件间的通信问题，而无需担心 `props`逐级传递的负担。

