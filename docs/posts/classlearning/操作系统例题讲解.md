---
date: 2025-12-15
category:
  - 期末复习
tag:
  - 操作系统
---

# 操作系统核心算法例题及解析

## 第一章 概述 —— 系统调用相关例题

### 例题：fork 系统调用应用

**题目**：编写一段 C 语言代码，使用 fork () 创建子进程，分别在父进程和子进程中输出进程 ID，并说明 fork () 的返回值特点。**解析步骤**：

1. 调用 fork () 创建子进程，返回值存储在变量 pid 中。
2. fork () 返回值规则：父进程中返回子进程 ID（大于 0），子进程中返回 0，创建失败返回 - 1。
3. 通过判断 pid 值区分父、子进程，分别输出对应信息。
4. 代码实现：


```c
#include <stdio.h>
#include <unistd.h>
int main() {
    pid_t pid = fork();
    if (pid == -1) {
        perror("fork failed");
        return 1;
    } else if (pid == 0) {
        printf("子进程：PID = %d，父进程PID = %d\n", getpid(), getppid());
    } else {
        printf("父进程：PID = %d，子进程PID = %d\n", getpid(), pid);
    }
    return 0;
}
```

**输出结果**（示例）：

```plaintext
父进程：PID = 1234，子进程PID = 1235
子进程：PID = 1235，父进程PID = 1234
```

**注意事项**：子进程会复制父进程的地址空间，fork () 之后的代码会被父子进程分别执行。

## 第二章 进程与线程 —— 进程调度算法例题

### 例题：先来先服务（FCFS）调度算法

**题目**：有 3 个进程 P1、P2、P3，进入就绪队列的次序为 P1、P2、P3，CPU 周期分别为 21ms、6ms、3ms。计算平均周转时间、平均带权周转时间和平均等待时间。**解析步骤**：

1. 调度序列：按 FCFS 规则，执行顺序为 P1→P2→P3。
2. 周转时间 = 完成时间 - 进入就绪队列时间（假设均为 0）：
   - P1：21ms - 0 = 21ms
   - P2：21ms + 6ms - 0 = 27ms
   - P3：27ms + 3ms - 0 = 30ms
3. 带权周转时间 = 周转时间 / CPU 周期：
   - P1：21/21 = 1
   - P2：27/6 = 4.5
   - P3：30/3 = 10
4. 等待时间 = 周转时间 - CPU 周期：
   - P1：21 - 21 = 0ms
   - P2：27 - 6 = 21ms
   - P3：30 - 3 = 27ms
5. 平均计算：
   - 平均周转时间：(21+27+30)/3 = 26ms
   - 平均带权周转时间：(1+4.5+10)/3 ≈ 5.17
   - 平均等待时间：(0+21+27)/3 = 16ms

### 例题：信号量实现生产者 - 消费者问题

**题目**：使用信号量实现有界缓冲区（大小为 100）的生产者 - 消费者问题，要求保证缓冲区访问的互斥和同步。**解析步骤**：

1. 定义信号量：

   - mutex：互斥信号量，保护缓冲区访问，初始值 1。
   - empty：同步信号量，标识空缓冲区数量，初始值 100。
   - full：同步信号量，标识满缓冲区数量，初始值 0。

2. 生产者进程：先申请空缓冲区（P (empty)），再申请互斥锁（P (mutex)），放入数据后释放互斥锁（V (mutex)），最后通知消费者（V (full)）。

3. 消费者进程：先申请满缓冲区（P (full)），再申请互斥锁（P (mutex)），取出数据后释放互斥锁（V (mutex)），最后通知生产者（V (empty)）。

   

   代码实现

   （伪代码）：

```plaintext
#define N 100
typedef int semaphore;
semaphore mutex = 1, empty = N, full = 0;

void producer() {
    int item;
    while (TRUE) {
        item = 生产数据;
        P(empty);  // 申请空缓冲区
        P(mutex);  // 申请互斥锁
        将item放入缓冲区;
        V(mutex);  // 释放互斥锁
        V(full);   // 通知消费者有数据
    }
}

void consumer() {
    int item;
    while (TRUE) {
        P(full);   // 申请满缓冲区
        P(mutex);  // 申请互斥锁
        从缓冲区取出item;
        V(mutex);  // 释放互斥锁
        V(empty);  // 通知生产者有空位
        消费item;
    }
}
```

## 第三章 死锁 

### 银行家算法例题

**题目**：系统有 A、B、C 三类资源，总量分别为 10、5、7。当前资源分配情况如下表，判断当前系统是否安全，若安全给出安全序列。

| 进程                         | 已分配资源（A,B,C） | 最大需求（A,B,C） | 剩余需求（A,B,C） |
| ---------------------------- | ------------------- | ----------------- | ----------------- |
| P0                           | 0,1,0               | 7,5,3             | 7,4,3             |
| P1                           | 2,0,0               | 3,2,2             | 1,2,2             |
| P2                           | 3,0,2               | 9,0,2             | 6,0,0             |
| P3                           | 2,1,1               | 2,2,2             | 0,1,1             |
| P4                           | 0,0,2               | 4,3,3             | 4,3,1             |
| 当前可用资源（A,B,C）：3,3,2 |                     |                   |                   |
| **解析步骤**：               |                     |                   |                   |

1. 检查各进程剩余需求是否≤可用资源：

   - P1 剩余需求（1,2,2）≤（3,3,2），可先执行 P1。

2. 执行 P1 后，释放其已分配资源，可用资源更新为：3+2, 3+0, 2+0 =（5,3,2）。

3. 继续查找剩余需求≤当前可用资源的进程：

   - P3 剩余需求（0,1,1）≤（5,3,2），执行 P3。

4. 释放 P3 资源，可用资源更新为：5+2, 3+1, 2+1 =（7,4,3）。

5. 继续查找：

   - P0 剩余需求（7,4,3）≤（7,4,3），执行 P0。

6. 释放 P0 资源，可用资源更新为：7+0, 4+1, 3+0 =（7,5,3）。

7. 继续查找：

   - P2 剩余需求（6,0,0）≤（7,5,3），执行 P2。

8. 释放 P2 资源，可用资源更新为：7+3, 5+0, 3+2 =（10,5,5）。

9. 最后执行 P4，剩余需求（4,3,1）≤（10,5,5），执行完成。

   安全序列：P1→P3→P0→P2→P4，当前系统安全。

   

### 多资源死锁检测

**题目**：系统有 3 个进程（P0、P1、P2）和 4 类资源（磁带机、绘图仪、扫描仪、CD-ROM），资源总量 \(E=(4,2,3,1)\)。当前资源分配情况如下：

- 可用资源向量 \(A=(2,1,0,0)\)

- 分配矩阵C（行：进程，列：资源）：$  C=\begin{bmatrix}  0 & 0 & 1 & 0 \\  2 & 0 & 0 & 1 \\  0 & 1 & 2 & 0  \end{bmatrix} $

- 请求矩阵R（行：进程，列：资源）：$ R=\begin{bmatrix}  2 & 0 & 0 & 1 \\  1 & 0 & 1 & 0 \\  2 & 1 & 0 & 0  \end{bmatrix} $

  

  判断系统是否存在死锁，若存在，指出死锁进程。

**解析步骤**：

1. 初始化：标记所有进程为 “未完成”，可用资源 \(A=(2,1,0,0)\)。

2. 遍历所有未完成进程，检查是否满足$ R[i] \leq A$：

   - P0 请求 \((2,0,0,1)\)，可用资源 \((2,1,0,0)\) 不满足（CD-ROM 资源不足）；

- P1 请求 \((1,0,1,0)\)，可用资源 \((2,1,0,0)\) 不满足（扫描仪资源不足）；
  - P2 请求 \((2,1,0,0)\)，可用资源 \((2,1,0,0)\) 满足。

3. 标记 P2 为 “完成”，释放其已分配资源，可用资源更新为：\(A + C[2] = (2+0,1+1,0+2,0+0) = (2,2,2,0)\)。

4. 再次遍历未完成进程（P0、P1）：

   - P0 请求 \((2,0,0,1)\)，可用资源 \((2,2,2,0)\) 不满足（CD-ROM 资源不足）；
   - P1 请求 \((1,0,1,0)\)，可用资源 \((2,2,2,0)\) 满足（1≤2，0≤2，1≤2，0≤0）。

5. 标记 P1 为 “完成”，释放其已分配资源，可用资源更新为：\((2,2,2,0) + C[1] = (2+2,2+0,2+0,0+1) = (4,2,2,1)\)。

6. 最后遍历未完成进程（P0）：

   - P0 请求 \((2,0,0,1)\)，可用资源 \((4,2,2,1)\) 满足（2≤4，0≤2，0≤2，1≤1）。

7. 标记 P0 为 “完成”，所有进程均完成，**系统无死锁**。

### 变式（存在死锁场景）：

若可用资源初始为 \(A=(1,1,0,0)\)，重复上述步骤：

1. 第一步无进程满足 \(R[i] \leq A\)，未完成进程为 P0、P1、P2；

2. 无新进程可完成，剩余进程均无法推进，**系统存在死锁，死锁进程为 P0、P1、P2**。

   

## 第四章 存储管理 —— 页面置换算法例题

### 例题：LRU 页面置换算法

**题目**：某程序分配 3 个页框，初始为空，页面走向为 4,3,2,1,4,3,5,4,3,2,1,5。计算缺页次数和缺页率。**解析步骤**：

1. 页框初始状态：[]
2. 按页面走向逐次处理，记录页框变化和缺页情况（× 表示缺页）：
   - 4：[]→[4]，缺页（×1）
   - 3：[4]→[4,3]，缺页（×2）
   - 2：[4,3]→[4,3,2]，缺页（×3）
   - 1：[4,3,2]→[1,3,2]（淘汰最近最少使用的 4），缺页（×4）
   - 4：[1,3,2]→[1,4,2]（淘汰最近最少使用的 3），缺页（×5）
   - 3：[1,4,2]→[1,4,3]（淘汰最近最少使用的 2），缺页（×6）
   - 5：[1,4,3]→[5,4,3]（淘汰最近最少使用的 1），缺页（×7）
   - 4：[5,4,3]→[5,4,3]（命中，无缺页）
   - 3：[5,4,3]→[5,4,3]（命中，无缺页）
   - 2：[5,4,3]→[5,2,3]（淘汰最近最少使用的 4），缺页（×8）
   - 1：[5,2,3]→[1,2,3]（淘汰最近最少使用的 5），缺页（×9）
   - 5：[1,2,3]→[1,2,5]（淘汰最近最少使用的 3），缺页（×10）
3. 缺页次数 = 10 次，总访问次数 = 12 次。
4. 缺页率 = 10/12≈83.3%

### 例题：可变分区首次适配算法

**题目**：内存空闲分区为：2K、4K、20K、10K、8K、5K（按地址从低到高排列）。现有一进程申请 6K 内存，使用首次适配算法分配后，空闲分区变为多少？**解析步骤**：

1. 首次适配算法：从内存起始位置查找第一个能容纳申请大小的空闲分区。
2. 遍历空闲分区：2K（不足 6K）→4K（不足 6K）→20K（满足 6K）。
3. 分配 6K 后，20K 空闲分区剩余：20K - 6K =14K。
4. 分配后空闲分区顺序：2K、4K、14K、10K、8K、5K。



### 例题：段页式虚拟地址到物理地址转换

**题目**：某系统采用段页式存储管理，虚拟地址结构为：段号（2 位）+ 页号（3 位）+ 页内偏移（9 位）。已知：

- 页大小 = \(2^9 = 512\) 字节；

- 段表（每个进程 1 张）：

  

  | 段号 | 段长（页数） | 页表始址（物理地址） | 段存在位 |

  

  |------|--------------|----------------------|----------|

  

  |     0    |           4            |           10240               |        1        |

  

  |     1    |           3            |            20480              |         1        |

  

  |     2    |           5             |           30720               |         0        |

  

  |      3    |          2             |           40960                |        1        |

- 段 0 的页表（页表项：页框号 + 存在位）：

  

  | 页号 | 页框号 | 存在位 |

  

  |------|--------|--------|

  

  |    0     |     15     |     1     |

  

  |     1     |     23     |     1     |

  

  |     2     |     37     |     1     |

  

  |     3     |     42     |     1     |

  

  现有虚拟地址：01 011 101001100（二进制），将其转换为物理地址。

**解析步骤**：

1. 拆分虚拟地址各字段：
   - 段号（前 2 位）：01（二进制）= 1（十进制）；
   - 页号（中间 3 位）：011（二进制）= 3（十进制）；
   - 页内偏移（后 9 位）：101001100（二进制）= 332（十进制）。
2. 查段表（段号 = 1）：
   - 段存在位 = 1（段已调入内存）；
   - 段长 = 3 页，页号 = 3 > 段长 - 1=2，**段内页号越界，抛出越界中断**。

**修正虚拟地址**（无越界场景）：

虚拟地址：00 010 101001100（二进制），拆分后：

- 段号 = 00（十进制 0），页号 = 010（十进制 2），页内偏移 = 332。

1. 查段表（段号 = 0）：
   - 段存在位 = 1，段长 = 4 页，页号 = 2 ≤ 3（合法），页表始址 = 10240。
2. 计算页表项地址：
   - 每个页表项占 4 字节（假设），页表项偏移 = 页号 ×4 = 2×4=8；
   - 页表项物理地址 = 页表始址 + 偏移 = 10240 + 8 = 10248。
3. 查段 0 的页表（页号 = 2）：
   - 页框号 = 37，存在位 = 1（页已调入内存）。
4. 计算物理地址：
   - 物理地址 = 页框号 × 页大小 + 页内偏移 = 37×512 + 332；
   - 计算：37×512=18944，18944+332=19276（十进制）；
   - 转换为十六进制：19276 → 0x4B4C。

**最终物理地址**：19276（十进制）或 0x4B4C（十六进制）。

## 第五章 文件系统 —— 磁盘空间管理例题

### 例题：位图法管理磁盘空间

**题目**：某磁盘有 32 个扇区（编号 0-31），位图中每一位对应一个扇区（0 表示空闲，1 表示占用）。当前位图为：10011011011011000110111101110111（从高位到低位对应扇区 0-31）。请找出所有空闲扇区编号。**解析步骤**：

1. 将位图按每一位对应扇区编号（高位对应扇区 0，低位对应扇区 31）。
2. 逐位解析位图，值为 0 的位对应的扇区为空闲：
   - 位图二进制：1 0 0 1 1 0 1 1 0 1 1 0 1 1 0 0 0 1 1 0 1 1 1 1 0 1 1 1 0 1 1 1
   - 对应扇区 0-31，空闲扇区（值为 0）编号：1、2、5、8、11、14、15、16、19、24、28
3. 最终空闲扇区：1、2、5、8、11、14、15、16、19、24、28。

## 第六章 设备管理 —— 磁盘臂调度算法例题

### 例题：SCAN（电梯）调度算法

**题目**：磁盘有 0-35 共 36 个柱面，当前磁头在 10 号柱面，且正在向柱面号增大的方向移动。当前等待的磁盘 I/O 请求柱面号为：1、36、16、34、9、12。计算磁头移动的总柱面数。**解析步骤**：

1. SCAN 算法：磁头按当前方向移动，依次处理沿途请求，到达边缘后反向。
2. 当前磁头位置 10，方向：增大，请求队列：1、36、16、34、9、12。
3. 按方向筛选并排序请求（≥10）：12、16、34、36。
4. 处理顺序：10→12（移动 2）→16（移动 4）→34（移动 18）→36（移动 2）。
5. 到达 36（最大柱面），反向（向减小方向），剩余请求：9、1。
6. 处理顺序：36→9（移动 27）→1（移动 8）。
7. 总移动柱面数：2+4+18+2+27+8=61。