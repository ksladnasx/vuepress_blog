ONF 提出的 SDN 三层框架包括哪三层？并简述各层的作用。

・应用层、控制层、基础设施层。

应用层包含了网络所要承载的多元业务与应用，通过调用控制层提供的应用程序接口，支持实现弹性的上层应用与业务；

控制层相当于 SDN 网络的 "大脑", 起到承上启下的作用，一方面通过 API 为上层网络应用提供编程接口，另一方面通过控制数据平面接口 (CDPI) 对基础设施层的网络设备进行统一的配置、管理与控制器 等信息。

在 SDN 体系结构中，四个平面指的是什么？请分别简述这四个平面的功能或任务。(1) 数据平面：居路径 (SDN Datapath) (Network Element, 负责数据包或流的发和处理 松 SDN 数据路径是 逻辑上的网络设备，关键 力 代理 NBI 改皮从数据(3) 应用平面(4) 管理平面：负责网元的初始化配置，SDN 控制器及应用的控制范围等静态工作 指定 SDN Datapath 控制器，定义

什么是流表？OpenFlow 交换机中的流表与传统交换机的转发表有什么不同？(1) OpenFlow 交换机的流表指的是特定流的转发策略表项的集 是 OpenFlow 交换机中对数据转发逻辑的 的核心数据结构，由一系列具有优先级顺序的流表项构成 不仅包含了传统网络设备中 MAC 地址表、路由表中的相关信息 含了更多层次与类型的网络特征信息，集交换机、路由器、防火墙等功能于一也是 OpenFlow 交换机 流表项中 还包 使得一个 OpenFlow 交换机可以(2) 相比于传统交换机的转发表只包含 MAC 地址与端口的映射 OpenFlow 交换机的流表项中包含了更丰富的字段，其中涵盖了 OSI 网 0 模型中 2-4 层的网络特征；此外，OpenFlow 交换机的数据转发处理 象成通用的匹配 (Match)- 动作 (Action) 过程，配到相应字段后会执行对应的动作表中的动作，区别于传统交换机每个流表项在

OpenFlow 交换机模型包含哪三个必要组成部分？分别简述它们的作用，并画出该架构模型。(1) 流表：由若干流表项构成，每个动作关联一个流表项，指示 交换机如何进行流的处理。(2) 安全通道：OpenFlow 交换 机通过安全通道与远端控制器连 接，负责控制器与交换机之间的 交互。(3) OpenFlow 协议：定义了 种南向接口标准，为控制器与交 换机之间的通信提供了一种开放 标准。

OpenFlow 交换机模型包含哪三个必要组成部分？分别简述它们的作用，并画出该架构模型。(1) 流表：由若干流表项构成，每个动作关联一个流表项，指示 交换机如何进行流的处理。(2) 安全通道：OpenFlow 交换 机通过安全通道与远端控制器连 负责控制器与交换机之间的 交互。(3) OpenFlow 协议：定义了 种南向接口标准，为控制器与交 换机之间的通信提供了一种开放 标准。

Features 和 Packet-in 消息分别属于哪种消息类型？它们有何作用？简述它们如何触发及触发后的信息交互？Features 消息属于 Controller-to-Switch 消息类型，用于获取交换机的特性或属性信息，在建立传输安全会话后，控制器主动向交换机发送 Features-request 消息，请求交换机特性，交换机通过 Features-reply 消息回复自身所支持的功能特性；Packet-in 消息属于 Asynchronous 类型，用于告知控制器新数据包的到达，如果数据包在流表中没有匹配项，或者匹配的流表项中指定端口为 CONTROLLER 的动作时，交换机将发送 Packet-in 消息给控制器 控制器通过发送 Packet-out 消息指导交换机进行数据处理

在 OpenFlow 协议中，Flow-mod 消息属于哪种消息类型？简述其作用，并说明该消息哪种情况会被触发？(1) Flow-mod 消息属于 Controller-to-Switch 消息类型。(2) Flow-mod 消息用于修改交换机的状态消息，如增加、删除和修改交换机的流表项、组表项及端口状态。(对交换机的流表进行配置，包括增、删、改等)。(3) 控制器主动下发流表时，或者当流表匹配失败，交换机发送 packet-in 消息给控制器后，控制器通过 Flow-mod 消息下发流表时。

简述 SDN 架构下网络链路发现的过程，并以 1 个控制器 + 2 个交换机为例画出 LLDP 链路发现过程示意。控制器发送带 LLDP 的 packet_out 消息给与之相连的每个交换机，要求交换packet-out 消息之后就会执行控制器去); 由此，每个交换机将收到发送 P 并向控制器发送 packet-in 消息，制器收到 packet-in 消息之后进行解 由此创建交换机之间两两链接的ControllerPacket out 带 LLDP 的 带 LLDP 的 Packet outPacket Int广播 LLDP

南向网络控制是 SDN 控制器中起核心作用的基础功能，请列举其中三个南向网络控制功能，并分别解释其具体作用。表项下发 机，指导具体转发行为

请分别指出如下 RESTCONF 消息中的方法、入口、资源、HTTP 头，并说明资源的类型和数据格式；此外，请在消息的查询部分使用参数来替代 Accept 头中对数据格式的约束 (写出替换后的 RESTCONF 消息)?GET /.well-known/restconf/datastore/example-routing:routing HTTP/1.1 Host: [example.com](https://example.com/) Accept: application/vnd.yang.data+json・方法：GET 入口:/.well-known/restconf/ 资源:datastore/example-routing:routing HTTP 头:[Host:example.com](https://host:example.com/) Accept application/nd.yang.data+json 资源的类型是数据存储资源、数据格式为 json 替换后的消息: GET /.well-known/restconf/datastore/example-routing:routing?format=json HTTP/1.1 Host: [example.com](https://example.com/)

在 Ryu 控制器编程中，二层自学习交换机涉及哪些 OpenFlow 消息？需要对哪些类型的 OpenFlow 事件设置监听处理？各事件分别属于通信的哪个阶段？(1) Features 消息、Packet-in、Packet-out 消息，还可能用到 Flow-mod 消息(2) EventOFPFeatures 类型和 EventOFPPacketIn 类型事件。(3) CONFIG_DISPATCHER 和 MAIN_DISPATCHER

在 SDN 中，北向接口的主要功能体现在哪两方面？基于意图的北向 API 与功能型北向 API 的主要区别有哪些。(1) 为上层业务应用提供网络资源与基础功能抽象；为上层应用和网络管控提供可编程的开发接口。(2) 基于意图的 API: 基于自上而下的网络视角和方法，重点在满足上层应用与业务实现逻辑和服务质量的需求，关注的是 "应用需要什么";功能型北向 API: 基于自下而上的网络视角和方法，重点在网络资源抽象及控制能力的开放，关注 "网络能提供什么"

在 POX 控制器编程中，二层自学习交换机涉及哪些 OpenFlow 消息？请画 (写) 出其数据包处理流程。(1) Features 消息、Packet-in、Packet-out 消息，还可能用到 Flowmod 消息(2) 如图图 5.17 二层自学习交换机组件的数据包处理流程

1、如图给出了 SDN 方式下控制器与交换机之间的通信流程示意图，请回答如下问题:(1) 控制器与交换机之间的安全通道的作用是什么？OpenFlow 协议版本的协商是在哪个消息中完成？(2 分)(2) 图中 1、2、3、4 为必选操作，请对应写出各消息。 除 5 号操作所在的正常通信环节，该图所示的通信流程还包含了哪些环节？(3 分)(3) 在正常通信环节执行 pingall 时，5 号箭头表示的消息可能有哪两种？((1 分)(4) 假设图中的控制器为 Ryu, 请使用 curl 命令调用 REST API 创建一条流表:dpid 为 2, 优先级为 100, 匹配项为 1 号端口入、动作为 2 号端口出，数据类型为 json, url 为http://localhost:8080/stats/flowentry/add.(2 分)(5) 收到 (4) 中 REST API 调用之后，控制器会触发什么消息？该消息的作用是什么？Controller4SET CONFIGGET CONFIG REQUESTGET CONFIG REPLY正常通信(2 分)全通道用传输 0pow 的控制协议消息。penFiow 协议版本的协商在 Helo 消意建度的特 EEUT 环节有(3) PACKET-IN、FLOW_MOD (4) curl-XPOST-d"match"{ "dpid":2. "priority: 100."in_port":1"actionstype"OUTPUT", "port":2http://localhost:8080/stats/lowentry/add (5) FLOW_MOD。其作用是对交换机的流表进行配置，包括增、删、改等。

2、结合如下 NETCONF 操作示例，回答以下问题

```xml
<rpc message-id="1" xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"> 
    <get-config xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
        <source>
            <running/>
        </source>
        <filter type="xpath"select="/capable-switch"/>
    </get-config>
</rpc>
```

(1) 本示例的操作类型是什么？配置的数据库对象是什么？(2 分)

(2) NETCONF 协议定义了哪三种数据库？请结合数据库的操作解释三种数据库的作用及其相互转化关系。(3 分)

(3) 请写出 RESTCONF 中 GET、PUT、POST、DELETE 对应的 NETCONF 操作。(2 分)

(4) 请使用 RESTCONF 消息格式获取数据存储资源中的 json 类型数据，要求分别使用查询字段和 HTTP 头两种方式约束 json 数据类型。(3 分)

答案：

(1)<get-config>    <running/>

(2)  三种数据库及其转化关系：

<running/>数据库：用以描述目前在设备上运行生效配置，包括当前设备上可用的所有 概念状态信息。

<candidate/>数据库：用来存放可能被调用或生效的候选 (备选) 配置信息，对该数据库的任何改变都不会立即直接影响网络设备，可用于反复配置测试。 

<startup/>数据库：用于保存当前运行的配信息，供设备重启后快速恢复运行的网络配置。

 <candidate/>数据库可以通过<edit-config>进行反复配置；通过在<candidate/>数据库上执行<commit>操作可将<candidate/>数据库的内容生效到<running/>数据库；此外通过<copy-config/>操作可以将<running/>数据库中的内容覆盖<startup/>数据库。 

 (3)<get-config>、<edit-config>(operation="replace")、<edit-config>(operation="create")、<edit-config>(operation="delete")

(4) 方式一：

GET /.well-known/restconf/datastore?format=json HTTP/1.1

Host: example.com  

方式二：

GET /.well-known/restconf/datastore HTTP/1.1

Host: example.comAccept: application/nd.yang.data+json

3、结合如下代码，理解分析 Ryu 控制器组件编程

 (1) RYU 组件继承于哪个类？该类的作用是什么？(2 分) 

(2) 请结合代码解释 set_ev_cs" 的作用及各参数的意义。(3 分)

 (3) 请从该 packet_inhandler 函数中的实现中总結 Ryu 组件编程中 Packet-in 消息的主要处理过程 (即解析其中的主要代码语句)。(5 分)

```py
	@set_ev_cls(ofp_eventEventOFPPacketin.MAIN_DISPATCHER)
def packet in handler (self.ev):
    msg = ev.msg
    dp = msg.datapath
    ofp = dp.ofproto
    ofp_parser = dp.ofproto_parser
    
    actions = [ofp_parser.OFPActionOutput(ofp.OFPP_FLOOD)]
    
    data = None
    if msg.buff_id == ofp.OFP_NO_BUFFER:
        data = msg.data 
      
    out = ofp_parser.OFPPacketOut(
        datapath = dp
        buffer_id = msg.buffer_id
        in_port = msg.in_port
        actions = actions
        data = data
    )
    
dp send_msg (out)
```

(1) Ryu 组件继承于 RyuApp 类。它是 Ryu 应用组件的抽象功能描述类 为应用开发提供基本的模板，用于完成 Ryu 应用所需要完成的基本操作。

(2)"set_ev_cls" 用于修饰一个事件处理函数，当某个事件消息触发后，对应的时间处理函数就会被调用。即，当 Ryu 控制器收到修饰器中第一个参数所指示的消息，将调用下面对应的 handler 处理函数。代码中，ofp_event.EventOFPPacketIn 表示的是事件消息类型，MAIN_DISPATCHER 指示接收该事件消息的阶段，packet_in_handler 是对应的消息处理函数。

(3) 获取 OpenFlow Packet-in 消息对象 ev.msg--msg.datapath 获取 Packet-in 消息发自于哪个 datapath (或 switch)-- 获取 openflow 协议编解码器 dp.ofproto_parser-- 使用 dp.ofproto_parser 中的 OFPActionOutput 方法定义 packet-out 动作 -- 使用 ofp_parser.OFPPacketOut 构造 packet-out 消息 -- 使用 dp.send_msg 将该 packet-out 消息发送到交换机。

4、根据如下 RESTCONF 操作示例，回答以下问题:

GET /.well-known/restconf/datastore/example-routing:routing HTTP/1.1

Host: example.com

Accept: application/vnd.yang.data +json

(1) 本示例中，RESTCONF 操作的方法、入口、资源、HTTP 头分别是什么？(2 分)

(2) 本示例操操作的是什么类型的数据资源？数据格式是什么；(2 分)

(3) 请在消息的查询部分使用参数来替代 Accept 头中对数据格式的约束 (写出替换后的 RESTCONF 消息)?(2 分)

(4) 假设图中的控制器为 Ryu, 请使用 curl 命令调用 REST API 创建一条流表:dpid 为 2, 优先级为 100, 匹配项为 1 号端口入、动作为 3 号端口出，数据类型为 json,url 为http://localhost:8080/stats/flowentrv/add.(4 分)

(1) 方法：GET

入口:   /.well-known/restconf/ 

资源:datastore/example-routing:routing 

HTTP 头:Host:example.com

Accept: application/nd.yang.data+json

(2) 资源的类型是数据存储资源、数据格式为 json

(3)替换后的消息

GET /.well-known/restconf/datastore/example-routing:routing?format=json HTTP/1.1

Host:example.com

(4) 

```cmd
curl -X POST -d '{
"dpid":2,
"priority": 100,
"match": {
"in_port":1ados"type",
}

"actions":[{

"type":"OUTPUT",

 "port":3

}]
}' http://localhost:8080/stats/flowentry/add
```

实验中发现的问题：对 SDN 方式下的通信流程和流表的理解不透彻流表的增删改查对 ping 的影响及数据包匹配 - 动作的变化

| 动作                     | 操作                                                         |
| ------------------------ | ------------------------------------------------------------ |
| 查看节点和连接信息       | 分别输入 nodes和 1inks 查看节点及端口连接情况                |
| 查看流表                 | 使用 dpctl  dump-flows 命令查看当前流表项                    |
| 执行 pinga11             | 先执行 pingall 命令，检查网络连通性，停查看流表 项，观察流表项并解释 |
| 删除所有流表             | 使用 dpctl  del-flows 命令删除流表，然后查看。               |
| 添加流表                 | 执行 dpctl  add-flow in_port \(=1\), actions=out put:2 , 然后查看：再次增加从 2 号端口进，1 号端口出的流表，查看结果。 |
| 测试两两节点之间的连通性 | 使用・ping 命令，查看当前流表下某两个节点是否连通            |