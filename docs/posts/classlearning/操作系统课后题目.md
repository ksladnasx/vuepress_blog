---
date: 2026-01-03
category:
  - 期末复习
tag:
  - 操作系统
sticky: true
---

# 操作系统书后习题

## 第一章

**1. 操作系统两大主要作用？**

- 管理 CPU、内存、I/O 设备等硬件资源；
- 为用户 / 应用程序提供便捷的硬件抽象接口。

**3. 分时系统和多道程序系统的区别？**

- 分时系统：按时间片轮转调度，支持多用户交互，响应快；
- 多道程序系统：多个程序并发执行，仅提升 CPU 利用率，无交互性。

**6. 为何 I/O 指令是特权指令？** 

防止用户程序错误控制 I/O 设备，避免破坏硬件或系统资源，保障系统稳定性。

**10. 内核态与用户态的区别及设计意义？**

- 区别：内核态可执行所有指令（含特权指令）、访问所有资源；用户态仅能执行非特权指令、访问受限资源；
- 意义：隔离用户程序与系统核心，防止用户程序破坏系统，提升安全性与稳定性。

**12. 以下哪些是只能在内核态使用的指令？（选项：a 禁止所有中断、b 读时钟、c 设置日期 - 时间时钟、d 改变存储映像）**

答案：(a)、(c)、(d)

用户态能执行的指令，核心特征：**仅作用于进程自身内存 / 数据，不影响系统全局、不操控硬件、执行错误只会让自身进程崩溃，不会导致系统故障**，具体包含：

1. 所有**基础数据运算指令**：加减乘除、逻辑运算、位运算等；
2. 所有**进程自身数据的读写指令**：读写本进程虚拟地址空间内的变量、数组、文件缓冲区等（✅ 可写，不是只读）；
3. 所有**程序流程控制指令**：条件判断、循环、函数调用 / 返回、跳转等；
4. 部分**只读式系统信息获取指令**：仅读取时钟时间、系统版本等无修改权限的基础信息

**13. 4 个程序 P1 (10ms)、P2 (20ms)、P3 (5ms)，在 2 个 CPU + 超线程的系统中运行，总运行时间？**

情况一：20ms（P1与P3在一个CPU上执行，P2 需 20ms在另外一个CPU上执行，两个CPU并行执行）

情况二：25ms( P2与P3在一个CPU上执行，P1在另外一个CPU上执行)

情况三：30ms   ;   情况四：35ms

**23. 有一个文件,其文件描述符是fd,内含下列字 节序列:3, 1, 4, 1,5,9, 2, 6,5,3,5. 有如下系统调用: Iseek(fd, 3, SEEK_SET); read(fd, &buffer, 4); 其中Iseek调用寻找文件中的字节3。在读操作 完成之后,buffer 中的内容是什么?**

1. `lseek(fd, 3, SEEK_SET)` 含义（必考）

`SEEK_SET` 表示 **从文件开头绝对偏移**，偏移 3 字节 = 把文件读写指针，定位到「文件索引为 3 的字节的位置」

👉 操作系统中，文件字节的索引（位置编号）**永远从 0 开始**，这是铁律！

2. `read(fd, &buffer, 4)` 含义（必考）

从指针定位的位置开始，**连续向后读取 4 个字节**，存入 buffer 中；只要文件剩余字节数足够，就直接读，✅ 无跳跃、✅ 无循环，是最基础的连续读取规则。则是从1开始，读四个字节。

答案：1、5、9、2

**27. 进程的地址空间与物理内存分离的好处？**

1. 进程地址空间隔离，防止进程间数据破坏，提升安全性；
2. 支持虚拟内存，使进程可使用超过物理内存的地址空间，提升内存利用率。



## 第二章

**1. 进程三状态（就绪、运行、阻塞）的剩余两种转换是否可能？**

不可能，剩余转换为 “就绪→阻塞” 和 “阻塞→运行”：

- 就绪→阻塞：就绪进程**未获得 CPU 使用权**，无法主动发起 I/O 等阻塞操作，无法直接转换；
- 阻塞→运行：阻塞进程需先完成等待事件（如 I/O 完成），转为就绪态后，再由调度器选中才能进入运行态，不能直接转换。

**6. 已知 RAM4GB（OS 占 512MB），进程各占 256MB，求使 CPU 利用率达 99% 的最大 I/O 等待时间占比？**

1. 计算可用内存：4GB - 512MB = 3584MB，最多同时运行进程数为 3584MB ÷ 256MB = 14 个；
2. CPU 利用率公式：1 减去每个进程 I/O 等待占比的 14 次方，结果需大于等于 99%（即 1 - p 的 14 次方 ≥ 0.99）；
3. 推导得 p 的 14 次方 ≤ 0.01，计算后 p 约等于 0.72，故最大 I/O 等待时间占比约 72%。

**9. 如何用多线程优化从镜像服务器下载 2GB 大文件的时间？**

1. 拆分文件：将 2GB 文件分成多个连续的字节块，每个块对应一个镜像服务器；

2. 并行下载：创建多个线程，每个线程向对应的镜像服务器发起请求（指定块的起始和结束字节），同时下载各自负责的块；

3. 合并文件：所有线程下载完成后，将各个字节块按原文件顺序拼接，生成完整文件

   核心优势：充分利用多服务器的带宽资源，减少单线程下载的等待时间，提升整体下载效率。

**18. 用户态实现线程的最大优缺点是什么？**

- 最大优点：线程切换在用户态完成，不需要内核参与，切换开销小（无需切换内核态 / 用户态，上下文保存和恢复操作简单）；
- 最大缺点：***内核无法感知用户级线程的存在***，若一个用户级线程因 I/O 等操作阻塞，整个进程的所有用户级线程都会被阻塞；且无法利用多核 CPU（内核按进程调度，同一进程的用户级线程只能在一个 CPU 核心上运行）。

**27. 用户级线程和内核级线程的栈，是每个线程一个栈还是每个进程一个栈？**

- 用户级线程：每个线程一个栈。因为用户级线程是**进程内独立的执行流**，需要独立的栈存储局部变量、函数调用上下文等，确保执行互不干扰；
- 内核级线程：每个线程一个栈。内核级线程是**内核直接调度的独立实体**，每个线程需具备独立的用户栈（用于用户态执行）和内核栈（用于内核态处理中断、系统调用等操作）。

**36. 快餐店雇员（领班→厨师→打包员→收银员）的进程通信模型是什么？与 UNIX 的联系？**

- 通信模型：流式管道通信。数据按 “领班→厨师→打包员→收银员” 的顺序，单向、有序传递，前一个环节的输出作为后一个环节的输入；
- 与 UNIX 的联系：UNIX 系统中的管道（pipe）就是基于该模型实现的，用于进程间单向、顺序的字节流通信（例如父子进程间通过管道传递数据）。

**39. 代码中连续执行两次 fork ()，会创建多少个子进程？**

共创建 3 个子进程，原理如下：

1. 第一次 fork ()：父进程创建 1 个子进程，此时系统中共有 2 个进程（父进程、子进程 1）；
2. 第二次 fork ()：当前的 2 个进程（父进程、子进程 1）**都会执行 fork ()**，各自创建 1 个子进程（子进程 2、子进程 3）；
3. 总进程数为 2 的 2 次方 = 4 个，减去原始的 1 个父进程，最终子进程数为 3 个（公式：**2 的 n 次方 - 1，n 为 fork () 执行次数**）。

**44. 作业运行时间分别为 9、6、3、5、X，按什么顺序运行能得到最短平均响应时间？（依 X 取值而定）**

采用短作业优先（SJF）调度算法，按作业运行时间升序排列，分情况如下：

- 若 X≤3：顺序为 X、3、5、6、9；
- 若 3＜X≤5：顺序为 3、X、5、6、9；
- 若 5＜X≤6：顺序为 3、5、X、6、9；
- 若 6＜X≤9：顺序为 3、5、6、X、9；
- 若 X＞9：顺序为 3、5、6、9、X。

**45. .有5个批处理作业A~E,它们几乎同时到达一 个计算中心。作业 A (运行时间 10，优先级 3)、B (6，5)、C (2，2)、D (4，1)、E (8，4)（优先级 5 最高），计算各调度算法的平均周转时间（作业到达时间均为 0，周转时间 = 完成时间 - 到达时间）？**

对于轮转法,假设系统具有多道程序处理能力, 每个作业均公平共享CPU时间,对

- **轮转法**（时间片 = 1）每个作业均公平共享CPU时间,：

  因为是它们几乎同时到达一 个计算中心，因此顺序没影响，就是按最小的时间片来，记为 t，**t 趋近于0**

  第n轮，按顺序每个减去t，最小的C完成，则A的完成时间是`5 (n-1) t+mt`（前面经历了（n-1）轮，每轮用时5t ,m表示每一轮A是第m个减t的） ，`nt = 2`；

  显然A的完成时间是`5nt - (5-m)t `,   (5-m) 是一个有理数而t趋近于0， 则A的完成时间是可记为5nt ，约为10，为A的完成时间。

  此时D剩下2为最小，接下来的过程一样的，剩下四个，直到最小的D完成，则完成时间是`10+2*4=18 `（队列只剩四个，每轮是4t）。

  以此类推。总周转时间是`10+8+6+4+2= 30`。

  注意此处要是指定了时间片为1或者其他的，就按这个方法来不过不用极限了。时间片轮转就是一个队列轮转着来。

  如果每个作业到达时间不一样，优先级有影响。例如此时是`p1->p2->p3` ,在运行p3，p3结束后放入队尾的时候如果p4进入，要对比p3和p4的优先级。如果如果优先级`p4<p3`,则此时队列是`p4->p3->p2->p1`  ；优先级`p4>p3`，则此时队列是`p3->p4->p2->p1`。

  

- 优先级调度（**按优先级从高到低**）：

  执行顺序：B、E、A、C、D；

  完成时间：B (6)、E (14)、A (24)、C (26)、D (30)；

  平均周转时间：(6+14+24+26+30)÷5=20；

  

- 先来先服务（按 A、B、C、D、E 顺序）：

  完成时间：A (10)、B (16)、C (18)、D (22)、E (30)；

  平均周转时间：(10+16+18+22+30)÷5=19.2；

  

- 最短作业优先（按运行时间从短到长）：

  执行顺序：C、D、B、E、A；

  完成时间：C (2)、D (6)、B (12)、E (20)、A (30)；

  平均周转时间：(2+6+12+20+30)÷5=14。
  
  
  
- 高响应比优先（HRRN）：选择 “响应比最高” 的进程（响应比 =（等待时间 + 运行时间）/ 运行时间）

**47. 系统中有 2 个周期 5ms（CPU 时间 1ms）的电话任务，1 个周期 33ms（CPU 时间 11ms）的视频流任务，实时系统是否可调度？**采用速率单调调度（RMS）判断，可调度，步骤如下：

1. 计算各任务的 CPU 利用率：
   - 每个电话任务利用率：1ms÷5ms=0.2；
   - 视频流任务利用率：11ms÷33ms≈0.333；
   - 总利用率：0.2+0.2+0.333=0.733；
2. RMS 最大可调度利用率（3 个任务）：3×(2 的三分之一次方 -1)≈0.78；
3. 因总利用率 0.733≤0.78，故系统可调度。

### 线程的定义和作用；线程与进程的联系与区别、线程的类型

- 线程（轻量级进程 LWP）

  - 定义：进程内的 “执行单元”，是 OS 调度的基本单位（比进程更小，开销更低）。
  - 作用：减少进程切换开销，提高并发效率（如浏览器的多个标签页对应多个线程，共享浏览器进程的资源）。

- 线程与进程的联系与区别

  | 维度     | 进程                                 | 线程                                  |
  | -------- | ------------------------------------ | ------------------------------------- |
  | 资源分配 | 资源分配的基本单位（有独立地址空间） | 不分配资源（共享所属进程的资源）      |
  | 调度     | 调度的基本单位（早期 OS）            | 调度的基本单位（现代 OS）             |
  | 切换开销 | 大（需切换地址空间、资源上下文）     | 小（仅切换执行上下文，如 PC、寄存器） |
  | 并发性   | 进程间并发                           | 进程内线程并发 + 进程间并发           |
  | 生命周期 | 独立（父进程终止不影响子进程）       | 依赖进程（进程终止，线程全部终止）    |
  | 通信方式 | 需进程通信（共享存储、消息传递）     | 直接共享进程资源（全局变量、文件）    |

- 线程的类型

  1. 用户级线程（ULT）
     - 管理主体：用户态线程库（如 POSIX 线程库），OS 内核不感知线程存在。
     - 优点：切换开销小（用户态完成），灵活；缺点：一个线程阻塞，整个进程阻塞（内核只调度进程）。
  2. 内核级线程（KLT）
     - 管理主体：OS 内核，每个线程对应一个内核线程（KT）。
     - 优点：线程阻塞不影响其他线程，并发效率高；缺点：切换开销大（需内核态）。
  3. **混合级线程**：用户级线程映射到内核级线程（如 N:M 映射），兼顾灵活性和并发效率（现代 OS 常用）。

### 信号量实现生产者 - 消费者问题

**题目**：使用信号量实现有界缓冲区（大小为 100）的生产者 - 消费者问题，要求保证缓冲区访问的互斥和同步。**解析步骤**：

1. 定义信号量：

   - mutex：互斥信号量，保护缓冲区访问，初始值 1。
   - empty：同步信号量，标识空缓冲区数量，初始值 100。
   - full：同步信号量，标识满缓冲区数量，初始值 0。

2. 生产者进程：先申请空缓冲区（P (empty)），再申请互斥锁（P (mutex)），放入数据后释放互斥锁（V (mutex)），最后通知消费者（V (full)）。

3. 消费者进程：先申请满缓冲区（P (full)），再申请互斥锁（P (mutex)），取出数据后释放互斥锁（V (mutex)），最后通知生产者（V (empty)）。

   

   代码实现

   （伪代码）：

```plaintext
#define N 100
typedef int semaphore;
semaphore mutex = 1, empty = N, full = 0;

void producer() {
    int item;
    while (TRUE) {
        item = 生产数据;
        P(empty);  // 申请空缓冲区
        P(mutex);  // 申请互斥锁
        将item放入缓冲区;
        V(mutex);  // 释放互斥锁
        V(full);   // 通知消费者有数据
    }
}

void consumer() {
    int item;
    while (TRUE) {
        P(full);   // 申请满缓冲区
        P(mutex);  // 申请互斥锁
        从缓冲区取出item;
        V(mutex);  // 释放互斥锁
        V(empty);  // 通知生产者有空位
        消费item;
    }
}
```

## 一二章知识点

### 一、简要记忆

**第一章 操作系统基础核心考点**

1. 操作系统核心作用：管理 CPU、内存、I/O 等硬件资源，为用户和程序提供简洁的硬件操作接口。
2. 分时系统与多道程序系统区别：多道程序系统仅实现程序并发、提升 CPU 利用率，无交互性；分时系统按时间片轮转调度，支持多用户实时交互，响应速度快。
3. 特权指令与内核态、用户态：特权指令（如 I/O、中断控制）仅能在核心态执行，防止用户程序破坏系统；内核态权限最高，可访问所有资源，用户态权限受限，二者隔离是为保障系统安全稳定。
4. 地址空间与物理内存分离优势：实现进程地址隔离，提升安全性；支持虚拟内存，让进程可用空间突破物理内存限制。
5. 多核并行计算规律：程序总运行时间由耗时最长的单个程序决定，其余程序可并行完成。

**第二章 进程线程与调度核心考点**

1. 进程三状态核心：就绪、运行、阻塞，就绪→阻塞、阻塞→运行这两种转换绝对不可能发生；就绪进程需等调度才会运行，阻塞进程需先转为就绪再运行。
2. 核心计算公式：①CPU 利用率 = 1-pⁿ（p 为单进程 I/O 等待占比，n 为并发进程数）；②n 次 fork 创建子进程数 = 2ⁿ-1。
3. 线程核心考点：多线程下载大文件，核心是拆分文件、并行下载、合并文件，优势是提升效率；用户级线程切换开销小，内核无感知，不支持多核，一个线程阻塞则整个进程阻塞；内核级线程由内核调度，支持多核，线程阻塞不影响进程，两类线程均为每个线程一个独立栈。
4. 进程通信：流式管道通信是单向有序的流水线式数据传递，UNIX 的 pipe 机制基于此实现，适用于进程间字节流的单向传输。
5. 作业调度算法：短作业优先按运行时间升序调度，平均周转时间最短；优先级调度按优先级高低执行；时间片轮转均分 CPU，轮流响应，响应快无饿死；先来先服务按到达顺序执行，计算均需算平均周转时间（周转时间 = 完成时间 - 到达时间）。
6. 实时调度 RMS：判断任务是否可调度，先算各任务利用率（执行时间 / 周期）求和，**总利用率不超 n×(2^(1/n)-1) 即可调度**，任务周期越短优先级越高。

### 二、进程与线程管理模块

1. **进程状态与转换**
   - 核心状态：就绪（等待 CPU）、运行（占用 CPU）、阻塞（等待事件，如 I/O）
   - 不可能的转换：`就绪→阻塞`（就绪进程未获 CPU，无法发起阻塞操作）；`阻塞→运行`（阻塞进程需先转为就绪，再被调度）
2. **操作系统的核心作用**
   - 管理硬件资源（CPU、内存、I/O 设备）；为用户 / 应用程序提供硬件抽象接口
3. **分时系统 vs 多道程序系统**
   - 分时系统：按时间片轮转调度，支持多用户交互，响应快
   - 多道程序系统：多程序并发执行，仅提升 CPU 利用率，无交互性
4. **特权指令的意义**
   - 定义：仅能在内核态执行的指令（如 I/O 指令）
   - 原因：防止用户程序错误控制硬件，保护系统资源与稳定性
5. **内核态与用户态**
   - 区别：内核态可执行所有指令、访问所有资源；用户态仅能执行非特权指令、访问受限资源
   - 设计意义：隔离用户程序与系统核心，提升安全性与稳定性
6. **线程相关**
   - 用户级线程：每个线程一个栈；优点是切换开销小，缺点是内核无法感知（一个线程阻塞则进程阻塞）
   - 内核级线程：每个线程一个栈；内核直接调度，可利用多核
7. **进程通信模型**
   - 流式管道通信：数据单向、顺序传递（如快餐店雇员的 “领班→厨师→打包员” 流程）；对应 UNIX 的`pipe`机制
8. **fork 创建子进程**
   - 规则：每次 fork 会复制进程，子进程也会执行后续代码；`n次fork`的子进程数为`2ⁿ - 1`
9. **作业调度算法**
   - 短作业优先（SJF）：按作业时长升序排列，获最短平均响应时间（依作业时长动态调整顺序）
   - 轮转法（RR）：时间片轮流转，公平共享 CPU；完成时间需按时间片循环分配计算
   - 优先级调度：按优先级（高优先）执行
   - 先来先服务（FCFS）：按作业到达顺序执行
   - 平均周转时间：`(各作业完成时间之和) ÷ 作业数`
10. **实时调度（速率单调 RMS）**
    - 判断可调度的条件：**总 CPU 利用率 ≤ `n×(2^(1/n)-1)`（n 为任务数）**；总利用率低于阈值则可调度



## 第三章

### 一、连续内存分配算法（对应题 4）

用于为进程分配连续的内存空间，核心是 “选择空闲区的规则”：

- **首次适配**：按内存地址顺序，找**第一个**能容纳进程的空闲区，然后指针回到开头
- **最佳适配**：找**最小**能容纳进程的空闲区（减少空间浪费）
- **最差适配**：找**最大**的空闲区（避免频繁分割小空闲区）
- **下次适配**：从**上次分配空闲区的下一个空闲区**开始，按地址顺序找能容纳的空闲区

例题：在一个交换系统中,按内存地址排列的空闲区大小是10MB、4MB、20MB、18MB、7MB、9MB、12MB和15MB。对于连续的段请求:(a) 12MB、(b) 10MB、(c) 9MB 。使用首次适配算法,将找出哪个空闲区?使用最佳适配、最差适配、下次适配算法呢?

**初始空闲区**（按地址顺序）：  
10 MB, 4 MB, 20 MB, 18 MB, 7 MB, 9 MB, 12 MB, 15 MB  

---

**(1) 首次适配（First Fit）**  
① 请求 12 MB → 扫描：10(不够) → 4(不够) → 20(够, 分配) → 剩余 8 MB。  
列表变为：10, 4, 8, 18, 7, 9, 12, 15。  
② 请求 10 MB → 扫描：10(刚好) → 分配，移出。  
列表：4, 8, 18, 7, 9, 12, 15。  
③ 请求 9 MB → 扫描：4(不够) → 8(不够) → 18(够) → 分配后剩 9 MB。 

将找出 20 MB区； 10 MB区；18 MB区。  

---

**(2) 最佳适配（Best Fit）**  
① 请求 12 MB → 候选：20, 18, 12, 15 → 最小满足是 12 MB → 分配并移出。  
列表：10, 4, 20, 18, 7, 9, 15。  
② 请求 10 MB → 候选：10, 20, 18, 15 → 最小满足是 10 MB → 移出。  
列表：4, 20, 18, 7, 9, 15。  
③ 请求 9 MB → 候选：20, 18, 9, 15 → 最小满足是 9 MB → 移出。  

将找出 12 MB区；10 MB区；9 MB区。  

---

**(3) 最差适配（Worst Fit）**  
① 请求 12 MB → 候选：20, 18, 12, 15 → 最大是 20 MB → 剩 8 MB。  
列表：10, 4, 8, 18, 7, 9, 12, 15。  
② 请求 10 MB → 候选：10, 18, 12, 15 → 最大是 18 MB → 剩 8 MB。  
列表：10, 4, 8, 8, 7, 9, 12, 15。  
③ 请求 9 MB → 候选：10, 12, 15 → 最大是 15 MB → 剩 6 MB。  

将找出 20 MB区；18 MB区；15 MB区。  

---

**(4) 下次适配（Next Fit）**  
指针初始在起点。  
① 请求 12 MB：从第一块开始扫描 → 10(不够) → 4(不够) → 20(够) → 分配剩 8 MB，指针**移到下一块**（原18 MB块）。  
列表：10, 4, 8, 18, 7, 9, 12, 15。  
② 请求 10 MB：从指针处（18 MB块）开始 → 18(够) → 分配剩 8 MB，指针移到下一块（7 MB块）。  
列表：10, 4, 8, 8, 7, 9, 12, 15。  
③ 请求 9 MB：从指针处（7 MB块）开始 → 7(不够) → 9(刚好) → 分配移出。  

将找出 20 MB区；18 MB区；9 MB区。  

---

**最终答案表**  

| 算法     | 12 MB请求来源 | 10 MB请求来源 | 9 MB请求来源 |
| -------- | ------------- | ------------- | ------------ |
| 首次适配 | 20 MB区       | 10 MB区       | 18 MB区      |
| 最佳适配 | 12 MB区       | 10 MB区       | 9 MB区       |
| 最差适配 | 20 MB区       | 18 MB区       | 15 MB区      |
| 下次适配 | 20 MB区       | 18 MB区       | 9 MB区       |



### 二、分页存储管理（对应题 7）

将虚拟地址拆分为 “页号 + 页内偏移”，通过页表映射到物理内存，核心是**虚拟地址转物理地址的步骤**：

1. 计算：页号 = 虚拟地址 ÷ 页面大小；页内偏移 = 虚拟地址 % 页面大小
2. 查页表：找到页号对应的**页框号**
3. 计算物理地址：物理地址 = 页框号 × 页面大小 + 页内偏移

例：使用图3-9的页表,给出下面每个虚拟地址对应的物理地址:
(a) 20、(b) 4100、(c) 8300

![图3-9 页表](..\img\page_table.png)

显然看图说话，虚拟地址20对应的线指向8k-12k的部分的页，起址为8192（8*1024），然后页内偏移 = 虚拟地址 % 页面大小=20

则物理地址 = 对应地址起始值+ 页内偏移 = 8192+20 =8212 。同理可得，b的物理地址4100，c的物理地址24684

### 分页原理；逻辑地址到页号和页内偏移量的转换方法（两种：公式和二进制）

- 分页原理
  - 逻辑地址空间：分为 n 个逻辑页（页号 0、1、2…n-1），每页大小为 2^k 字节（如 4KB=2^12 字节）。
  - 物理内存：分为 m 个物理块（块号 0、1、2…m-1），**块大小 = 页大小**（保证页能装入块）。
- **逻辑地址结构**：逻辑地址 = 页号（高位） + 页内偏移量（低位）。
- 转换方法
  1. 公式法
     - 页号 = 逻辑地址 ÷ 页大小（整除）；
     - 页内偏移量 = 逻辑地址 % 页大小（取余）。
     - 例子：页大小 4KB（4096），逻辑地址 10000 → 页号 = 10000÷4096=2，页内偏移量 = 10000%4096=1808。
  2. 二进制法
     - 页大小 = 2^k → 页内偏移量占 k 位，页号占剩余高位。
     - 例子：页大小 4KB（2^12），逻辑地址 16 位 → 低 12 位是页内偏移量，高 4 位是页号。

### 请求分页的地址变换

在普通页式地址映射基础上增加 “缺页检查”：

1. 拆分逻辑地址为页号和页内偏移量；
2. 查找页表，检查存在位（P）；
3. 若 P=1：按普通页式映射计算物理地址；
4. 若 P=0：触发缺页中断，OS 调入页面后，再执行步骤 3。

### 三、页面置换算法（对应题 28、36）

当内存页框不足时，替换已装入的页面，核心是 “替换哪个页面的规则”：

- FIFO（先进先出 first in first out）：                                                                                            
  - 规则：替换**最早装入页框**的页面
  - 特点：易出现 “Belady 异常”（页框数增加，缺页次数反而变多）
  
- LRU（最近最少使用  latest recent use）：
  - 规则：替换**最久未被访问**的页面
  - 特点：需记录页面的访问时间，反映 “局部性原理”
  
- NRU（最近未使用   not recent use）：
  - 规则：按 “**R 位（最近访问标记）+ M 位（修改标记）**” 的优先级置换（优先级：**R=0&M=0 < R=0&M=1 < R=1&M=0 < R=1&M=1**）
  
- 最佳置换算法（OPT）：选择 “未来最长时间不被访问” 的页面换出；实际无法实现（无法预知未来访问）
  
- 时钟算法（Clock）（第二次机会算法）：
  
  - 规则：基于 FIFO，先检查页面的 **R 位**；
  - 若 R=1，置 R=0 并放到队尾，给他第二次机会；直到找到 R=0 的页面置换
  - 如果引用位 R= 0，置换该页，新页放入该位置，引用位R置为 1，新页加入**队尾**。
  
- 时钟算法改良算法（既有R又有M的情况）：

  考虑 **(R, M)** 两位组合，优先级顺序如下（从最佳置换候选到最差置换候选）：

  1. **(0, 0)**：最近未使用，未被修改（干净页）——最好换出，无需写回磁盘。
  2. **(0, 1)**：最近未使用，但被修改过（脏页）——需要写回磁盘，开销较大。
  3. **(1, 0)**：最近使用过，但干净——可能很快又用，尽量保留。
  4. **(1, 1)**：最近使用过且脏——最不该换出。

  置换规则：

  1. 扫描循环队列，检查每一页的 (R, M)。
  2. 寻找第一个 **(0, 0)** 页直接换出。
  3. 如果没有 (0, 0)，寻找 (0, 1)，但在找到前如果遇到 (1, 0) 或 (1, 1)，将 R 位清 0（给第二次机会）并继续扫描。
  4. 如果扫描一轮没找到可换的，再扫第二轮时必定会有 (0, 0) 或 (0, 1)（因为 R 位已被清过一次），优先选 (0, 0)。

#### **页面置换算法例题**

1.**如果将FIFO页面置换算法用到4个页框和8个页面上,若初始时页框为空,访问序列串为0172327103,请问会发生多少次缺页中断?如**

**果使用LRU算法呢?**

---

**1. FIFO 算法**

初始页框：空，8个页面指的就是0-7这八个页面。

访问顺序：  **0 1 7 2 3 2 7 1 0 3**

页框数量 = 4。(按进入顺序，**最前面的是最早装入的**)

| 访问 | 页框内容     | FIFO替换选择 | 缺页？ |
| ---- | ------------ | ------------ | ------ |
| 0    | [0]          | -            | ✔      |
| 1    | [0, 1]       | -            | ✔      |
| 7    | [0, 1, 7]    | -            | ✔      |
| 2    | [0, 1, 7, 2] | -            | ✔      |
| 3    | [1, 7, 2, 3] | 换出 0       | ✔      |
| 2    | [1, 7, 2, 3] | 已在内存     |        |
| 7    | [1, 7, 2, 3] | 已在内存     |        |
| 1    | [1, 7, 2, 3] | 已在内存     |        |
| 0    | [7, 2, 3, 0] | 换出 1       | ✔      |
| 3    | [7, 2, 3, 0] | 已在内存     |        |

**FIFO 缺页次数：**  
前 5 个访问已经缺页 5 次（因为填满 4 页框 + 第 5 次访问新页 3 缺页）。  
之后在第 9 个访问 0 时又缺页 1 次。  
合计 = 6 次缺页。

---

**2. LRU 算法**

  注意动态调整页框内容的顺序，数组按最近最少使用排序，**最近使用的放最后**，这样方便后续替换。

| 访问 | 页框内容     | 替换选择                          | 缺页？ |
| ---- | ------------ | --------------------------------- | ------ |
| 0    | [0]          | -                                 | ✔      |
| 1    | [0, 1]       | -                                 | ✔      |
| 7    | [0, 1, 7]    | -                                 | ✔      |
| 2    | [0, 1, 7, 2] | -                                 | ✔      |
| 3    | [1, 7, 2, 3] | 换出 0                            | ✔      |
| 2    | [1, 7, 3, 2] | 已在内存，访问2后把它移到最新位置 |        |
| 7    | [1, 3, 2, 7] | 已在内存，访问7后移到最新位置     |        |
| 1    | [3, 2, 7, 1] | 已在内存，访问1后移到最新位置     |        |
| 0    | [2, 7, 1, 0] | 换出 3                            | ✔      |
| 3    | [7, 1, 0, 3] | 换出 2                            | ✔      |

仔细跟踪 LRU 顺序（用列表尾部表示最近访问过，头部是最久未使用的）：

**LRU 缺页次数：**  
发生在访问 0, 1, 7, 2, 3, 0, 3 这 7 个位置。  
缺页次数 = **7**。

---

**最终答案：**

- **FIFO 缺页次数** = **6**  
- **LRU 缺页次数** = **7**

![页面置换算法](..\img\page_algorithm.png)

显然NRU算法 移除页面 2，FIFO 算法移除页面 3，LRU算法 移除页面 1，Second chance 算法移除页面 2（找第一个R=0且M=0的）。

### 四、磁盘 I/O 时间计算（对应题 35）

磁盘访问一个页面的总时间由三部分组成，核心是**时间构成 + 计算逻辑**：

- 单个页面的访问时间 = 寻道时间（移动磁臂到目标柱面） + 旋转延迟（等待目标扇区转到磁头下） + **传输时间**（读写数据）
- 传输时间 = 页面大小 ÷（每磁道容量 ÷ 磁盘旋转周期）
- 总时间（页面随机分布）= 页面数 × 单个页面访问时间

**例题：从平均寻道时间10ms、旋转延迟时间10ms、 每磁道32KB的磁盘上载入一个64KB的程序, 对于下列页面大小分别需要多少时间? (a)页面大小为2KB。 (b) 页面大小为4KB。 假设页面随机地分布在磁盘上,柱面的数目非 常大,以致于两个页面在同一个柱面的概率可 以忽略不计。**

(a) 680 ms； (b) 360 ms；



## 第四章

### 一、索引节点（i 节点）的文件大小计算

**核心逻辑**：仅考虑直接地址时，文件最大大小 = 直接地址数量 × 单个磁盘块大小

**例题（题 16）：考虑图 4-13 中的 i 节点，含 4 字节表示的 10 个直接地址，磁盘块大小是 1024KB，文件最大可能有多大？**

解题：文件最大大小 = 10 个直接地址 × 1024KB / 块 = 10240KB（即 10MB）

### 二、文件分配方式的适用场景

**核心逻辑**：

- 连续分配：适合大小固定的文件，随机访问快；但不适合动态变化的文件（易碎片、扩展难）

- 链表分配：适合动态变化的文件，无碎片；但随机访问慢

- 索引分配：**适合大小动态变化**的文件，支持随机访问；开销略高


**例题（题 18）：一个大小在 4KB 和 4MB 间变化的文件，连续、链表、索引三种分配方式中哪个最合适？**

  解题：选索引分配。因为文件大小动态变化，索引分配既支持动态调整，又能实现随机访问。



### DMA的工作原理和通道的工作原理

- DMA 的工作原理
  - 核心硬件：DMA 控制器（独立于 CPU 的硬件）。
  - 工作过程：
    1. 进程请求 I/O（如读取硬盘数据），CPU 向 DMA 控制器发送命令（设备地址、内存地址、传输长度）；
    2. CPU 继续执行其他任务，DMA 控制器控制设备与内存直接交换数据；
    3. 数据传输完成后，DMA 控制器向 CPU 发中断；
    4. CPU 响应中断，通知进程 I/O 完成。
  - 核心优势：CPU 无需参与数据传输，仅需发命令和处理中断，极大提高 CPU 利用率。
- 通道的工作原理
  - 核心硬件：通道处理器（专用的 I/O 处理器，有自己的指令系统）。
  - 工作过程：
    1. CPU 向通道发送 “通道程序”（包含 I/O 命令、设备地址、内存地址）；
    2. 通道执行通道程序，控制设备与内存交换数据，可同时控制多个设备；
    3. 所有 I/O 完成后，通道向 CPU 发中断；
    4. CPU 响应中断，处理后续工作。
  - 核心优势：CPU 只需启动通道，无需干预 I/O 过程，支持多设备并发，适合大型系统。

### SPOOLING技术

- **定义**：Simultaneous Peripheral Operations On-Line（联机并行外围操作），是一种将独占设备转换为虚拟设备的技术。
- **核心思想**：利用磁盘作为 “缓冲区”，将进程的 I/O 请求缓存到磁盘的 “输入井” 或 “输出井”，再由 “井管理程序” 依次将请求提交给物理设备。
- 组成部分
  1. 输入井：磁盘上的区域，存放进程的输入数据（从输入设备读入）。
  2. 输出井：磁盘上的区域，存放进程的输出数据（待输出到设备）。
  3. 输入井管理程序：控制输入设备将数据写入输入井。
  4. 输出井管理程序：控制输出井的数据写入输出设备。
     1. 虚拟设备：进程访问的逻辑设备（对应输入井 / 输出井）。
- 例子（虚拟打印机）
  1. 多个进程提交打印任务，OS 将打印数据写入输出井；
  2. 输出井管理程序按顺序将数据发送给物理打印机；
  3. 进程无需等待打印完成，可继续执行（异步 I/O）。
- **优点**：提高独占设备利用率，实现多进程并发 I/O，提高系统吞吐量。

### 三、硬链接与符号链接的优缺点

**核心逻辑**：

- 硬链接优点：不占用额外磁盘空间（仅新增目录项）；删除原文件后，硬链接仍可访问文件内容

- 符号链接优点：可跨文件系统链接；可链接目录（硬链接通常不能链接目录）


### 四、空闲磁盘空间管理（空闲块表 vs 位图）

**核心逻辑**：

1. 空间开销：

   - 空闲块表空间 = 空闲块数（F） × 磁盘地址对应的字节数（D 字节）
   - 位图空间 = 总块数（B） ÷ 8（1 位表示 1 个块）

2. 空闲块表空间更少的条件：F × D < B / 8

   

   例题（题 24）磁盘地址需 D 位，磁盘有 B 个块、F 个空闲。什么条件下空闲块表空间少于位图？若 D=16 位，计算空闲磁盘空间的百分比。


- 条件：当 D=16 位（即 2 字节）时，代入得 2F < B/8 → F/B < 1/16 = 6.25%，即空闲磁盘空间百分比需小于 6.25%。

### 五、空闲块位图的状态变化

**核心逻辑**：

- 分配块：对应位设为 1；释放块：对应位设为 0

- 分配规则：从最小编号的空闲块（位为 0 的位置）开始分配

  

**例题（题 25）空闲块位图初始为1000 0000 0000 0000（块 0 被占），文件 A 写入6 块后位图为1111 1110 0000 0000，完成以下操作后位图状态：(a) 写入 5 块的文件 B；(b) 删除文件 A；(c) 写入 8 块的文件 C；(d) 删除文件 B**


- (a) 写文件 B（5 块）：占块 8-12 → 位图：`1111 1111 1111 0000`

- (b) 删除文件 A（即删除A写入的块）：释放块 1-6 → 位图：`1000 0001 1111 0000`

- (c) 写文件 C（8 块）：按顺序写入空闲块→ 位图：`1111 1111 1111 1100`

- (d) 删除文件 B：释放块 8-12 → 位图：`1111 1110 0000 1100`

### 六、磁盘块的内部碎片

**核心逻辑**：内部碎片比例 = （磁盘块大小 - 文件大小） ÷ 磁盘块大小 × 100%；实际文件系统碎片更大（因小文件多、含元数据开销）

**例题（题 37）：某个文件系统使用2KB的磁盘块,而中间文件 大小值为1KB。如果所有的文件都是正好1KB 大,那么浪费掉的磁盘空间的比例是多少?你 认为一个真正的文件系统所浪费的空间比这个 数值大还是小?请说明理由**

- 碎片比例：（2KB - 1KB）÷ 2KB × 100% = 50%
- 实际更大：因为实际存在更多小于此块大小的小文件，且有目录、元数据等额外开销。

### 七、索引节点（直接 + 间接地址）的最大文件大小

**核心逻辑**：

1. 间接块指针数 = 间接块大小 ÷ 指针地址大小
2. 总块数 = 直接地址数 + 间接块指针数
3. 最大文件大小 = 总块数 × 磁盘块大小

**例题（题 38）：磁盘块大小 4KB，块指针地址 4 字节，用 10 个直接地址和 1 个间接块，可访问的最大文件大小是多少字节？**

- 间接块指针数：4KB ÷ 4 字节 = 1024
- 总块数：10 + 1024 = 1034
- 最大文件大小：1034 × 4KB = 1034 × 4096 字节 = 4235264 字节



## 第五章

### 一、中断驱动 I/O 的适用性评估

**核心逻辑**：判断中断驱动 I/O 是否有意义，需计算中断总开销占 CPU 时间的比例；若开销过高（接近 / 超过 CPU 可分配时间），则无意义。

**例题（题 12）：一个典型文本打印页面含 50 行，每行 80 个字符。打印机每分钟打印 6 个页面，打印每个字符请求一次中断，中断服务花费 50μs。使用中断驱动的 I/O 运行该打印机有没有意义？**

1. 计算每分钟打印字符数：50 行 ×80 字符 / 行 ×6 页面 = 24000 字符
2. 计算中断总开销：24000 字符 ×50μs / 字符 = 1200000μs=1.2 秒
3. 开销占比：1.2 秒 / 60 秒 = 2%，CPU 额外开销极低，因此**有意义**。

### 二、I/O 软件的四层结构

**核心逻辑**：I/O 软件分为四层，各层功能：

- 用户层 I/O 软件：处理用户请求的格式转换；
- 设备独立性软件：设备分配、权限检查；
- 设备驱动程序：计算设备操作参数、写设备寄存器；
- 中断处理程序：响应设备中断（本题未涉及）。

**例题（题 14）以下工作是在四个 I/O 软件层的哪一层完成的？**

(a) **为**一个磁盘读操作**计算**磁道、扇区、磁头；(b) 向设备寄存器**写命令**；

(c) **检查用户**是否允许使用设备；(d) 将二进制整数**转换成 ASCII 码**以便打印。

解题：(a) 设备驱动程序；(b) 设备驱动程序；(c) 设备独立性软件；(d) 用户层 I/O 软件



### 三、磁盘扇区的读入时间计算

**核心逻辑**：读入一个扇区的时间 = 旋转延迟 + 传输时间；

- 旋转延迟：磁盘半圈的时间，公式为`1/(2×转速（转/秒）)`；
- 传输时间：一个扇区的传输时间，公式为`1/(柱面扇区数×转速（转/秒）)。`

**例题（题 18）一个磁盘的转速为 7200rpm，一个柱面上有 500 个扇区，每个扇区大小为 512B。读入一个扇区需要多少时间？**

1. 转速转换为转 / 秒：7200rpm ÷ 60=120 转 / 秒
2. 旋转延迟：1/(2×120)≈0.00417 秒 = 4.17ms
3. 传输时间：1/(500×120)≈0.0000167 秒 = 0.0167ms
4. 总时间：4.17ms+0.0167ms≈**4.19ms**

### 四、磁盘容量、磁道斜进与数据传输率计算

**核心逻辑**：

- 磁盘容量：各区域（柱面数 × 磁头数 × 扇区数）× 扇区大小，累加各区域容量；

- 该区域内的最优磁道斜进（单位：扇区） = 在寻道时间内磁盘转过的圈数 × 区域扇区数  

- 假设连续读取一个文件，文件占满一个磁道后要继续到相邻磁道读取。  从当前磁道最后一个扇区到下一磁道第一个扇区，需要做两件事：

  1. 磁头移动到相邻柱面（寻道）耗时 1 ms
  2. 磁盘在这 1 ms 内仍在旋转，等寻道结束，原来在磁头下的扇区已经转过去了

  如果不做斜进，那么逻辑上的“下一扇区”在物理上可能需要转几乎一圈才能到磁头下，造成大的旋转延迟。

- 最大数据传输率：转速 × 一个柱面的扇区数 × 扇区大小。

**例题（题 28）考虑一个包含 16 个磁头和 400 个柱面的磁盘。该磁盘分成 4 个 100 柱面的区域，不同区域分别包含 160、200、240 和 280 个扇区。每个扇区含 512 字节，相邻柱面平均寻道时间 1ms，磁盘转速 7200rpm。计算磁盘容量、最优磁道斜进以及最大数据传输率。**

1. 磁盘容量：

   区域 1：100×16×160×512=131072000B=131.072MB

   区域 2：100×16×200×512=163840000B=163.84MB

   区域 3：100×16×240×512=196608000B=196.608MB

   区域 4：100×16×280×512=229376000B=229.376MB

   总容量：131.072+163.84+196.608+229.376=720.896MB

2. **最优磁道斜进：**

   我们分步讲解看最优磁道斜进的计算逻辑。

   ---

   **已知条件：**
   - 相邻柱面寻道时间：1 ms
   - 磁盘转速：7200 rpm
   - 各区域每磁道扇区数分别为 160、200、240、280
   - 磁道斜进是指同一逻辑扇区在相邻磁道上物理位置偏移的扇区数

   ---

   **1. 算出一圈的旋转时间**
   转速 7200 转/分钟  
   转一圈时间 = 60 ÷ 7200 ≈ 8.333 ms

   ---

   **2. 最优斜进怎么算**
   目标：**寻道结束后，磁头刚好位于下一磁道的“逻辑第一扇区”的物理位置**  
   在 1 ms 寻道期间磁盘转过的角度 = (1 ms ÷ 8.333 ms) × 1圈 ≈ 0.12 圈

   这个角度对应的扇区数，取决于每磁道有多少扇区。  
   不同区域每磁道扇区数不同：

   - 区域1：160 扇区 → 0.12 × 160 ≈ 19.2 扇区
   - 区域2：0.12 × 200 ≈ 24 扇区
   - 区域3：0.12 × 240 ≈ 28.8 扇区
   - 区域4：0.12 × 280 ≈ 33.6 扇区

   ---

   **3. ps: 如果斜进固定一个值，应该选哪个作为斜进？**
   如果斜进固定一个值，要保证所有区域在寻道 1 ms 后都能刚好对准或超前，必须选择**最大的扇区偏移数**，即 34 扇区。

   但有时题目会假设按“平均扇区数”算，因为统一斜进无法同时满足所有区域。  
   平均扇区数 = (160+200+240+280)/4 = 220  
   0.12 × 220 ≈ 26.4 扇区 → 取整 26

   通常教材例题答案可能是 26 扇区，这是平衡设计。

   

3. 最大数据传输率：

   转速转 / 秒：7200÷60=120 转 / 秒

   传输率：120×280×512=17203200 字节 / 秒 


### 五、磁盘调度算法的寻道时间计算

**核心逻辑**：

- 先来先服务（FCFS）：按请求顺序移动磁臂，总寻道时间 = 总移动柱面数 × 每个柱面时间；

- 最近柱面优先（SSTF）：移动到最近的请求柱面，计算总移动柱面数 × 每个柱面时间；

- 电梯算法（SCAN）：初始向一个方向移动，处理完该方向请求后回到起始点然后**反向**，计算总移动柱面数 × 每个柱面时间。

  

**例题（题 31）磁盘请求以柱面 10、22、20、2、40、6 和 38 的次序进入，寻道时每个柱面移动需要 6ms，磁臂起始于柱面 20。计算各算法的寻道时间：(a) 先来先服务；(b) 最近柱面优先；(c) 电梯算法（初始向上移动）。**


1. (a) 先来先服务：路径：20→10→22→20→2→40→6→38（磁臂起始于柱面 20）

   移动柱面数：10（20→10）+12（10→22）+2+18+38+34+32=146 （路径之间差值和）

   寻道时间：146×6ms=876ms

2. (b) 最近柱面优先：路径：20→22→38→40→10→6→2

   移动柱面数：2+16+2+30+4+4=58

   寻道时间：58×6ms=348ms

3. (c) 电梯算法（初始向上）：

   路径：20→22→38→40→20→10→6→2

   移动柱面数：2+16+2+20+10+4+4=58

   寻道时间：58×6ms=348ms



## 第六章

### 一、死锁检测算法的应用

**核心逻辑**（银行家算法，拿着A一个个去对每个进程的请求`Ri`，能分配就分配然后将该进程的已分配的资源`Ci`释放到A(加到A)）：

1. **C（Claim / 最大需求矩阵）** —— 每个进程声明需要每种资源的最大数量。
2. **A（Allocation / 已分配矩阵）** —— 当前已分配给每个进程的资源数量。
3. **R（Request / 当前请求矩阵）** —— 每个进程当前还请求多少资源才能完成。
4. **E（Existing / 系统资源总量）**
5. **A_v（Available / 当前可用资源向量）**

死锁检测步骤为：

1) 寻找一个**没有标记**的进程`Pi`,对于它而言R矩阵的第`i`行向量小于或等于A。  
2) 如果找到了这样一个进程,那么将C矩阵的第`i`行向量**加到A中,**标记该进程,并转到第1步。
3) 如果没有这样的进程,那么算法终止。 算法结束时,所有没有标记过的进程(如果存在的话)都是死锁进程。



**例题（题 14）系统有 4 个进程 P1-P4，5 种资源 RS1-RS5，已分配矩阵 C、需求矩阵 R、可用资源 E=(2,4,1,4,4)、已分配总和 A=(0,1,0,2,1)。用死锁检测算法说明系统存在死锁，并识别死锁进程。**

确认需求矩阵 R（题目已给出），可用资源 E=(2,4,1,4,4)；

每个进程已分配资源：C1 = 0 1 1 2； C2 = 0 1 0 1 0 ；C3 =0 0 0 0 1 ；C4 = 2 1 0 0 0

检查进程：

首先，未标记的进程集合 P = (P1 P2 P3 P4)
P1 剩余需求 R1=(1,0,2,1,1)，R1 不小于或等于 A,无法分配并释放P1的资源。
P2 剩余需求 R2=(0,1,0,2,1)，R2 小于 A；标记 P2；A = (0,2,0,3,1)；P = (P1 ，P3， P4)
P1 剩余需求R1 不小于或等于 A；P = (P3 ，P4，P1 ) 
P3 剩余需求 R3=(0,2,0,3,1)，R3 等于 A；标记 P3；`加上C3`; A = (0,2,0,3,2)；P = (P1，P4)
P1 剩余需求 R1仍 不小于或等于 A；P = (P4，P1)
P4 剩余需求 R4=(0,2,1,1,0)，R4 不小于或等于 A  
因此，进程 P1 和 P4 仍未标记。它们处于死锁状态。

### 二、死锁可能性的判断（基于资源数与进程需求）

**核心逻辑**：判断是否可能死锁，需结合死锁的必要条件（互斥、占有等待、不可剥夺、循环等待），同时计算 “资源数是否能满足进程的最大需求”：若`资源数≥进程数 x（每个进程最大需求 - 1）+ 1`，则不会死锁。 

**例题（题 22）**：系统有 2 个进程、3 个相同资源，每个进程最多需要 2 个资源。是否可能发生死锁？为什么？

解题：不可能发生死锁。原因：计算 “资源数下限”：进程数 x（每个进程最大需求 - 1）+ 1=1+ 2*(2-1)=3，当前资源数恰好为 3；当资源数≥该下限，无论进程如何请求，总能有一个进程获得足够资源完成，释放资源后其他进程也能完成，不满足 “循环等待” 等死锁条件。

### 三、安全状态与可用资源的最小值

**核心逻辑**：安全状态需存在 “安全序列”（进程按序列依次完成，释放资源后后续进程可完成）。步骤：

1. 计算**剩余需求**(也就是R矩阵)：剩余需求 = 最大需求量 - 已分配资源；

2. 遍历进程，寻找 “剩余需求≤可用资源” 的进程，标记后释放其已分配资源到可用资源；

3. 重复步骤 2，若所有进程都能被标记，则状态安全；据此确定可用资源的最小值。

   

**例题（题 26）系统有 4 个进程、5 个可分配资源，已分配、最大需求量、可用资源为 (0,0,x,1,1)。求保持安全状态的 x 最小值。**

   计算各进程的剩余需求：

   - 进程 A：(1,1,2,1,3)-(1,0,2,1,1)=(0,1,0,0,2)；
   - 进程 B：(2,2,2,1,0)-(2,0,1,1,0)=(0,2,1,0,0)；
   - 进程 C：(2,1,3,1,0)-(1,1,0,1,0)=(1,0,3,0,0)；
   - 进程 D：(1,1,2,2,1)-(1,1,1,1,0)=(0,0,1,1,1)；

   初始可用资源为 (0,0,x,1,1)，尝试 x 的最小值：

   当 x=1 时，可用资源为 (0,0,1,1,1)：

   - 进程 D 的剩余需求 (0,0,1,1,1)≤可用资源，标记 D；释放其已分配 (1,1,1,1,0)，可用资源更新为 (1,1,2,2,1)；

   - 进程 A 的剩余需求 (0,1,0,0,2)≤可用资源，标记 A；释放已分配 (1,0,2,1,1)，可用资源更新为 (2,1,4,3,2)；

   - 进程 B 的剩余需求 (0,2,1,0,0)≤可用资源，标记 B；释放已分配 (2,0,1,1,0)，可用资源更新为 (4,1,5,4,2)；

   - 进程 C 的剩余需求 (1,0,3,0,0)≤可用资源，标记 C；所有进程完成，状态安全。

     

     因此 x 的最小值为1。

### 四、预防死锁（破除 “占有等待” 条件）的方法改进

**核心逻辑**：原方法（请求新资源前释放已有资源）的问题是 “丢失原有资源”，改进思路是 “先保留原有资源的使用权，直到新资源分配成功”。

**例题（题 31）**：预防死锁的方法之一是请求新资源前释放已有资源，但会导致进程丢失原有资源。给出该方法的改进。

解题：改进方法：进程请求新资源时，**先申请新资源，若新资源分配成功，再保留原有资源；若新资源分配失败，才释放原有资源并进入等待**。或：引入 “资源预留” 机制，进程先声明所需资源，系统为其预留（不实际分配），当所有所需资源都能预留时，再一次性分配所有资源（同时破除 “占有等待” 条件，避免资源丢失）。