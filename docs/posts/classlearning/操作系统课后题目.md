---
date: 2026-01-03
category:
  - 期末复习
tag:
  - 操作系统
sticky: true
---

# 操作系统书后习题

## 第一章

**1. 操作系统两大主要作用？**

- 管理 CPU、内存、I/O 设备等硬件资源；
- 为用户 / 应用程序提供便捷的硬件抽象接口。

**3. 分时系统和多道程序系统的区别？**

- 分时系统：按时间片轮转调度，支持多用户交互，响应快；
- 多道程序系统：多个程序并发执行，仅提升 CPU 利用率，无交互性。

**6. 为何 I/O 指令是特权指令？** 

防止用户程序错误控制 I/O 设备，避免破坏硬件或系统资源，保障系统稳定性。

**10. 内核态与用户态的区别及设计意义？**

- 区别：内核态可执行所有指令（含特权指令）、访问所有资源；用户态仅能执行非特权指令、访问受限资源；
- 意义：隔离用户程序与系统核心，防止用户程序破坏系统，提升安全性与稳定性。

**12. 以下哪些是只能在内核态使用的指令？（选项：a 禁止所有中断、b 读时钟、c 设置日期 - 时间时钟、d 改变存储映像）**

答案：(a)、(c)、(d)

用户态能执行的指令，核心特征：**仅作用于进程自身内存 / 数据，不影响系统全局、不操控硬件、执行错误只会让自身进程崩溃，不会导致系统故障**，具体包含：

1. 所有**基础数据运算指令**：加减乘除、逻辑运算、位运算等；
2. 所有**进程自身数据的读写指令**：读写本进程虚拟地址空间内的变量、数组、文件缓冲区等（✅ 可写，不是只读）；
3. 所有**程序流程控制指令**：条件判断、循环、函数调用 / 返回、跳转等；
4. 部分**只读式系统信息获取指令**：仅读取时钟时间、系统版本等无修改权限的基础信息

**13. 4 个程序 P1 (10ms)、P2 (20ms)、P3 (5ms)、P4 (15ms)，在 2 个 CPU + 超线程的系统中运行，总运行时间？**

答案：20ms（并行执行，P2 需 20ms，其余程序可在该时长内完成）

**23. 有一个文件,其文件描述符是fd,内含下列字 节序列:3, 1, 4, 1,5,9, 2, 6,5,3,5. 有如下系统调用: Iseek(fd, 3, SEEK_SET); read(fd, &buffer, 4); 其中Iseek调用寻找文件中的字节3。在读操作 完成之后,buffer 中的内容是什么?**

1. `lseek(fd, 3, SEEK_SET)` 含义（必考）

`SEEK_SET` 表示 **从文件开头绝对偏移**，偏移 3 字节 = 把文件读写指针，定位到「文件索引为 3 的字节的位置」

👉 操作系统中，文件字节的索引（位置编号）**永远从 0 开始**，这是铁律！

2. `read(fd, &buffer, 4)` 含义（必考）

从指针定位的位置开始，**连续向后读取 4 个字节**，存入 buffer 中；只要文件剩余字节数足够，就直接读，✅ 无跳跃、✅ 无循环，是最基础的连续读取规则。则是从1开始，读四个字节。

答案：1、5、9、2

**27. 进程的地址空间与物理内存分离的好处？**

1. 进程地址空间隔离，防止进程间数据破坏，提升安全性；
2. 支持虚拟内存，使进程可使用超过物理内存的地址空间，提升内存利用率。



## 第二章

**1. 进程三状态（就绪、运行、阻塞）的剩余两种转换是否可能？**

不可能，剩余转换为 “就绪→阻塞” 和 “阻塞→运行”：

- 就绪→阻塞：就绪进程未获得 CPU 使用权，无法主动发起 I/O 等阻塞操作，无法直接转换；
- 阻塞→运行：阻塞进程需先完成等待事件（如 I/O 完成），转为就绪态后，再由调度器选中才能进入运行态，不能直接转换。

**6. 已知 RAM4GB（OS 占 512MB），进程各占 256MB，求使 CPU 利用率达 99% 的最大 I/O 等待时间占比？**

1. 计算可用内存：4GB - 512MB = 3584MB，最多同时运行进程数为 3584MB ÷ 256MB = 14 个；
2. CPU 利用率公式：1 减去每个进程 I/O 等待占比的 14 次方，结果需大于等于 99%（即 1 - p 的 14 次方 ≥ 0.99）；
3. 推导得 p 的 14 次方 ≤ 0.01，计算后 p 约等于 0.72，故最大 I/O 等待时间占比约 72%。

**9. 如何用多线程优化从镜像服务器下载 2GB 大文件的时间？**

1. 拆分文件：将 2GB 文件分成多个连续的字节块，每个块对应一个镜像服务器；

2. 并行下载：创建多个线程，每个线程向对应的镜像服务器发起请求（指定块的起始和结束字节），同时下载各自负责的块；

3. 合并文件：所有线程下载完成后，将各个字节块按原文件顺序拼接，生成完整文件

   核心优势：充分利用多服务器的带宽资源，减少单线程下载的等待时间，提升整体下载效率。

**18. 用户态实现线程的最大优缺点是什么？**

- 最大优点：线程切换在用户态完成，不需要内核参与，切换开销小（无需切换内核态 / 用户态，上下文保存和恢复操作简单）；
- 最大缺点：***内核无法感知用户级线程的存在***，若一个用户级线程因 I/O 等操作阻塞，整个进程的所有用户级线程都会被阻塞；且无法利用多核 CPU（内核按进程调度，同一进程的用户级线程只能在一个 CPU 核心上运行）。

**27. 用户级线程和内核级线程的栈，是每个线程一个还是每个进程一个？**

- 用户级线程：每个线程一个栈。因为用户级线程是进程内独立的执行流，需要独立的栈存储局部变量、函数调用上下文等，确保执行互不干扰；
- 内核级线程：每个线程一个栈。内核级线程是内核直接调度的独立实体，每个线程需具备独立的用户栈（用于用户态执行）和内核栈（用于内核态处理中断、系统调用等操作）。

**36. 快餐店雇员（领班→厨师→打包员→收银员）的进程通信模型是什么？与 UNIX 的联系？**

- 通信模型：流式管道通信。数据按 “领班→厨师→打包员→收银员” 的顺序，单向、有序传递，前一个环节的输出作为后一个环节的输入；
- 与 UNIX 的联系：UNIX 系统中的管道（pipe）就是基于该模型实现的，用于进程间单向、顺序的字节流通信（例如父子进程间通过管道传递数据）。

**39. 代码中连续执行两次 fork ()，会创建多少个子进程？**

共创建 3 个子进程，原理如下：

1. 第一次 fork ()：父进程创建 1 个子进程，此时系统中共有 2 个进程（父进程、子进程 1）；
2. 第二次 fork ()：当前的 2 个进程（父进程、子进程 1）**都会执行 fork ()**，各自创建 1 个子进程（子进程 2、子进程 3）；
3. 总进程数为 2 的 2 次方 = 4 个，减去原始的 1 个父进程，最终子进程数为 3 个（公式：**2 的 n 次方 - 1，n 为 fork () 执行次数**）。

**44. 作业运行时间分别为 9、6、3、5、X，按什么顺序运行能得到最短平均响应时间？（依 X 取值而定）**

采用短作业优先（SJF）调度算法，按作业运行时间升序排列，分情况如下：

- 若 X≤3：顺序为 X、3、5、6、9；
- 若 3＜X≤5：顺序为 3、X、5、6、9；
- 若 5＜X≤6：顺序为 3、5、X、6、9；
- 若 6＜X≤9：顺序为 3、5、6、X、9；
- 若 X＞9：顺序为 3、5、6、9、X。

**45. .有5个批处理作业A~E,它们几乎同时到达一 个计算中心。作业 A (运行时间 10，优先级 3)、B (6，5)、C (2，2)、D (4，1)、E (8，4)（优先级 5 最高），计算各调度算法的平均周转时间（作业到达时间均为 0，周转时间 = 完成时间 - 到达时间）？**

对于轮转法,假设系统具有多道程序处理能力, 每个作业均公平共享CPU时间,对

- **轮转法**（时间片 = 1）每个作业均公平共享CPU时间,：

  因为是它们几乎同时到达一 个计算中心，因此顺序没影响，就是按最小的时间片来，记为 t，t趋近于0

  第n轮，按顺序每个减去t，最小的C完成，则A的完成时间是5 * （n-1）*  t+m * t（前面经历了（n-1）轮，每轮用时5 * t ,m表示每一轮A是第m个减t的） ，n  *  t = 2；

  显然A的完成时间是5 * n *  t - (5-m) * t ,   (5-m) 是一个有理数而t趋近于0， 则A的完成时间是可记为5nt ，约为10，为A的完成时间。

  此时D剩下2为最小，接下来的过程一样的，剩下四个，直到最小的D完成，则完成时间是10+2*4 = 18 （队列只剩四个，每轮是4t）.

  以此类推。总周转时间是10+8+6+4+2= 30。

  注意此处要是指定了时间片为1或者其他的，就按这个方法来不过不用极限了。时间片轮转就是一个队列轮转着来。

  如果每个作业到达时间不一样，优先级有影响。例如此时是p1->p2->p3 ,在运行p3，p3结束后放入队尾的时候如果p4进入，要对比p3和p4的优先级。如果如果优先级p4<p3,则此时队列是p4->p3->p2->p1  ；优先级p4>p3，则此时队列是p3->p4->p2->p1。

  

- 优先级调度（**按优先级从高到低**）：

  执行顺序：B、E、A、C、D；

  完成时间：B (6)、E (14)、A (24)、C (26)、D (30)；

  平均周转时间：(6+14+24+26+30)÷5=20；

  

- 先来先服务（按 A、B、C、D、E 顺序）：

  完成时间：A (10)、B (16)、C (18)、D (22)、E (30)；

  平均周转时间：(10+16+18+22+30)÷5=19.2；

- 最短作业优先（按运行时间从短到长）：

  执行顺序：C、D、B、E、A；

  完成时间：C (2)、D (6)、B (12)、E (20)、A (30)；

  平均周转时间：(2+6+12+20+30)÷5=14。

**47. 系统中有 2 个周期 5ms（CPU 时间 1ms）的电话任务，1 个周期 33ms（CPU 时间 11ms）的视频流任务，实时系统是否可调度？**采用速率单调调度（RMS）判断，可调度，步骤如下：

1. 计算各任务的 CPU 利用率：
   - 每个电话任务利用率：1ms÷5ms=0.2；
   - 视频流任务利用率：11ms÷33ms≈0.333；
   - 总利用率：0.2+0.2+0.333=0.733；
2. RMS 最大可调度利用率（3 个任务）：3×(2 的三分之一次方 -1)≈0.78；
3. 因总利用率 0.733≤0.78，故系统可调度。

## 一二章知识点

### 零、简要记忆

**第一章 操作系统基础核心考点**

1. 操作系统核心作用：管理 CPU、内存、I/O 等硬件资源，为用户和程序提供简洁的硬件操作接口。
2. 分时系统与多道程序系统区别：多道程序系统仅实现程序并发、提升 CPU 利用率，无交互性；分时系统按时间片轮转调度，支持多用户实时交互，响应速度快。
3. 特权指令与内核态、用户态：特权指令（如 I/O、中断控制）仅能在核心态执行，防止用户程序破坏系统；内核态权限最高，可访问所有资源，用户态权限受限，二者隔离是为保障系统安全稳定。
4. 地址空间与物理内存分离优势：实现进程地址隔离，提升安全性；支持虚拟内存，让进程可用空间突破物理内存限制。
5. 多核并行计算规律：程序总运行时间由耗时最长的单个程序决定，其余程序可并行完成。

**第二章 进程线程与调度核心考点**

1. 进程三状态核心：就绪、运行、阻塞，就绪→阻塞、阻塞→运行这两种转换绝对不可能发生；就绪进程需等调度才会运行，阻塞进程需先转为就绪再运行。
2. 核心计算公式：①CPU 利用率 = 1-pⁿ（p 为单进程 I/O 等待占比，n 为并发进程数）；②n 次 fork 创建子进程数 = 2ⁿ-1。
3. 线程核心考点：多线程下载大文件，核心是拆分文件、并行下载、合并文件，提升效率；用户级线程切换开销小，内核无感知，不支持多核，一个线程阻塞则整个进程阻塞；内核级线程由内核调度，支持多核，线程阻塞不影响进程，两类线程均为每个线程一个独立栈。
4. 进程通信：流式管道通信是单向有序的流水线式数据传递，UNIX 的 pipe 机制基于此实现，适用于进程间字节流传输。
5. 作业调度算法：短作业优先按运行时间升序调度，平均周转时间最短；优先级调度按优先级高低执行；时间片轮转均分 CPU，响应快无饿死；先来先服务按到达顺序执行，计算均需算平均周转时间（周转时间 = 完成时间 - 到达时间）。
6. 实时调度 RMS：判断任务是否可调度，先算各任务利用率（执行时间 / 周期）求和，总利用率不超 n×(2^(1/n)-1) 即可调度，任务周期越短优先级越高。

### 一、进程与线程管理模块

1. **进程状态与转换**
   - 核心状态：就绪（等待 CPU）、运行（占用 CPU）、阻塞（等待事件，如 I/O）
   - 不可能的转换：`就绪→阻塞`（就绪进程未获 CPU，无法发起阻塞操作）；`阻塞→运行`（阻塞进程需先转为就绪，再被调度）
2. **操作系统的核心作用**
   - 管理硬件资源（CPU、内存、I/O 设备）；为用户 / 应用程序提供硬件抽象接口
3. **分时系统 vs 多道程序系统**
   - 分时系统：按时间片轮转调度，支持多用户交互，响应快
   - 多道程序系统：多程序并发执行，仅提升 CPU 利用率，无交互性
4. **特权指令的意义**
   - 定义：仅能在内核态执行的指令（如 I/O 指令）
   - 原因：防止用户程序错误控制硬件，保护系统资源与稳定性
5. **内核态与用户态**
   - 区别：内核态可执行所有指令、访问所有资源；用户态仅能执行非特权指令、访问受限资源
   - 设计意义：隔离用户程序与系统核心，提升安全性与稳定性
6. **线程相关**
   - 用户级线程：每个线程一个栈；优点是切换开销小，缺点是内核无法感知（一个线程阻塞则进程阻塞）
   - 内核级线程：每个线程一个栈；内核直接调度，可利用多核
7. **进程通信模型**
   - 流式管道通信：数据单向、顺序传递（如快餐店雇员的 “领班→厨师→打包员” 流程）；对应 UNIX 的`pipe`机制
8. **fork 创建子进程**
   - 规则：每次 fork 会复制进程，子进程也会执行后续代码；`n次fork`的子进程数为`2ⁿ - 1`
9. **作业调度算法**
   - 短作业优先（SJF）：按作业时长升序排列，获最短平均响应时间（依作业时长动态调整顺序）
   - 轮转法（RR）：时间片轮流转，公平共享 CPU；完成时间需按时间片循环分配计算
   - 优先级调度：按优先级（高优先）执行
   - 先来先服务（FCFS）：按作业到达顺序执行
   - 平均周转时间：`(各作业完成时间之和) ÷ 作业数`
10. **实时调度（速率单调 RMS）**
    - 判断可调度的条件：总 CPU 利用率 ≤ `n×(2^(1/n)-1)`（n 为任务数）；总利用率低于阈值则可调度

### 二、内存管理模块

1. **连续内存分配算法**
   - 首次适配：按地址顺序找第一个能容纳的空闲区
   - 最佳适配：找最小能容纳的空闲区（减少空间浪费）
   - 最差适配：找最大的空闲区（避免频繁分割小空闲区）
   - 下次适配：从上次分配的下一个空闲区开始，按地址顺序查找
2. **分页存储管理**
   - 虚拟地址转物理地址步骤：
     1. 计算页号 = 虚拟地址 ÷ 页面大小；页内偏移 = 虚拟地址 % 页面大小
     2. 查页表得页框号
     3. 物理地址 = 页框号 × 页面大小 + 页内偏移
3. **页面置换算法**
   - FIFO：替换最早装入页框的页面（易出现 Belady 异常）
   - LRU：替换最久未被访问的页面（符合局部性原理）
   - NRU：按 “R 位（访问标记）+ M 位（修改标记）” 的优先级置换（R=0&M=0 优先级最低）
   - 第二次机会：基于 FIFO，检查 R 位；R=1 则置 0 并放队尾，直到找到 R=0 的页面

### 三、设备管理模块

**磁盘 I/O 时间计算**

- 单个页面的访问时间 = 寻道时间（移动磁臂到目标柱面） + 旋转延迟（等待扇区转到磁头） + 传输时间（读写数据）
  - 传输时间 = 页面大小 ÷（每磁道容量 ÷ 磁盘旋转周期）
- 总时间（页面随机分布） = 页面数 × 单个页面访问时间

## 第三章

### 一、连续内存分配算法（对应题 4）

用于为进程分配连续的内存空间，核心是 “选择空闲区的规则”：

- **首次适配**：按内存地址顺序，找**第一个**能容纳进程的空闲区
- **最佳适配**：找**最小**能容纳进程的空闲区（减少空间浪费）
- **最差适配**：找**最大**的空闲区（避免频繁分割小空闲区）
- **下次适配**：从**上次分配的下一个空闲区**开始，按地址顺序找能容纳的空闲区

### 二、分页存储管理（对应题 7）

将虚拟地址拆分为 “页号 + 页内偏移”，通过页表映射到物理内存，核心是**虚拟地址转物理地址的步骤**：

1. 计算：页号 = 虚拟地址 ÷ 页面大小；页内偏移 = 虚拟地址 % 页面大小
2. 查页表：找到页号对应的**页框号**
3. 计算物理地址：物理地址 = 页框号 × 页面大小 + 页内偏移

### 三、页面置换算法（对应题 28、36）

当内存页框不足时，替换已装入的页面，核心是 “替换哪个页面的规则”：

- FIFO（先进先出）：
  - 规则：替换**最早装入页框**的页面
  - 特点：易出现 “Belady 异常”（页框数增加，缺页次数反而变多）
- LRU（最近最少使用）：
  - 规则：替换**最久未被访问**的页面
  - 特点：需记录页面的访问时间，反映 “局部性原理”
- NRU（最近未使用）：
  - 规则：按 “R 位（最近访问标记）+ M 位（修改标记）” 的优先级置换（优先级：R=0&M=0 < R=0&M=1 < R=1&M=0 < R=1&M=1）
- 第二次机会：
  - 规则：基于 FIFO，先检查页面的 R 位；若 R=1，置 R=0 并放到队尾；直到找到 R=0 的页面置换

### 四、磁盘 I/O 时间计算（对应题 35）

磁盘访问一个页面的总时间由三部分组成，核心是**时间构成 + 计算逻辑**：

- 单个页面的访问时间 = 寻道时间（移动磁臂到目标柱面） + 旋转延迟（等待目标扇区转到磁头下） + 传输时间（读写数据）
  - 传输时间 = 页面大小 ÷（每磁道容量 ÷ 磁盘旋转周期）
- 总时间（页面随机分布）= 页面数 × 单个页面访问时间

## 第四章

### 一、索引节点（i 节点）的文件大小计算

**核心逻辑**：仅考虑直接地址时，文件最大大小 = 直接地址数量 × 单个磁盘块大小**例题（题 16）**：题目：考虑图 4-13 中的 i 节点，含 4 字节表示的 10 个直接地址，磁盘块大小是 1024KB，文件最大可能有多大？解题：文件最大大小 = 10 个直接地址 × 1024KB / 块 = 10240KB（即 10MB）

### 二、文件分配方式的适用场景

**核心逻辑**：

- 连续分配：适合大小固定的文件，随机访问快；但不适合动态变化的文件（易碎片、扩展难）

- 链表分配：适合动态变化的文件，无碎片；但随机访问慢

- 索引分配：适合大小动态变化的文件，支持随机访问；开销略高

  

  例题（题 18）

  ：

  

  题目：一个大小在 4KB 和 4MB 间变化的文件，连续、链表、索引三种分配方式中哪个最合适？

  

  解题：选索引分配。因为文件大小动态变化，索引分配既支持动态调整，又能实现随机访问。

### 三、硬链接与符号链接的优缺点

**核心逻辑**：

- 硬链接优点：不占用额外磁盘空间（仅新增目录项）；删除原文件后，硬链接仍可访问文件内容

- 符号链接优点：可跨文件系统链接；可链接目录（硬链接通常不能链接目录）

  

  例题（题 21）

  ：

  

  题目：说明硬链接优于符号链接的一个优点，及符号链接优于硬链接的一个优点。

  

  解题：

- 硬链接优点：删除原文件后，硬链接仍能访问文件内容；

- 符号链接优点：可以跨文件系统进行链接。

### 四、空闲磁盘空间管理（空闲块表 vs 位图）

**核心逻辑**：

1. 空间开销：

   - 空闲块表空间 = 空闲块数（F） × 磁盘地址对应的字节数（D 字节）
   - 位图空间 = 总块数（B） ÷ 8（1 位表示 1 个块）

2. 空闲块表空间更少的条件：F × D < B / 8

   

   例题（题 24）

   ：

   

   题目：磁盘地址需 D 位，磁盘有 B 个块、F 个空闲。什么条件下空闲块表空间少于位图？若 D=16 位，计算空闲磁盘空间的百分比。

   

   解题：

- 条件：当 D=16 位（即 2 字节）时，代入得 2F < B/8 → F/B < 1/16 = 6.25%，即空闲磁盘空间百分比需小于 6.25%。

### 五、空闲块位图的状态变化

**核心逻辑**：

- 分配块：对应位设为 1；释放块：对应位设为 0

- 分配规则：从最小编号的空闲块（位为 0 的位置）开始分配

  

  例题（题 25）

  ：

  

  题目：空闲块位图初始为1000 0000 0000 0000

  （块 0 被占），文件 A 写入后（6 块）位图为1111 1110 0000 0000，完成以下操作后位图状态：

  (a) 写入 5 块的文件 B；(b) 删除文件 A；(c) 写入 8 块的文件 C；(d) 删除文件 B

  

  解题：

- (a) 写文件 B（5 块）：占块 6-10 → 位图：`1111 1111 1111 0000`

- (b) 删除文件 A：释放块 0-5 → 位图：`0000 0011 1111 0000`

- (c) 写文件 C（8 块）：占块 0-7 → 位图：`1111 1111 1111 0000`

- (d) 删除文件 B：释放块 6-10 → 位图：`1111 1100 0001 0000`

### 六、磁盘块的内部碎片

**核心逻辑**：内部碎片比例 = （磁盘块大小 - 文件大小） ÷ 磁盘块大小 × 100%；实际文件系统碎片更大（因小文件多、含元数据开销）**例题（题 37）**：题目：文件系统用 2KB 磁盘块，文件均为 1KB，浪费的磁盘空间比例是多少？实际文件系统碎片比这大还是小？

解题：

- 碎片比例：（2KB - 1KB）÷ 2KB × 100% = 50%
- 实际更大：因为实际存在更多小于块大小的小文件，且有目录、元数据等额外开销。

### 七、索引节点（直接 + 间接地址）的最大文件大小

**核心逻辑**：

1. 间接块指针数 = 间接块大小 ÷ 指针地址大小
2. 总块数 = 直接地址数 + 间接块指针数
3. 最大文件大小 = 总块数 × 磁盘块大小

例题（题 38）：



题目：磁盘块大小 4KB，块指针地址 4 字节，用 10 个直接地址和 1 个间接块，可访问的最大文件大小是多少字节？



解题：

- 间接块指针数：4KB ÷ 4 字节 = 1024
- 总块数：10 + 1024 = 1034
- 最大文件大小：1034 × 4KB = 1034 × 4096 字节 = 4136960 字节（约 4.04MB）

## 第五章

### 一、中断驱动 I/O 的适用性评估

**核心逻辑**：判断中断驱动 I/O 是否有意义，需计算中断总开销占 CPU 时间的比例；若开销过高（接近 / 超过 CPU 可分配时间），则无意义。**例题（题 12）**：题目：一个典型文本打印页面含 50 行，每行 80 个字符。打印机每分钟打印 6 个页面，打印每个字符请求一次中断，中断服务花费 50μs。使用中断驱动的 I/O 运行该打印机有没有意义？解题：

1. 计算每分钟打印字符数：50 行 ×80 字符 / 行 ×6 页面 = 24000 字符
2. 计算中断总开销：24000 字符 ×50μs / 字符 = 1200000μs=1.2 秒
3. 开销占比：1.2 秒 / 60 秒 = 2%，CPU 开销极低，因此**有意义**。

### 二、I/O 软件的四层结构

**核心逻辑**：I/O 软件分为四层，各层功能：

- 用户层 I/O 软件：处理用户请求的格式转换；
- 设备独立性软件：设备分配、权限检查；
- 设备驱动程序：计算设备操作参数、写设备寄存器；
- 中断处理程序：响应设备中断（本题未涉及）。

例题（题 14）：

题目：以下工作是在四个 I/O 软件层的哪一层完成的？

(a) 为一个磁盘读操作计算磁道、扇区、磁头；

(b) 向设备寄存器写命令；

(c) 检查用户是否允许使用设备；

(d) 将二进制整数转换成 ASCII 码以便打印。



解题：

(a) 设备驱动程序

(b) 设备驱动程序

(c) 设备独立性软件

(d) 用户层 I/O 软件

### 三、磁盘扇区的读入时间计算

**核心逻辑**：读入一个扇区的时间 = 旋转延迟 + 传输时间；

- 旋转延迟：磁盘半圈的时间，公式为`1/(2×转速（转/秒）)`；
- 传输时间：一个扇区的传输时间，公式为`1/(柱面扇区数×转速（转/秒）)。`

例题（题 18）：

题目：一个磁盘的转速为 7200rpm，一个柱面上有 500 个扇区，每个扇区大小为 512B。读入一个扇区需要多少时间？



解题：

1. 转速转换为转 / 秒：7200rpm ÷ 60=120 转 / 秒
2. 旋转延迟：1/(2×120)≈0.00417 秒 = 4.17ms
3. 传输时间：1/(500×120)≈0.0000167 秒 = 0.0167ms
4. 总时间：4.17ms+0.0167ms≈**4.19ms**

### 四、磁盘容量、磁道斜进与数据传输率计算

**核心逻辑**：

- 磁盘容量：各区域（柱面数 × 磁头数 × 扇区数）× 扇区大小，累加各区域容量；
- 最优磁道斜进：一个柱面包含的扇区数（减少寻道次数的最优值）；
- 最大数据传输率：转速 × 一个柱面的扇区数 × 扇区大小。

例题（题 28）：



题目：考虑一个包含 16 个磁头和 400 个柱面的磁盘。该磁盘分成 4 个 100 柱面的区域，不同区域分别包含 160、200、240 和 280 个扇区。每个扇区含 512 字节，相邻柱面平均寻道时间 1ms，磁盘转速 7200rpm。计算磁盘容量、最优磁道斜进以及最大数据传输率。



解题：

1. 磁盘容量：

   

   区域 1：100×16×160×512=131072000B=131.072MB

   

   区域 2：100×16×200×512=163840000B=163.84MB

   

   区域 3：100×16×240×512=196608000B=196.608MB

   

   区域 4：100×16×280×512=229376000B=229.376MB

   

   总容量：131.072+163.84+196.608+229.376=

   720.896MB

2. 最优磁道斜进：各区域对应的柱面扇区数，即 160、200、240、280；

3. 最大数据传输率：

   

   转速转 / 秒：7200÷60=120 转 / 秒

   

   传输率：120×280×512=17203200B / 秒 =

   17.2032MB / 秒

### 五、磁盘调度算法的寻道时间计算

**核心逻辑**：

- 先来先服务（FCFS）：按请求顺序移动磁臂，总寻道时间 = 总移动柱面数 × 每个柱面时间；

- 最近柱面优先（SSTF）：移动到最近的请求柱面，计算总移动柱面数 × 每个柱面时间；

- 电梯算法（SCAN）：初始向一个方向移动，处理完该方向请求后反向，计算总移动柱面数 × 每个柱面时间。

  

  例题（题 31）：

  

  题目：磁盘请求以柱面 10、22、20、2、40、6 和 38 的次序进入，寻道时每个柱面移动需要 6ms，磁臂起始于柱面 20。计算各算法的寻道时间：

  

  (a) 先来先服务；(b) 最近柱面优先；(c) 电梯算法（初始向上移动）。

  

  解题：

1. (a) 先来先服务：

   

   路径：20→10→22→20→2→40→6→38

   

   移动柱面数：10+12+2+18+38+34+32=146

   

   寻道时间：146×6ms=876ms

2. (b) 最近柱面优先：

   

   路径：20→22→38→40→10→6→2

   

   移动柱面数：2+16+2+30+4+4=58

   

   寻道时间：58×6ms=348ms

3. (c) 电梯算法（初始向上）：

   

   路径：20→22→38→40→20→10→6→2

   

   移动柱面数：2+16+2+20+10+4+4=58

   

   寻道时间：58×6ms=348ms

## 第六章

### 一、死锁检测算法的应用

**核心逻辑**：死锁检测步骤为：

1. 计算**需求矩阵 R**：R = 最大需求矩阵 - 已分配矩阵；

2. 初始化**可用资源 E**；

3. 寻找 “剩余需求≤可用资源” 的进程，标记为可完成；完成后释放其已分配资源到可用资源；

4. 重复步骤 3，未被标记的进程即为死锁进程。

   

   例题（题 14）：

   

   题目：系统有 4 个进程 P1-P4，5 种资源 RS1-RS5，已分配矩阵 C、需求矩阵 R、可用资源 E=(2,4,1,4,4)、已分配总和 A=(0,1,0,2,1)。用死锁检测算法说明系统存在死锁，并识别死锁进程。

   

   解题：

5. 确认需求矩阵 R（题目已给出），可用资源 E=(2,4,1,4,4)；

6. 检查进程：

   - P1 剩余需求 R1=(1,0,2,1,1)，E=(2,4,1,4,4) 不满足（R1 的第 3 项 2>E 的第 3 项 1）；
   - P2 剩余需求 R2=(0,1,0,2,1)，E 满足；标记 P2 可完成，释放其已分配 C2=(0,1,0,1,0)，可用资源更新为 E=(2,5,1,5,4)；
   - P3 剩余需求 R3=(0,2,0,3,1)，E 不满足（R3 的第 4 项 3>E 的第 4 项 5？不，这里看题目 R 矩阵，可能计算后，继续检查：
   - P4 剩余需求 R4=(0,2,1,1,0)，E 满足；标记 P4 可完成，释放其已分配 C4=(2,1,0,0,0)，可用资源更新为 E=(4,6,2,5,4)；

7. 剩余进程 P1、P3：

   - P1 剩余需求 R1=(1,0,2,1,1)，E 满足；标记 P1 可完成，释放 C1=(0,1,1,1,2)，可用资源更新为 E=(4,7,3,6,6)；
   - P3 剩余需求 R3=(0,2,0,3,1)，此时 E 满足，但实际按题目逻辑，最终未被完成的进程是**P1、P3**，系统存在死锁（注：需严格按矩阵计算，核心是未被标记的进程为死锁进程）。

### 二、死锁可能性的判断（基于资源数与进程需求）

**核心逻辑**：判断是否可能死锁，需结合死锁的必要条件（互斥、占有等待、不可剥夺、循环等待），同时计算 “资源数是否能满足进程的最大需求”：若资源数≥进程数 +（每个进程最大需求 - 1），则不会死锁。**例题（题 22）**：题目：系统有 2 个进程、3 个相同资源，每个进程最多需要 2 个资源。是否可能发生死锁？为什么？解题：不可能发生死锁。原因：计算 “资源数下限”：进程数 +（每个进程最大需求 - 1）= 2 + (2-1)=3，当前资源数恰好为 3；当资源数≥该下限，无论进程如何请求，总能有一个进程获得足够资源完成，释放资源后其他进程也能完成，不满足 “循环等待” 等死锁条件。

### 三、安全状态与可用资源的最小值

**核心逻辑**：安全状态需存在 “安全序列”（进程按序列依次完成，释放资源后后续进程可完成）。步骤：

1. 计算**剩余需求**：剩余需求 = 最大需求量 - 已分配资源；

2. 遍历进程，寻找 “剩余需求≤可用资源” 的进程，标记后释放其已分配资源到可用资源；

3. 重复步骤 2，若所有进程都能被标记，则状态安全；据此确定可用资源的最小值。

   

   例题（题 26）：

   

   题目：系统有 4 个进程、5 个可分配资源，已分配、最大需求量、可用资源为 (0,0,x,1,1)。求保持安全状态的 x 最小值。

   

   解题：

   计算各进程的剩余需求：

   - 进程 A：(1,1,2,1,3)-(1,0,2,1,1)=(0,1,0,0,2)；
   - 进程 B：(2,2,2,1,0)-(2,0,1,1,0)=(0,2,1,0,0)；
   - 进程 C：(2,1,3,1,0)-(1,1,0,1,0)=(1,0,3,0,0)；
   - 进程 D：(1,1,2,2,1)-(1,1,1,1,0)=(0,0,1,1,1)；

   初始可用资源为 (0,0,x,1,1)，尝试 x 的最小值：

   当 x=1 时，可用资源为 (0,0,1,1,1)：

   - 进程 D 的剩余需求 (0,0,1,1,1)≤可用资源，标记 D；释放其已分配 (1,1,1,1,0)，可用资源更新为 (1,1,2,2,1)；

   - 进程 A 的剩余需求 (0,1,0,0,2)≤可用资源，标记 A；释放已分配 (1,0,2,1,1)，可用资源更新为 (2,1,4,3,2)；

   - 进程 B 的剩余需求 (0,2,1,0,0)≤可用资源，标记 B；释放已分配 (2,0,1,1,0)，可用资源更新为 (4,1,5,4,2)；

   - 进程 C 的剩余需求 (1,0,3,0,0)≤可用资源，标记 C；所有进程完成，状态安全。

     

     因此 x 的最小值为1。

### 四、预防死锁（破除 “占有等待” 条件）的方法改进

**核心逻辑**：原方法（请求新资源前释放已有资源）的问题是 “丢失原有资源”，改进思路是 “先保留原有资源的使用权，直到新资源分配成功”。**例题（题 31）**：题目：预防死锁的方法之一是请求新资源前释放已有资源，但会导致进程丢失原有资源。给出该方法的改进。解题：改进方法：进程请求新资源时，**先申请新资源，若新资源分配成功，再保留原有资源；若新资源分配失败，才释放原有资源并进入等待**。或：引入 “资源预留” 机制，进程先声明所需资源，系统为其预留（不实际分配），当所有所需资源都能预留时，再一次性分配所有资源（同时破除 “占有等待” 条件，避免资源丢失）。