---
date: 2026-01-23
category:
  - 项目经验
tag:
  - React
  - TypeScript
---

# 农担项目所遇问题及总结

本周主要是农担项目的ui设计和开放，包括demo的一些撰写。接下来我会对印象深刻的地方进行总结，属于是想到哪里写哪里，但是靠前的自然是较为重要的，并非按照时间顺序排序的。

## **组件封装**

代码中有很多处组件的封装，例如SVG图标的组件封装，在代码中对于icon的展示有独特的封装， 它并非简单的存储svg，而是只存储svg的核心部分，然后再使用`forwardRef`来实现封装并后期利用className等对svg样式进行修改。这样在代码后续调用的时候就可以对svg图标进行丰富的自定义和操作。

首先是导入方式，此处在svg的路径后使用了`?react`后缀，其目的是告诉Vite：将这个SVG文件转换为一个React组件，这样在转化后`Assistant`就是一个可以直接渲染的React组件：`<Assistant / >`

```tsx
import Assistant from "./assistant.svg?react";
```

然后在对于类型的定义中，`SVGSVGElement`：说明ref指向的是`<svg>`DOM元素，`& { className: any }`为合并类型，因为转换后的SVG组件可能有className属性便于后期样式修改。

转发实现部分为`((props, ref) =>{}`，接收外部的`ref`和`props`并直接传递给底层的SVG组件，相当于建立了一个"透明"的传递层。

```tsx
import Assistant from "./assistant.svg?react";

export const AssistantIcon = forwardRef<
    SVGSVGElement & { className: any },
    React.PropsWithChildren<{ className?: string }>
>((props, ref) => {
    return <Assistant ref={ref} {...props} />;
});
...	其余封装类似
```

那么后面使用很方便的一点就是，在简单的导入同时可以利用贴上的ref来直接操作SVG DOM，并且能实现灵活的svg样式控制，例如

```tsx
import { AssistantIcon, SkillIcon, FlowIcon } from './icons';

const iconRef = useRef<SVGSVGElement>(null);  //定义标签iconRef
useEffect(() => {
  if (iconRef.current) {     //对标签对应组件的各种操作(也就是AssistantIcon这个svg)
    const bbox = iconRef.current.getBBox();     // 获取SVG的边界框
    iconRef.current.animate(...);      // 给svg元素添加动画
  }
}, []);  //仅在组件挂载时执行一次
// 此处传递操作并通过className灵活修改改样式
<AssistantIcon ref={iconRef}  className="w-6 h-6 text-red-500 hover:text-blue-500"/>;  //贴上iconRef标签
```



## **forwardRef**

### 定义

**`React.forwardRef`**是一个**高阶函数**，用于创建一个React组件。主要目的是让组件能够接收从其父组件传递下来的 `ref`，并将其“转发”到组件内部的某个具体的DOM元素或子组件。

### forwardRef接收的参数类型 

其中`forwardRef<T, P>` 接受两个泛型参数：

- **`T`**：`ref` 指向的**元素类型**
- **`P`**：组件接受的 **props 类型**

例如`forwardRef<SVGSVGElement & { className: any },    React.PropsWithChildren<{ className?: string }> >`中：

第一个参数：`SVGSVGElement & { className: any }`表示 `ref.current` 将是一个 **SVG `<svg>` 元素**，定义了ref这个标签指向的类型。在创建标签的时候就`const iconRef = useRef<SVGSVGElement>(null); // 这样声明ref就够了`

第二个参数这里是一个**工具类型**，它定义你传的prop只能有className或者children（或者两个都传），例如;

```tsx
/** 此处的props对象为：{ className: "icon-large", children:[
    "<span>图标</span>",
    "点击我" ]} 
 **/
<AssistantIcon className="icon-large">
   <span>图标</span> 点击我
</AssistantIcon>
```

### 代码样例

其实代码中很多地方还有类似的封装，例如对于各种卡片的样式部分，对卡片头部也有类似封装，其中 泛型 `<HTMLDivElement, ...>` 指定了ref指向的目标类型（一个div）和组件的属性类型：

```tsx
// 1. 使用 `forwardRef` 创建一个可以转发 ref 的组件
const CardHeader = React.forwardRef< 
    HTMLDivElement, // ref最终将被附加到的元素类型（这里是HTMLDivElement）
    React.HTMLAttributes<HTMLDivElement>   // 组件可以接收的所有props类型（包括所有标准div属性）
>( // 2. `forwardRef` 接收一个渲染函数作为参数，这个函数会接收 `props` 和从父组件传下来的 `ref` 作为其两个参数
        ({ className, ...props }, ref) => ( 
        // 3. 在内部，将 `ref` 和 `props` 都绑定到目标元素（div）上
    <div
        ref={ref}
        className={cname("flex flex-col space-y-1.5 p-5 pb-4", className)}
        {...props}
    />
        )
    )

// 4. 为组件设置一个清晰的 displayName，便于在React DevTools中调试
CardHeader.displayName = "CardHeader"
```

此处的ref可以理解为一个**“直接访问标记”**。他就像是给某个组件贴了一个带把手的名牌，那便可以通过这个**把手**（`ref.current`）直接**拉住**组件进行操作，而不是去通过React的正常“传话”系统（props和state）去间接影响它。因此修改`.current`**不会**触发重渲染儿修改state会触发重新渲染。

```tsx
import { useRef } from 'react';

function CardComponent() {
  // 创建ref，指定类型为HTMLDivElement（与forwardRef的泛型一致）
  const headerRef = useRef<HTMLDivElement>(null);

  const handleClick = () => {
    if (headerRef.current) {   //利用标签进行DOM元素的直接操作
      headerRef.current.style.backgroundColor = '#f0f9ff';
      headerRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  };

  return (
    <div>
      <CardHeader ref={headerRef} className="cursor-pointer">  //贴上标签headerRef，同时还传递自定义类名修改样式
        内容
      </CardHeader>
      <button onClick={handleClick}>高亮头部</button>
    </div>
  );
}
```

## 开会与vibe coding

周五还进行了开会，主要内容对于我来讲，就是改变自己编码者的身份，而更多的成为代码的审查者和一个架构者，对于能用ai完成的部分尽量用ai来提升效率，而对于我开发人员来讲，主要就是对代码和业务逻辑的宏观架构和调控。让ai写代码的时候就要更加考虑业务逻辑和代码的优化和后续的维护，而非功能的实现。当然也讲解了智能体的实现等等相关内容。

**Vibe Coding** 是一个与 AI 结对编程的终极工作流程，旨在帮助开发者丝滑地将想法变为现实。本指南详细介绍了从项目构思、技术选型、实施规划到具体开发、调试和扩展的全过程，强调以**规划驱动**和**模块化**为核心，避免让 AI 失控导致项目混乱。这里我还找到了一个食用指南：[vibe-coding-cn](https://github.com/tukuaiai/vibe-coding-cn)

当然在ai使用中有很多导致错误的坑，例如对这次项目来说ai修改很坑的一点是改的不完全，例如对于logo判断这里应该是：

```tsx
 {logo ? (typeof logo === 'string' ? 
                            <div className="max-w-6 min-w-6 max-h-6 rounded-full overflow-hidden bg-transparent">
                                <img className="w-6 h-6" src={logo} />
                            </div>
                            : <div className="w-6 h-6 min-w-6 flex justify-center items-center bg-transparent">
                                {logo}
                            </div>
                        ) : <div className="w-8 h-8 min-w-6 flex justify-center items-center bg-transparent" >
                                {/* <AvatarIcon /> */}
                                <img src="/workflow.svg" alt="aiLogo" />
                            </div>}
```

但是ai有些地方改了有些地方没改，导致后续的logo展示就会有地方展示失败。还有就是对于类名写错的情况，例如对于类名中间加空格导致react没法正常识别出现bug，ai并不能正常的进行识别。这里的h-[calc(100%-104px)]写成了h-[calc(100% - 104px)] 都没法识别，无效改了半天，浪费了时间。



## 项目git拉取

这个地方有个坑，如果你直接点分支的右上角那个clone按钮复制链接进行git clone,得到的是main分支下的文件而非你所想要的那个分支。正确的方法应该是 克隆的时候克隆指定分支，如这里是customer/cqnd/main分支：

```cmd
git clone -b customer/cqnd/main git@git.un-net.com:unnet-llm/adp/postwise.git
```

这样获得的文件才是你想要的那个分支的。



## 项目启动但无法访问页面

先排查路由文件，路由文件没问题通过命令行进行curl查看

```cmd
curl http://localhost:4001/workspace
```

如果返回`curl: (52) Empty reply from server`表示服务器接受了连接，但没有返回任何数据就关闭了连接。有几种可能的原因和解决方法：

###  检查端口占用

这里我是4001端口

```bash
# 查找哪个进程在使用 4001 端口
netstat -ano | findstr :4001
# 记下 PID，然后在任务管理器中查看
```

返回结果：

```bash
C:\Users\wh826>netstat -ano | findstr :4001
  TCP    0.0.0.0:4001           0.0.0.0:0              LISTENING       19416
  TCP    127.0.0.1:4001         0.0.0.0:0              LISTENING       6112
  TCP    127.0.0.1:4001         127.0.0.1:51385        TIME_WAIT       0
  TCP    127.0.0.1:4001         127.0.0.1:58250        TIME_WAIT       0
  TCP    127.0.0.1:50096        127.0.0.1:4001         TIME_WAIT       0
  TCP    127.0.0.1:59318        127.0.0.1:4001         TIME_WAIT       0
```

显然看前两个，后面的是回环端口，发现两个进程在争夺同一个端口，则使用 PowerShell进行进程id查看

```powershell
Get-Process -Id 19416,6112
```

然后停止其中的进程或者应用

```powershell
taskkill /PID 6112 /F
```



## 下载请求得到undefine

这个是Blob的解析异常，应该首先看axios的拦截器，有些返回的是response.data导致请求异常，当响应是 Blob 类型（如下载文件）时，拦截器中的 `response.data` 会被自动转换，这可能导致错误。这里需要对响应拦截器进行修改，增加对于blob类型的响应的判断，如果是此类型直接返回response。或者直接选择绕过利用fetch进行请求。

增加blob类型的响应的判断判断:

```ts
customAxios.interceptors.response.use(function (response) {
    // 检查是否是 blob 响应 ,对于 blob 响应，直接返回 response 而不是 response.data
    if (response.config.responseType === 'blob' || 
        response.headers['content-type']?.includes('application/octet-stream') ||
        response.headers['content-type']?.includes('application/vnd.ms-excel') ||
        response.headers['content-type']?.includes('application/pdf')) {
    
      return response;
    }
    .....后续代码
}
```

那么对应的请求应该规定好返回的类型(这里定义好了返回类型是AxiosResponse，方便后续处理)：

```ts
import { AxiosResponse } from "axios";
import axios from "../request";

//下载知识库文件，规定好responseType
export async function downloadFile(knowledge_id:number, file_id:number): Promise<import('axios').AxiosResponse> {
  const token = localStorage.getItem('ws_token');
  return axios.get(`/api/v2/filelib/knowledge/file/download/${knowledge_id}/${file_id}`, {
    responseType: 'blob',
  })
}
```

## 文件下载

在前面配置好然后就能调用请求进行文件下载了，这里的外层包裹的函数 captureAndAlertRequestErrorHoc是用于对抛出的错误消息进行处理并展示弹窗。同时注意如果下载请求返回的数据类型是json的说明请求遇到错误则抛出异常：

```ts
const handleDownload = (file) => {
        captureAndAlertRequestErrorHoc(
            downloadFile(Number(id), file.id).then(async (response) => {
                // 检查响应内容类型，注意：现在 response 是 AxiosResponse 对象
                const contentType = response.headers['content-type'] || '';

                // 如果返回的是 JSON（可能是错误响应），先检查
                if (contentType.includes('application/json')) {
                    // Axios 中，response.data 已经是 blob，需要转换为文本再解析
                    const text = await new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsText(response.data);
                    });

                    const errorData = text ? JSON.parse(text as string) : {};
                    if (errorData.status_code && errorData.status_code !== 200) {
                        throw new Error(`下载失败: ${errorData.status_message || errorData.message || errorData.status_code}`);
                    }
                }
                if (response.status !== 200) {
                    throw new Error(`下载失败: ${response.status} ${response.statusText}`);
                }

                // response.data 已经是 blob 数据，因为设置了 responseType: 'blob'
                const blob = response.data;
                // 检查 blob 是否有效
                if (!blob || blob.size === 0) {
                    throw new Error('下载失败: 文件内容为空');
                }

                // 使用原始文件名
                let fileName = file.file_name;

                // 创建临时 URL 和下载链接
                const downloadUrl = window.URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = downloadUrl;
                link.download = fileName;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                window.URL.revokeObjectURL(downloadUrl);
            })
        );
    }
```





## react基础学习

 React 的三大核心概念：**JSX**、**组件 & Props**、**Hooks**。

### 一、JSX：JavaScript + XML

它是一种 JavaScript 的语法扩展，允许你在 JavaScript 代码中直接书写类似 HTML 的结构，用来**描述 UI 应该是什么样子**。

**核心要点**：

1. **它不是字符串，也不是HTML**，最终会被编译成普通的 JavaScript 对象（React 元素）。
2. **必须有一个根元素**。早期必须用 `<div>` 包裹，现在推荐使用空的 `<>`（片段）包裹，避免添加无意义的 DOM 节点。
3. **在 JSX 中嵌入 JavaScript 表达式**：使用单花括号 `{}`。这可以是变量、函数调用，或者任何返回值的表达式。
4. **属性名采用小驼峰命名**：例如 `class` 要写成 `className`，`onclick` 要写成 `onClick`。
5. **JSX 本身也是一个表达式**：可以在 `if` 语句、`for` 循环中使用，可以赋值给变量，也可以作为函数的参数或返回值。

```jsx
// 嵌入 JavaScript 表达式
const name = 'Alice';
const element = <h1>Hello, {name}</h1>;

// JSX 也是一个表达式，可以在条件或循环中使用
const showWelcome = true;
const greeting = (
  <>
    {showWelcome ? <h1>Welcome!</h1> : <h1>Please Login</h1>}
    <ul>
      {['Task 1', 'Task 2'].map((item) => (
        <li key={item}>{item}</li>
      ))}
    </ul>
  </>
);
```



### 二、组件与 Props

**组件**是 React 应用的**构建块**。每个组件都是一个独立的、可复用的 UI 片段。

- **定义组件**：就是一个返回 JSX 的 **JavaScript 函数**。**函数名必须以大写字母开头**（这是 React 区分组件和原生 HTML 标签的方式）。
- **使用组件**：像使用 HTML 标签一样使用它 `<Welcome />`。
- **Props**：是组件的 **“输入参数”** ，用于父组件向子组件传递数据。它是以属性形式写在组件标签上的，组件函数通过第一个参数（通常命名为 `props`）接收。**Props 是只读的**，组件不能修改自己的 props。

```jsx
// 1. 定义一个组件 (函数名大写！)
function Welcome(props) { // props 接收传入的数据
  // props 是只读的
  return <h1>Hello, {props.name}</h1>;
}

// 2. 使用组件，并传递 props (name="Sara")
function App() {
  return (
    <div>
      <Welcome name="Sara" />
      <Welcome name="Cahal" />
      <Welcome name="Edite" />
    </div>
  );
}

//或者循环调用，注意 name={item} 才会传递动态值即传递数组中的数字值，且要加 key 属性
const userList = [
  { id: 101, name: '张三', age: 25 },
  { id: 102, name: '李四', age: 30 },
  { id: 103, name: '王五', age: 28 }
];
function UserList() {
  return (
    <div className="user-list">
      <h2>用户列表</h2>
      {userList.map(user => (
        <Welcome 
          key={user.id}          // 使用唯一 id 作为 key
          name={user.name} 
          age={user.age}
        />
      ))}
    </div>
  );
}

```



**⚠️ 一个关键规则**：**永远不要在组件内部定义另一个组件**。这会导致每次父组件渲染时，子组件都被重新创建和卸载，导致性能问题和状态丢失。正确的做法是将每个组件定义在模块顶层。

```jsx
// ❌ 错误！禁止在组件内定义组件
function App() {
  function Welcome() { // 每次 App 渲染都会重新定义 Welcome
    return <h1>Hello</h1>;
  }
  return <Welcome />;
}

// ✅ 正确！将组件定义在顶层
function Welcome() {
  return <h1>Hello</h1>;
}
function App() {
  return <Welcome />;
}
```



### 三、Hooks：状态和生命周期

在 Hooks 出现之前，函数组件只能接收 props 渲染 UI，没有状态和生命周期。**Hooks 是一系列以 `use` 开头的特殊函数，它们让你能在函数组件中使用 React 的各种特性**。

**两个最核心的 Hook**：

1. **`useState` - 管理状态**

   - **作用**：在函数组件中添加内部可变的“状态”（state）。
   - **返回值**：返回一个包含两个元素的数组：`[当前状态值, 更新状态的函数]`。
   - **更新状态**：必须使用它返回的 `set` 函数来更新，直接修改 state 变量不会触发重新渲染。

   ```jsx
   import { useState } from 'react';
   function Counter() {
     // count 是当前状态值，setCount 是更新它的函数
     const [count, setCount] = useState(0); // 初始状态为 0
     return (
       <button onClick={() => setCount(count + 1)}>
         You clicked {count} times
       </button>
     );
   }
   ```

   

2. **`useEffect` - 处理副作用**

   - **作用**：让你在函数组件中执行副作用操作。**副作用**是指那些与渲染结果无关的操作，如数据获取、订阅、手动修改 DOM 等。
   - **执行时机**：默认情况下，它在 **每次组件渲染完成后**（包括首次渲染）执行。
   - **依赖数组**：第二个参数是一个数组，用于控制 effect 的执行条件。这是优化性能的关键。
     - `useEffect(fn)`：**无依赖数组**，每次渲染都执行。
     - `useEffect(fn, [])`：**空数组**，仅在组件挂载时执行一次（类似 vue中的`onMounted`），。
     - `useEffect(fn, [a, b])`：**依赖项数组**，当 `a` 或 `b` 的值发生变化时才执行。

   ```javascript
   import { useState, useEffect } from 'react';
   function Timer() {
     const [seconds, setSeconds] = useState(0);
     useEffect(() => {
       // 这是一个副作用：设置定时器
       const intervalId = setInterval(() => {
         setSeconds(s => s + 1);
       }, 1000);
       // 清理函数：在组件卸载或下一次 effect 执行前运行
       return () => clearInterval(intervalId);
     }, []); // 空依赖数组，表示此 effect 只在组件挂载时运行一次
     return <div>Seconds: {seconds}</div>;
   }
   ```

**Hooks 使用规则（铁律）**：

- **只在 React 函数的最顶层调用 Hook**。不要在循环、条件判断或嵌套函数中调用。
- **只在 React 函数组件或自定义 Hook 中调用 Hook**。不要在普通的 JavaScript 函数中调用。

### 总结与关系

你可以这样理解它们的关系：你用 **JSX** 语法在 **组件** 的函数体内描述 UI 结构；父组件通过 **Props** 将数据和控制逻辑传递下来；组件内部用 **Hooks** 来管理自己的状态（`useState`）和响应外部世界的变化（`useEffect`）。这三者共同构成了一个 React 组件的完整逻辑。
