<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.20" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme='dark'] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background-color: var(--vp-c-bg);
      }
    </style>
    <script>
      const useChoice = localStorage.getItem('vuepress-color-scheme')
      const systemStatus =
        'matchMedia' in window
          ? window.matchMedia('(prefers-color-scheme: dark)').matches
          : false

      if (useChoice === 'light') {
        document.documentElement.dataset.theme = 'light'
      } else if (useChoice === 'dark' || systemStatus) {
        document.documentElement.dataset.theme = 'dark'
      }
    </script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js" defer></script><title>React基础入门 | xh's blog </title><meta name="description" content="A VuePress bolg Site for personal useage">
    <link rel="preload" href="/vuepress_blog/assets/style-DHqMCh0M.css" as="style"><link rel="stylesheet" href="/vuepress_blog/assets/style-DHqMCh0M.css">
    <link rel="modulepreload" href="/vuepress_blog/assets/app-UmXydJji.js"><link rel="modulepreload" href="/vuepress_blog/assets/react入门.html-DfLkVr-w.js">
    <link rel="prefetch" href="/vuepress_blog/assets/get-started.html-BrW2OPcu.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-S6-rR0CJ.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/初级大模型算法工程师入门入门规划.html-PUD1hSiK.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/操作系统.html-YNNKIn6e.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/操作系统例题讲解.html-B-6_ekdl.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/操作系统课后题目.html-DlApKp0k.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/操作系统重难点.html-M5l9okRE.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/网络协议分析.html-B0mjkNCX.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/网络协议分析题.html-yvjyltqR.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/网络安全.html-fOPBAX77.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/网络安全重点.html-DGVv5IzC.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/软件定义网络.html-C67XijOI.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/软件定义网络重点.html-6Z3iflPr.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/软件定义网络题.html-BU6JilnL.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/SSEDemoFronted.html-CkMTwiLD.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/sseDomeServer.html-CMTtiZ0q.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/sseService.html-DLsLrZ5r.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/sseServiceWithBroadcastChannel.html-92dTtKay.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/docker部署流程.html-DqTH97bC.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/全栈开发.html-VUAWgHhY.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/项目经验.html-DUtouFrA.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/实习周总结1.html-DaCt6wvi.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/实习周总结2.html-BY7LBVJh.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/实习周总结3.html-C5mwoDrK.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/实习周总结4.html-CBxQOGEn.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/实习周总结5.html-DCgmTcP6.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/实习经验.html-Dkk6S6Zk.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/前端面试八股文.html-DQw4HnpF.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/基础算法.html-CLOvrdrI.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/倒货经验总结.html-CL4iQ_7G.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/todolist建立.html-B5EjdCgT.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/硅谷甄选项目笔记.html-DqHEbjP1.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/docsify项目创建与部署.html-CpLorkJ_.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/插件公式示例.html-B33CRABu.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/算法刷题.html-CXEaZEAR.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/组件传值与代码规范.html-DaePJcxq.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/nuxt.html-BVl7vC9r.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/Nuxt4.html-De03BzNK.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/react小实践.html-DOHkAIiK.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/农担项目所遇问题及总结.html-DyTzNiLQ.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/Http.html-BpCPFPFy.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/Nginx.html-DwHWNYWU.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/element-plus.html-Dt0Shoe-.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/vitest.html-BbKkgsi4.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/Vuepress上手.html-DYIwU6Ih.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/Vue探索.html-qlFs5-z_.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/BroadcastChannel方式解决sse连接数限制.html-6GwTFg2t.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/BroadcastChannel版本sse解读.html-Adx7YZ9b.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/sseService文件解析.html-CFu3fdr4.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/SSE实践测试.html-CjSzpvRb.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/SSE简介.html-D_5DeskR.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/流的处理.html-tw-jDSu6.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/404.html-472gSdLs.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-D4Vr1x4U.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-D8BmJRWK.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-DtbrREu1.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-CgGRLfzl.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-NnkC358F.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-C3eHk0Vo.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-HpkemBGh.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-BX-QMr8T.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-C3D2GhaK.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-BPrdVcRz.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-CCEYsNkj.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-B2JiFNeM.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-Bt2CbkVn.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-DzDHRR9E.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-Clc2oEJx.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-cvbG_VKD.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-jmKdmd-f.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-Bw9losca.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-COZGe3TG.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-Bo82Xr6G.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-DUExu0Mr.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-DlomL8bU.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-DbNnBFIB.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-BYZrx3C-.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-lH_oohfr.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-CM3W7KJs.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-BTsj8QAg.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-C9z1iF9P.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-BLMxlOAl.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-BAbqhVZZ.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-B3MMSr5C.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-DI57HGoX.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-DjiCImKB.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-C3CBBVRX.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-DoDaI2dM.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-zq0tpgC6.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-B_2lmY7-.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-RbGocMDB.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-CdlxNR7n.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-D7Fl-7bv.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-CoM2O_F8.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-CU0fp3Et.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-CYcDJCeV.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-_3AD9UeM.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/SearchResult-Dq26a1PS.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/browser-B92KtQ1J.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/social-share-l0sNRNKZ.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/giscus-DrGxERkK.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="vp-theme-container external-link-icon" vp-container><!--[--><header class="vp-navbar" vp-navbar><div class="vp-toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a class="route-link" href="/vuepress_blog/"><!----><span class="vp-site-name vp-hide-mobile" aria-hidden="true">xh&#39;s blog </span></a></span><div class="vp-navbar-items-wrapper" style=""><!--[--><!--]--><nav class="vp-navbar-items vp-hide-mobile" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/vuepress_blog/article/" aria-label="文章"><!--[--><!--[--><!--]--><!--]-->文章<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/vuepress_blog/category/" aria-label="分类"><!--[--><!--[--><!--]--><!--]-->分类<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/vuepress_blog/tag/" aria-label="标签"><!--[--><!--[--><!--]--><!--]-->标签<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/vuepress_blog/timeline/" aria-label="时间线"><!--[--><!--[--><!--]--><!--]-->时间线<!--[--><!--[--><!--]--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button type="button" class="vp-toggle-color-mode-button" title="toggle color mode"><svg class="light-icon" viewbox="0 0 32 32" style=""><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg class="dark-icon" viewbox="0 0 32 32" style="display:none;"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!--[--><button type="button" class="slimsearch-button" aria-label="搜索"><svg xmlns="http://www.w3.org/2000/svg" class="icon search-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="search icon"><path d="M192 480a256 256 0 1 1 512 0 256 256 0 0 1-512 0m631.776 362.496-143.2-143.168A318.464 318.464 0 0 0 768 480c0-176.736-143.264-320-320-320S128 303.264 128 480s143.264 320 320 320a318.016 318.016 0 0 0 184.16-58.592l146.336 146.368c12.512 12.48 32.768 12.48 45.28 0 12.48-12.512 12.48-32.768 0-45.28"></path></svg><div class="slimsearch-placeholder">搜索</div><div class="slimsearch-key-hints"><kbd class="slimsearch-key">Ctrl</kbd><kbd class="slimsearch-key">K</kbd></div></button><!--]--></div></header><!--]--><div class="vp-sidebar-mask"></div><!--[--><aside class="vp-sidebar" vp-sidebar><nav class="vp-navbar-items" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/vuepress_blog/article/" aria-label="文章"><!--[--><!--[--><!--]--><!--]-->文章<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/vuepress_blog/category/" aria-label="分类"><!--[--><!--[--><!--]--><!--]-->分类<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/vuepress_blog/tag/" aria-label="标签"><!--[--><!--[--><!--]--><!--]-->标签<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/vuepress_blog/timeline/" aria-label="时间线"><!--[--><!--[--><!--]--><!--]-->时间线<!--[--><!--[--><!--]--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="vp-sidebar-items"><!--[--><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">React基础入门 <!----></p><!----></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="vp-page"><!--[--><!--]--><div vp-content><!--[--><!--]--><div><h1 id="react基础入门" tabindex="-1"><a class="header-anchor" href="#react基础入门"><span>React基础入门</span></a></h1><h2 id="基础入门" tabindex="-1"><a class="header-anchor" href="#基础入门"><span>基础入门</span></a></h2><h3 id="一、核心认知-react-是什么-类比-vue" tabindex="-1"><a class="header-anchor" href="#一、核心认知-react-是什么-类比-vue"><span>一、核心认知：React 是什么？（类比 Vue）</span></a></h3><p>Vue3 是「渐进式框架」，有完整的模板、指令、响应式体系；React 是「UI 库」（核心只管视图渲染），更像「函数式的视图生成器」，核心思想：<strong>用函数描述 UI，数据变了函数重新执行，UI 就更新</strong>。</p><h3 id="关键类比-vue3-→-react" tabindex="-1"><a class="header-anchor" href="#关键类比-vue3-→-react"><span>关键类比（Vue3 → React）</span></a></h3><table><thead><tr><th>Vue3 概念</th><th>React 对应概念</th><th>核心差异</th></tr></thead><tbody><tr><td>单文件组件.vue</td><td>组件文件.tsx/.jsx</td><td>React 用 JSX 写模板（HTML 嵌 JS）</td></tr><tr><td>setup () 语法糖</td><td>函数组件</td><td>React 组件本质是返回 JSX 的函数</td></tr><tr><td>ref/reactive</td><td>useState/useReducer</td><td>React 响应式是「显式更新」</td></tr><tr><td>watch/watchEffect</td><td>useEffect/useLayoutEffect</td><td>副作用监听需手动指定依赖</td></tr><tr><td>Props 传值</td><td>Props 传值</td><td>逻辑一致，TS 类型声明方式不同</td></tr><tr><td>插槽 Slot</td><td>组件传子元素 / Props</td><td>React 无插槽，用「传元素」替代</td></tr></tbody></table><h3 id="二、极速上手-从「写一个按钮」开始" tabindex="-1"><a class="header-anchor" href="#二、极速上手-从「写一个按钮」开始"><span>二、极速上手：从「写一个按钮」开始</span></a></h3><h4 id="_1-环境准备-类比-vue-cli-vite" tabindex="-1"><a class="header-anchor" href="#_1-环境准备-类比-vue-cli-vite"><span>1. 环境准备（类比 Vue CLI/Vite）</span></a></h4><p>React 常用构建工具：</p><ul><li>Vite：<code>npm create vite@latest my-react -- --template react-ts</code>（和 Vue3 用 Vite 几乎一样）</li><li>启动：<code>cd my-react &amp;&amp; npm i &amp;&amp; npm run dev</code></li></ul><h4 id="_2-第一个组件-tsx-版-类比-vue3-单文件组件" tabindex="-1"><a class="header-anchor" href="#_2-第一个组件-tsx-版-类比-vue3-单文件组件"><span>2. 第一个组件（TSX 版，类比 Vue3 单文件组件）</span></a></h4><p>Vue3 你习惯这么写：</p><div class="language-vue line-numbers-mode" data-highlighter="prismjs" data-ext="vue"><pre><code><span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span></span>
<span class="line">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>count++<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>点击{{ count }}次<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">setup</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>ts<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript"></span>
<span class="line"><span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span>
<span class="line"></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>React 等价写法（TSX）：</p><div class="language-tsx line-numbers-mode" data-highlighter="prismjs" data-ext="tsx"><pre><code><span class="line"><span class="token comment">// src/Button.tsx</span></span>
<span class="line"><span class="token keyword">import</span> <span class="token punctuation">{</span> useState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;react&#39;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 函数组件 = Vue3 setup + template 合体</span></span>
<span class="line"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">MyButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">// useState：类比 ref(0)，返回[值, 修改值的方法]（React 必须用方法更新，不能直接改）</span></span>
<span class="line">  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useState</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">  <span class="token comment">// JSX = Vue 模板，语法更贴近 JS</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token punctuation">(</span></span>
<span class="line">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text"></span>
<span class="line">      点击</span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token plain-text">次</span>
<span class="line">    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span></span>
<span class="line">  <span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="核心形象化理解" tabindex="-1"><a class="header-anchor" href="#核心形象化理解"><span>核心形象化理解：</span></a></h4><ul><li>React 组件 = 「UI 工厂函数」：输入 Props / 状态，输出 JSX（UI）；</li><li>useState = 「状态盒子」：盒子里装着 count，只有用 setCount 才能打开盒子改值（Vue 的 ref 是「自动更新的盒子」）；</li><li>onClick = 「事件触发器」：和 Vue 的 @click 一样，只是 React 用驼峰命名（onClick、onChange）。</li></ul><h4 id="_3-组件传值-props-类比-vue-props" tabindex="-1"><a class="header-anchor" href="#_3-组件传值-props-类比-vue-props"><span>3. 组件传值（Props，类比 Vue Props）</span></a></h4><p>Vue3 传值：</p><div class="language-vue line-numbers-mode" data-highlighter="prismjs" data-ext="vue"><pre><code><span class="line"><span class="token comment">&lt;!-- 父组件 --&gt;</span></span>
<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MyButton</span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>测试按钮<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span></span>
<span class="line"></span>
<span class="line"><span class="token comment">&lt;!-- 子组件 --&gt;</span></span>
<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">setup</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>ts<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript"></span>
<span class="line">defineProps<span class="token operator">&lt;</span><span class="token punctuation">{</span> <span class="token literal-property property">title</span><span class="token operator">:</span> string <span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>React 等价写法：</p><div class="language-tsx line-numbers-mode" data-highlighter="prismjs" data-ext="tsx"><pre><code><span class="line"><span class="token comment">// 子组件 Button.tsx</span></span>
<span class="line"><span class="token keyword">interface</span> <span class="token class-name">ButtonProps</span> <span class="token punctuation">{</span></span>
<span class="line">  title<span class="token operator">:</span> <span class="token builtin">string</span></span>
<span class="line">  count<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token comment">// 可选属性，类比 Vue Props 可选</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// Props 作为函数参数传入</span></span>
<span class="line"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">MyButton</span><span class="token punctuation">(</span>props<span class="token operator">:</span> ButtonProps<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token punctuation">(</span></span>
<span class="line">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text"></span>
<span class="line">      </span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>title<span class="token punctuation">}</span><span class="token plain-text">：点击</span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token plain-text">次</span>
<span class="line">    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span></span>
<span class="line">  <span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 父组件 App.tsx</span></span>
<span class="line"><span class="token keyword">import</span> MyButton <span class="token keyword">from</span> <span class="token string">&#39;./Button&#39;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token punctuation">(</span></span>
<span class="line">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text"></span>
<span class="line">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">MyButton</span></span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>测试按钮<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text"></span>
<span class="line">    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span></span>
<span class="line">  <span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="形象化" tabindex="-1"><a class="header-anchor" href="#形象化"><span>形象化：</span></a></h4><p>React Props = 「工厂的原材料」：父组件把 title 传给子组件（工厂），工厂用原材料生产 UI。</p><h4 id="_4-副作用-类比-vue-watch-watcheffect" tabindex="-1"><a class="header-anchor" href="#_4-副作用-类比-vue-watch-watcheffect"><span>4. 副作用（类比 Vue watch/watchEffect）</span></a></h4><p>Vue3 监听 count 变化：</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code><span class="line"><span class="token function">watch</span><span class="token punctuation">(</span>count<span class="token punctuation">,</span> <span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;count变了：&#39;</span><span class="token punctuation">,</span> newVal<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>React 用 useEffect 实现：</p><div class="language-tsx line-numbers-mode" data-highlighter="prismjs" data-ext="tsx"><pre><code><span class="line"><span class="token keyword">import</span> <span class="token punctuation">{</span> useState<span class="token punctuation">,</span> useEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;react&#39;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">MyButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">  <span class="token comment">// useEffect = 「副作用容器」：组件渲染/更新后执行</span></span>
<span class="line">  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;count变了：&#39;</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span></span>
<span class="line">    <span class="token comment">// 依赖数组 = 监听的状态，类比 Vue watch 的第一个参数</span></span>
<span class="line">  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">  <span class="token keyword">return</span> <span class="token punctuation">(</span></span>
<span class="line">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">点击</span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token plain-text">次</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span></span>
<span class="line">  <span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="核心形象化" tabindex="-1"><a class="header-anchor" href="#核心形象化"><span>核心形象化：</span></a></h4><p>useEffect = 「善后处理员」：组件渲染完（UI 画好），处理异步、监听、DOM 操作等「善后工作」；依赖数组 = 「触发开关」：只有数组里的状态变了，才会重新执行 useEffect（空数组 = 只执行一次，类比 Vue 的 watch 立即执行 + 只监听一次）。</p><h3 id="三、react-核心灵魂-jsx-语法-类比-vue-模板" tabindex="-1"><a class="header-anchor" href="#三、react-核心灵魂-jsx-语法-类比-vue-模板"><span>三、React 核心灵魂：JSX 语法（类比 Vue 模板）</span></a></h3><p>JSX 是「JS 的语法扩展」，可以理解为「能写 HTML 的 JS」，核心规则：</p><ol><li>标签必须闭合：<code>&lt;div /&gt;</code>（类比 Vue 自闭合标签）；</li><li>只能有一个根节点：用 <code>&lt;&gt;&lt;/&gt;</code>（空标签，类比 Vue 的 <code>&lt;template&gt;</code> 根节点）包裹；</li><li>插值用 <code>{}</code>：<code>{count}</code>、<code>{props.title}</code>（类比 Vue 的 <code>{{}}</code>）；</li><li>样式用对象：<code>style={{ color: &#39;red&#39;, fontSize: &#39;16px&#39; }}</code>（类比 Vue 的 :style）；</li><li>class 用 className：<code>&lt;div className=&quot;box&quot; /&gt;</code>（因为 class 是 JS 关键字）。</li></ol><p>形象化：</p><p>JSX = 「HTML 和 JS 的混血儿」：既像 HTML 一样写结构，又能直接在里面写 JS 逻辑（比如 <code>{count &gt; 5 &amp;&amp; &lt;span&gt;超过5次&lt;/span&gt;}</code>，类比 Vue 的 <code>v-if</code>）。</p><h3 id="四、vue3-→-react-核心思维转换" tabindex="-1"><a class="header-anchor" href="#四、vue3-→-react-核心思维转换"><span>四、Vue3 → React 核心思维转换</span></a></h3><ol><li>「自动响应式」→「显式更新」：Vue 改 ref/reactive 自动更 UI，React 必须调用 setXxx 触发重渲染；</li><li>「模板分离」→「JSX 融合」：Vue 模板和逻辑分开，React 逻辑和 UI 写在同一个函数里（更贴近「数据驱动 UI」的本质）；</li><li>「指令化」→「函数式」：Vue 用 v-if/v-for 指令，React 用 JS 的 if/for 写逻辑（比如 <code>{list.map(item =&gt; &lt;li key={item.id}&gt;{item.name}&lt;/li&gt;)}</code> 类比 v-for）。</li></ol><h2 id="pick" tabindex="-1"><a class="header-anchor" href="#pick"><span>Pick</span></a></h2><h3 id="一、核心含义" tabindex="-1"><a class="header-anchor" href="#一、核心含义"><span>一、核心含义</span></a></h3><p><code>Pick&lt;SearchCriteria, &quot;page&quot; | &quot;pageSize&quot;&gt;</code> ，这是 TypeScript 内置的<strong>工具类型 <code>Pick</code></strong>，作用是<strong>从一个已有类型中「挑选」指定的属性，生成一个全新的、仅包含这些属性的类型</strong>，是 TS 类型编程中最常用的工具之一（你有 Vue3+TS 基础，理解这个会很轻松）。</p><h4 id="_1-语法拆解" tabindex="-1"><a class="header-anchor" href="#_1-语法拆解"><span>1. 语法拆解</span></a></h4><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code><span class="line">Pick<span class="token operator">&lt;</span>原类型<span class="token punctuation">,</span> 要挑选的属性名 <span class="token operator">|</span> 多个属性用 <span class="token operator">|</span> 分隔<span class="token operator">&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>对应到代码里：</p><ul><li><code>SearchCriteria</code>：原类型（你项目中定义的筛选条件完整类型，包含 <code>page</code>、<code>pageSize</code>、<code>startTime</code>、<code>keyword</code>、<code>minExecutionTime</code> 等所有字段）；</li><li><code>&quot;page&quot; | &quot;pageSize&quot;</code>：要挑选的属性（仅保留分页相关的 <code>page</code> 和 <code>pageSize</code>，排除其他筛选字段）；</li><li>最终 <code>Pick&lt;SearchCriteria, &quot;page&quot; | &quot;pageSize&quot;&gt;</code> 生成的新类型 = <strong>只有 <code>page</code> 和 <code>pageSize</code> 两个属性的类型</strong>，没有 <code>startTime</code>、<code>keyword</code> 等其他字段。</li></ul><h4 id="_2-形象化理解-类比-vue3-ts-场景" tabindex="-1"><a class="header-anchor" href="#_2-形象化理解-类比-vue3-ts-场景"><span>2. 形象化理解（类比 Vue3+TS 场景）</span></a></h4><p>假设你的 <code>SearchCriteria</code> 完整类型是这样的：</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code><span class="line"><span class="token comment">// 完整的筛选条件类型</span></span>
<span class="line"><span class="token keyword">interface</span> <span class="token class-name">SearchCriteria</span> <span class="token punctuation">{</span></span>
<span class="line">  page<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> <span class="token comment">// 页码</span></span>
<span class="line">  pageSize<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> <span class="token comment">// 页大小</span></span>
<span class="line">  keyword<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> <span class="token comment">// 关键词</span></span>
<span class="line">  startTime<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> <span class="token comment">// 开始时间</span></span>
<span class="line">  endTime<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> <span class="token comment">// 结束时间</span></span>
<span class="line">  minExecutionTime<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> <span class="token comment">// 最小执行时间</span></span>
<span class="line">  databaseName<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> <span class="token comment">// 数据库名</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>用 <code>Pick&lt;SearchCriteria, &quot;page&quot; | &quot;pageSize&quot;&gt;</code> 后，生成的新类型等价于：</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code><span class="line"><span class="token comment">// Pick 自动生成的新类型（无需手动写）</span></span>
<span class="line"><span class="token keyword">interface</span> <span class="token class-name">PickedCriteria</span> <span class="token punctuation">{</span></span>
<span class="line">  page<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span></span>
<span class="line">  pageSize<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_3-为什么要用-pick-核心价值" tabindex="-1"><a class="header-anchor" href="#_3-为什么要用-pick-核心价值"><span>3. 为什么要用 <code>Pick</code>（核心价值）</span></a></h4><p>在之前的代码中，<code>getBaseCriteria</code> 函数的目的是「仅返回分页相关的基础字段」，用 <code>Pick</code> 有 3 个关键作用：</p><ul><li><strong>类型安全</strong>：强制函数返回值只能包含 <code>page</code> 和 <code>pageSize</code>，如果不小心返回了 <code>startTime</code> 等字段，TS 会直接报错（避免手写漏检）；</li><li><strong>复用已有类型</strong>：不用重新写一个只有 <code>page</code>/<code>pageSize</code> 的新接口，直接复用 <code>SearchCriteria</code>，后续如果 <code>SearchCriteria</code> 里的 <code>page</code> 类型从 <code>number</code> 改成其他，这里会自动同步，减少维护成本；</li><li><strong>语义清晰</strong>：一眼就能看出「从完整筛选条件中挑选分页字段」，比手动写新接口更易读。</li></ul><h4 id="_4-对比-不用-pick-会怎么样" tabindex="-1"><a class="header-anchor" href="#_4-对比-不用-pick-会怎么样"><span>4. 对比：不用 <code>Pick</code> 会怎么样？</span></a></h4><p>如果不用 <code>Pick</code>，你需要手动写一个新接口：</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code><span class="line"><span class="token comment">// 手动定义基础分页类型（等价于 Pick 的效果，但冗余）</span></span>
<span class="line"><span class="token keyword">interface</span> <span class="token class-name">BaseCriteria</span> <span class="token punctuation">{</span></span>
<span class="line">  page<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span></span>
<span class="line">  pageSize<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">const</span> getBaseCriteria <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> BaseCriteria <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token punctuation">{</span> page<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> pageSize<span class="token operator">:</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种方式可行，但如果 <code>SearchCriteria</code> 中的 <code>page</code>/<code>pageSize</code> 类型修改（比如 <code>pageSize</code> 改成 <code>10 | 20 | 50</code>），你需要同时改 <code>BaseCriteria</code>，而用 <code>Pick</code> 会自动同步，更高效。</p><h3 id="二、代码中-pick-的实际作用" tabindex="-1"><a class="header-anchor" href="#二、代码中-pick-的实际作用"><span>二、代码中 <code>Pick</code> 的实际作用</span></a></h3><p>在 <code>getBaseCriteria</code> 函数中：</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code><span class="line"><span class="token keyword">const</span> getBaseCriteria <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Pick<span class="token operator">&lt;</span>SearchCriteria<span class="token punctuation">,</span> <span class="token string">&quot;page&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;pageSize&quot;</span><span class="token operator">&gt;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token punctuation">{</span></span>
<span class="line">    page<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token comment">// 快捷筛选强制重置到第1页</span></span>
<span class="line">    pageSize<span class="token operator">:</span> localCriteria<span class="token punctuation">.</span>pageSize <span class="token operator">||</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token comment">// 保留用户之前设置的页大小</span></span>
<span class="line">  <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>返回值类型被 <code>Pick</code> 约束，确保函数只能返回 <code>page</code> 和 <code>pageSize</code>，不会混入 <code>startTime</code> 等筛选字段；</li><li>结合后续的 <code>...getBaseCriteria()</code> + <code>...filterCriteria</code>，能精准实现「仅保留分页字段 + 当前快捷筛选条件」，彻底避免旧筛选条件残留。</li></ul><h2 id="usecallback" tabindex="-1"><a class="header-anchor" href="#usecallback"><span>useCallback</span></a></h2><p>在 <code>useCallback</code>中列出依赖项数组，本质上是在告诉 React：“<strong>只有当这个数组里的值发生变化时，才需要重新创建我包裹的这个函数。</strong>” 这是 React 用来优化性能、避免不必要的函数重建和组件重新渲染的核心机制。</p><p>为了快速抓住要点，我们先通过下面这个表格来直观理解不同依赖项设置的作用：</p><table><thead><tr><th style="text-align:left;">依赖项数组配置</th><th style="text-align:left;">函数何时重新创建？</th><th style="text-align:left;">常见使用场景与注意事项</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>空数组 <code>[]</code></strong></td><td style="text-align:left;"><strong>仅在组件首次渲染时创建一次</strong>，之后无论组件如何重新渲染，函数引用始终不变。</td><td style="text-align:left;">适用于不依赖任何组件内部状态或props的函数，例如一个固定的操作提示。需<strong>确保函数内部确实不依赖任何会变化的值</strong>，否则可能引用到旧的 state 或 props（闭包陷阱）。</td></tr><tr><td style="text-align:left;"><strong>包含特定依赖 <code>[dep1, dep2]</code></strong></td><td style="text-align:left;">在<strong>首次渲染时创建</strong>，之后<strong>仅当 <code>dep1</code>或 <code>dep2</code>的值发生变化时</strong>才会重新创建。</td><td style="text-align:left;">这是<strong>最常用和推荐</strong>的方式。用于函数内部使用了某些状态、props或函数的情况。能精准控制函数更新，平衡性能与逻辑正确性。</td></tr><tr><td style="text-align:left;"><strong>省略依赖项（不推荐）</strong></td><td style="text-align:left;"><strong>每次组件渲染时都会重新创建</strong>一个新的函数，等同于没有使用 <code>useCallback</code>。</td><td style="text-align:left;"><strong>基本失去了使用 <code>useCallback</code>的意义</strong>。ESLint 规则通常会对此发出警告，应避免这种写法。</td></tr></tbody></table><h3 id="💡-核心机制-理解闭包与稳定性" tabindex="-1"><a class="header-anchor" href="#💡-核心机制-理解闭包与稳定性"><span>💡 核心机制：理解闭包与稳定性</span></a></h3><p>依赖项列表之所以如此重要，深层原因与 JavaScript 的<strong>闭包</strong>机制有关。</p><ul><li><strong>保证逻辑正确性</strong>：当函数内部引用了组件状态（如 <code>state</code>）、<code>props</code>或其他在函数外部定义的变量时，这个函数会“记住”它被创建时所处的作用域（即形成闭包）。如果你在依赖项数组中遗漏了某个变量，<code>useCallback</code>返回的函数将继续使用该变量最初被“捕获”的值（旧值），从而导致逻辑错误。明确列出所有依赖，就是确保函数总能访问到这些变量的最新值。</li><li><strong>提供稳定性</strong>：在 React 中，一个函数如果被传递给子组件，或者作为其他 Hook（如 <code>useEffect</code>）的依赖，其引用的稳定性至关重要。<code>useCallback</code>通过依赖项数组来控制函数引用的变化，只有依赖项真的变了，函数引用才变。这种稳定性是 <code>React.memo</code>等优化手段能够生效的前提。</li></ul><h2 id="useeffect" tabindex="-1"><a class="header-anchor" href="#useeffect"><span>useEffect</span></a></h2><h3 id="一、基础用法" tabindex="-1"><a class="header-anchor" href="#一、基础用法"><span>一、基础用法</span></a></h3><p><code>useEffect(() =&gt; { fetchUserList(); }, [fetchUserList])</code> 核心拆解：这行代码是 React 中「副作用管理 + 依赖控制」的典型写法，我们先拆成<strong>基础结构</strong>和<strong>业务逻辑</strong>两层讲解，再对比 Vue3 帮你理解，最后讲这么写的「为什么」。</p><h4 id="_1-先懂-useeffect-基础语法" tabindex="-1"><a class="header-anchor" href="#_1-先懂-useeffect-基础语法"><span>1. 先懂 <code>useEffect</code> 基础语法</span></a></h4><p><code>useEffect</code> 是 React 处理「副作用」的核心 Hook，语法结构：</p><div class="language-tsx line-numbers-mode" data-highlighter="prismjs" data-ext="tsx"><pre><code><span class="line"><span class="token function">useEffect</span><span class="token punctuation">(</span></span>
<span class="line">  <span class="token comment">// 第一个参数：副作用回调函数（要执行的逻辑，比如请求、DOM操作、监听）</span></span>
<span class="line">  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">/* 要执行的代码 */</span> <span class="token punctuation">}</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token comment">// 第二个参数：依赖数组（决定回调函数「什么时候执行」）</span></span>
<span class="line">  <span class="token punctuation">[</span>依赖<span class="token number">1</span><span class="token punctuation">,</span> 依赖<span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">]</span></span>
<span class="line"><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p><strong>副作用</strong>：指「不属于组件渲染本身，但需要在渲染后执行的逻辑」（比如网络请求、操作 DOM、添加事件监听、修改全局变量等）；</p></li><li><p>依赖数组的规则</p><p>：只有数组里的变量 / 函数「引用发生变化」时，回调函数才会重新执行；</p><ul><li>依赖数组为空 <code>[]</code>：仅在组件<strong>首次挂载</strong>时执行 1 次（类比 Vue3 的 <code>onMounted</code>）；</li><li>依赖数组有值：组件挂载时执行 1 次 + 依赖项变化时再执行；</li><li>不写依赖数组：组件<strong>每次渲染 / 更新</strong>都执行（极度不推荐，会导致无限循环）。</li></ul></li></ul><h4 id="_2-拆解你问的这段代码" tabindex="-1"><a class="header-anchor" href="#_2-拆解你问的这段代码"><span>2. 拆解你问的这段代码</span></a></h4><div class="language-tsx line-numbers-mode" data-highlighter="prismjs" data-ext="tsx"><pre><code><span class="line"><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function">fetchUserList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 执行「获取用户列表」的网络请求</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>fetchUserList<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 依赖：fetchUserList 函数的引用</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_1-回调函数-fetchuserlist" tabindex="-1"><a class="header-anchor" href="#_1-回调函数-fetchuserlist"><span>（1）回调函数：<code>() =&gt; { fetchUserList(); }</code></span></a></h5><p>作用很简单：执行封装好的网络请求函数 <code>fetchUserList</code>，获取用户列表数据。</p><h5 id="_2-依赖数组-fetchuserlist" tabindex="-1"><a class="header-anchor" href="#_2-依赖数组-fetchuserlist"><span>（2）依赖数组：<code>[fetchUserList]</code></span></a></h5><p>核心是「监听 <code>fetchUserList</code> 函数的引用变化」—— 只有 <code>fetchUserList</code> 的引用变了，这个 <code>useEffect</code> 才会重新执行。</p><p>结合之前案例中 <code>fetchUserList</code> 被 <code>useCallback</code> 包裹的背景：</p><div class="language-tsx line-numbers-mode" data-highlighter="prismjs" data-ext="tsx"><pre><code><span class="line"><span class="token keyword">const</span> fetchUserList <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">// 依赖 searchParams 做请求</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>searchParams<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// fetchUserList 仅在 searchParams 变化时，引用才会更新</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以这行 <code>useEffect</code> 的<strong>实际执行逻辑</strong>是：</p><table><thead><tr><th>场景</th><th>执行行为</th><th>类比 Vue3</th></tr></thead><tbody><tr><td>组件首次挂载</td><td><code>fetchUserList</code> 有初始引用 → <code>useEffect</code> 执行 → 调用 <code>fetchUserList</code> 发初始请求</td><td><code>onMounted(() =&gt; fetchUserList())</code></td></tr><tr><td><code>searchParams</code> 变化（比如关键词 / 页码改了）</td><td><code>fetchUserList</code> 的 <code>useCallback</code> 检测到 <code>searchParams</code> 变 → <code>fetchUserList</code> 引用更新 → <code>useEffect</code> 检测到依赖变化 → 重新执行 → 调用新的 <code>fetchUserList</code> 发请求</td><td><code>watch(searchParams, () =&gt; fetchUserList(), { immediate: true })</code></td></tr><tr><td>组件其他状态变化（比如弹窗显隐）</td><td><code>searchParams</code> 没变化 → <code>fetchUserList</code> 引用不变 → <code>useEffect</code> 不执行 → 避免重复请求</td><td>无对应操作（Vue3 不监听无关状态）</td></tr></tbody></table><h3 id="二、为什么要这么写" tabindex="-1"><a class="header-anchor" href="#二、为什么要这么写"><span>二、为什么要这么写？</span></a></h3><p>（核心：避免闭包陷阱 + 减少无效请求）你可能会问：「为什么不直接把依赖写成 <code>[searchParams]</code>，比如 <code>useEffect(() =&gt; { fetchUserList(); }, [searchParams])</code>？」两种写法都能实现「searchParams 变化时重新请求」，但 <code>[fetchUserList]</code> 是更严谨的写法，原因如下：</p><h4 id="_1-避免「闭包陷阱」" tabindex="-1"><a class="header-anchor" href="#_1-避免「闭包陷阱」"><span>1. 避免「闭包陷阱」</span></a></h4><p>React 函数组件每次渲染都会创建新的变量 / 函数，<code>fetchUserList</code> 内部如果依赖多个外部变量（比如 <code>setLoading</code>、<code>message</code>、<code>searchParams</code>），直接依赖 <code>searchParams</code> 可能导致 <code>fetchUserList</code> 捕获「旧的闭包值」：</p><div class="language-tsx line-numbers-mode" data-highlighter="prismjs" data-ext="tsx"><pre><code><span class="line"><span class="token comment">// 反例：直接依赖 searchParams，可能出问题</span></span>
<span class="line"><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">// 假设 fetchUserList 没包 useCallback，这里的 fetchUserList 是「当前渲染周期的旧版本」</span></span>
<span class="line">  <span class="token comment">// 可能拿到的是旧的 searchParams/setLoading 引用</span></span>
<span class="line">  <span class="token function">fetchUserList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>searchParams<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而通过依赖「被 <code>useCallback</code> 包裹的 <code>fetchUserList</code>」，能保证每次执行的 <code>fetchUserList</code> 都是「最新的」（包含最新的 <code>searchParams</code>、<code>setLoading</code> 等依赖），彻底避免闭包陷阱。</p><h4 id="_2-符合-react-hooks-规则" tabindex="-1"><a class="header-anchor" href="#_2-符合-react-hooks-规则"><span>2. 符合 React Hooks 规则</span></a></h4><p>ESLint 的 <code>react-hooks/exhaustive-deps</code> 规则要求：<strong>useEffect 回调中用到的所有外部变量 / 函数，必须加入依赖数组</strong>。因为 <code>fetchUserList</code> 是回调中调用的外部函数，所以必须加入依赖；如果漏加，会触发报错，且可能导致逻辑异常。</p><h3 id="三、和-vue3-对比" tabindex="-1"><a class="header-anchor" href="#三、和-vue3-对比"><span>三、和 Vue3 对比</span></a></h3><p>React 的 <code>useEffect(() =&gt; { fetchUserList(); }, [fetchUserList])</code> 等价于 Vue3 中：</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code><span class="line"><span class="token comment">// Vue3 写法（onMounted + watch，且 watch 立即执行）</span></span>
<span class="line"><span class="token keyword">import</span> <span class="token punctuation">{</span> onMounted<span class="token punctuation">,</span> watch <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 组件挂载时执行一次</span></span>
<span class="line"><span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function">fetchUserList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 监听 fetchUserList 的依赖（searchParams）变化，重新执行</span></span>
<span class="line"><span class="token comment">// （Vue3 中无需监听函数本身，因为 Vue 的响应式是「自动的」）</span></span>
<span class="line"><span class="token function">watch</span><span class="token punctuation">(</span></span>
<span class="line">  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span>searchParams<span class="token punctuation">.</span>page<span class="token punctuation">,</span> searchParams<span class="token punctuation">.</span>keyword<span class="token punctuation">,</span> searchParams<span class="token punctuation">.</span>pageSize<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 监听 searchParams 核心字段</span></span>
<span class="line">  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">fetchUserList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token punctuation">{</span> immediate<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span> <span class="token comment">// 立即执行（等价于组件挂载时执行）</span></span>
<span class="line"><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>核心差异：</p><ul><li>Vue3：响应式是「自动的」，监听数据即可，无需关心函数引用；</li><li>React：是「显式依赖」，必须通过依赖数组声明要监听的变量 / 函数，且函数引用的稳定性需要用 <code>useCallback</code> 保证。</li></ul><h3 id="四、常见误区-注意事项" tabindex="-1"><a class="header-anchor" href="#四、常见误区-注意事项"><span>四、常见误区 &amp; 注意事项</span></a></h3><ol><li><p>依赖数组漏写 <code>fetchUserList</code>：</p><p>ESLint 会报错，且可能导致fetchUserList捕获旧的闭包值（比如拿到旧的searchParams），请求参数错误。</p></li><li><p><code>fetchUserList</code> 不包 <code>useCallback</code>：</p><p>每次组件渲染都会创建新的fetchUserList引用，导致useEffect每次都执行，触发重复请求（比如组件渲染 10 次，请求 10 次）。</p></li><li><p>依赖数组写空 <code>[]</code></p><p>仅挂载时执行 1 次，后续searchParams变化不会重新请求，筛选 / 分页功能失效。</p></li></ol><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p><code>useEffect(() =&gt; { fetchUserList(); }, [fetchUserList])</code> 的核心目的是：<strong>保证「只有当搜索参数（searchParams）变化时，才重新执行用户列表请求」，同时通过 <code>useCallback</code> 保证 <code>fetchUserList</code> 引用稳定，避免重复请求和闭包陷阱，完全符合 React Hooks 的规则</strong>。</p><h2 id="prev" tabindex="-1"><a class="header-anchor" href="#prev"><span>prev</span></a></h2><h3 id="一、prev-核心含义" tabindex="-1"><a class="header-anchor" href="#一、prev-核心含义"><span>一、<code>prev</code> 核心含义</span></a></h3><p><code>prev</code> 是 React 状态更新函数（如 <code>setSearchParams</code>）传给「函数式更新回调」的<strong>参数</strong>，代表「当前要更新的状态的最新快照」（即更新操作执行前，<code>searchParams</code> 的完整值）。</p><p>简单说：<code>prev = 更新前的 searchParams</code>，你可以把它理解为「状态的临时替身」，用来基于旧状态生成新状态。</p><h3 id="二、代码场景拆解" tabindex="-1"><a class="header-anchor" href="#二、代码场景拆解"><span>二、代码场景拆解</span></a></h3><p>你的代码：</p><div class="language-tsx line-numbers-mode" data-highlighter="prismjs" data-ext="tsx"><pre><code><span class="line"><span class="token keyword">const</span> <span class="token function-variable function">handleKeywordChange</span> <span class="token operator">=</span> <span class="token punctuation">(</span>e<span class="token operator">:</span> React<span class="token punctuation">.</span>ChangeEvent<span class="token operator">&lt;</span>HTMLInputElement<span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function">setSearchParams</span><span class="token punctuation">(</span>prev <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span></span>
<span class="line">    <span class="token operator">...</span>prev<span class="token punctuation">,</span> <span class="token comment">// 复制更新前的所有搜索参数（如pageSize、startTime等）</span></span>
<span class="line">    keyword<span class="token operator">:</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">,</span> <span class="token comment">// 覆盖关键词字段</span></span>
<span class="line">    page<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token comment">// 重置页码为1</span></span>
<span class="line">  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1-为什么要用「函数式更新」-prev" tabindex="-1"><a class="header-anchor" href="#_1-为什么要用「函数式更新」-prev"><span>1. 为什么要用「函数式更新」（<code>prev =&gt; {...}</code>）？</span></a></h4><p>React 的 <code>setXxx</code> 状态更新<strong>可能是异步的</strong>（比如频繁触发时，React 会批量更新），如果直接写：</p><div class="language-tsx line-numbers-mode" data-highlighter="prismjs" data-ext="tsx"><pre><code><span class="line"><span class="token comment">// 不推荐：可能拿到旧的 searchParams（闭包陷阱）</span></span>
<span class="line"><span class="token function">setSearchParams</span><span class="token punctuation">(</span><span class="token punctuation">{</span></span>
<span class="line">  <span class="token operator">...</span>searchParams<span class="token punctuation">,</span> <span class="token comment">// 这里的 searchParams 可能是组件渲染时的旧值</span></span>
<span class="line">  keyword<span class="token operator">:</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">,</span></span>
<span class="line">  page<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而用 <code>prev</code> 作为参数的函数式更新，能<strong>保证 <code>prev</code> 永远是「更新前的最新状态」</strong>，避免因异步更新导致的状态错误。</p><h4 id="_2-举个具体例子-帮你理解" tabindex="-1"><a class="header-anchor" href="#_2-举个具体例子-帮你理解"><span>2. 举个具体例子（帮你理解）</span></a></h4><p>假设当前 <code>searchParams</code> 是：</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code><span class="line"><span class="token punctuation">{</span> keyword<span class="token operator">:</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">,</span> page<span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> pageSize<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span> startTime<span class="token operator">:</span> <span class="token string">&quot;2025-01-01&quot;</span> <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>用户输入关键词「张三」触发 <code>handleKeywordChange</code> 时：</p><ul><li><code>prev</code> = <code>{ keyword: &quot;&quot;, page: 3, pageSize: 10, startTime: &quot;2025-01-01&quot; }</code>（更新前的完整状态）；</li><li><code>...prev</code> 复制所有旧字段；</li><li>覆盖 <code>keyword</code> 为「张三」，重置 <code>page</code> 为 1；</li><li>最终新的 <code>searchParams</code> = <code>{ keyword: &quot;张三&quot;, page: 1, pageSize: 10, startTime: &quot;2025-01-01&quot; }</code>。</li></ul><h3 id="三、关键注意点" tabindex="-1"><a class="header-anchor" href="#三、关键注意点"><span>三、关键注意点</span></a></h3><ol><li><p><code>prev</code> 是「只读快照」：你可以读取 <code>prev</code> 的值，但不要直接修改它（比如 <code>prev.page = 1</code>），必须通过「解构 + 覆盖」生成新对象（React 状态不可变）；</p></li><li><p>函数式更新的适用场景：只要你的新状态「依赖旧状态」（比如修改旧状态的某个字段、基于旧值计算新值），就用 <code>prev =&gt; {...}</code> 这种写法；</p></li><li><p>类比 Vue3：Vue3 中ref的函数式更新和这个逻辑一致，比如：</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code><span class="line"><span class="token comment">// Vue3 函数式更新（和 React prev 作用相同）</span></span>
<span class="line"><span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">count<span class="token punctuation">.</span><span class="token function-variable function">value</span> <span class="token operator">=</span> <span class="token punctuation">(</span>prev<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> prev <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// prev = 更新前的 count 值</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><h3 id="四、总结" tabindex="-1"><a class="header-anchor" href="#四、总结"><span>四、总结</span></a></h3><p><code>prev</code> 就是「更新前的状态副本」，用函数式更新（<code>prev =&gt; {...}</code>）能保证基于最新的旧状态生成新状态，避免 React 异步更新导致的「闭包陷阱」，是修改「对象 / 数组类型状态」的标准写法（因为 React 状态不可直接修改，必须基于旧状态创建新状态）。</p></div><!--[--><!--]--></div><footer class="vp-page-meta"><!----><div class="vp-meta-item git-info"><div class="vp-meta-item last-updated"><span class="meta-item-label">最近更新：: </span><time class="meta-item-info" datetime="2025-12-12T08:58:45.000Z" data-allow-mismatch>2025/12/12 16:58</time></div><div class="vp-meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: wh8261408@126.com">ksldnasx</span><!----><!--]--><!--]--></span></div></div></footer><!----><!--[--><!--]--></main><!--]--></div><!--[--><!----><!----><div class="social-share-global"><!----><button class="social-share-btn social-share-trigger" type="button" role="button" aria-label="Toggle global social share"><span class="social-share-icon-svg"><svg viewBox="0 0 1040 1024" xmlns="http://www.w3.org/2000/svg">
  <path d="M823.506 631.474c0-7.192-3.783-12.397-11.352-15.71-6.816-2.838-13.154-1.419-18.925 4.352-9.37 8.612-19.116 15.33-29.24 19.968-6.529 3.594-9.745 8.801-9.745 15.71V771.53c0 23.753-8.516 44.195-25.455 61.132-16.938 16.936-37.283 25.455-61.132 25.455H217.765c-23.753 0-44.195-8.517-61.131-25.455-16.937-16.939-25.455-37.284-25.455-61.132V321.639c0-23.753 8.516-44.195 25.455-61.132s37.283-25.455 61.131-25.455h60.565c2.175 0 5.016-.757 8.612-2.174 20.156-12.304 44.195-23.091 71.921-32.459 9.37-1.799 14.1-7.57 14.1-17.317 0-4.734-1.703-8.708-5.108-12.208-3.407-3.407-7.476-5.108-12.208-5.108h-137.88c-42.87 0-79.588 15.235-110.06 45.707S62 278.683 62 321.553V771.54c0 42.87 15.234 79.588 45.707 110.06s67.19 45.707 110.06 45.707H667.66c42.87 0 79.589-15.234 110.06-45.707 30.472-30.473 45.708-67.19 45.708-110.06l.095-140.06-.016-.006zm138.454-292.52c0-9.369-3.408-17.506-10.315-24.32L744.016 107.005c-6.815-6.815-14.953-10.315-24.32-10.315-4.353 0-8.802.945-13.535 2.745-14.1 6.15-21.106 16.75-21.106 31.891v103.812h-86.497c-38.235 0-73.625 1.986-106.273 5.962-32.648 3.976-61.42 9.465-86.215 16.468-24.887 7.004-47.315 15.805-67.282 26.214-19.967 10.41-37 21.576-51.104 33.217-14.103 11.64-26.403 25.077-37 40.03-10.598 14.953-19.117 29.62-25.456 44.097-6.34 14.387-11.352 30.285-15.142 47.604-3.783 17.317-6.341 33.5-7.571 48.64-1.229 15.143-1.893 31.514-1.893 49.212 0 20.157 3.125 42.208 9.465 65.959 6.34 23.753 13.25 44.384 20.818 61.608 7.571 17.317 16.468 35.207 26.784 53.848 10.315 18.55 17.413 30.945 21.387 37.001 3.977 6.15 7.76 11.736 11.353 16.75 3.595 4.733 8.327 7.004 14.1 7.004 1.42 0 3.595-.381 6.529-1.042 8.327-3.977 11.925-10.126 10.787-18.358-16.184-121.134-2.838-206.4 40.03-255.797 41.452-47.222 120.376-70.88 236.868-70.88h86.497v103.81c0 15.143 7.004 25.742 21.106 31.892 4.734 1.799 9.18 2.745 13.534 2.745 9.745 0 17.887-3.408 24.321-10.316L951.83 363.178c6.716-6.815 10.126-14.858 10.126-24.227l.004.004z" />
</svg></span></button></div><!--]--><!--]--></div>
    <script type="module" src="/vuepress_blog/assets/app-UmXydJji.js" defer></script>
  </body>
</html>
